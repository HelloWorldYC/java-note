<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>微服务介绍 | java</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/java-note/images/myfavicon.png">
    <meta name="description" content="java 学习笔记">
    
    <link rel="preload" href="/java-note/assets/css/0.styles.f5140cd9.css" as="style"><link rel="preload" href="/java-note/assets/js/app.b4e76d81.js" as="script"><link rel="preload" href="/java-note/assets/js/2.af1aff5f.js" as="script"><link rel="preload" href="/java-note/assets/js/1.b527e11e.js" as="script"><link rel="preload" href="/java-note/assets/js/14.cde1b595.js" as="script"><link rel="prefetch" href="/java-note/assets/js/10.a284a5f0.js"><link rel="prefetch" href="/java-note/assets/js/11.63d78869.js"><link rel="prefetch" href="/java-note/assets/js/12.411148a2.js"><link rel="prefetch" href="/java-note/assets/js/13.a6d8e7b5.js"><link rel="prefetch" href="/java-note/assets/js/15.c815dbff.js"><link rel="prefetch" href="/java-note/assets/js/16.f89ca76d.js"><link rel="prefetch" href="/java-note/assets/js/17.b43ef999.js"><link rel="prefetch" href="/java-note/assets/js/18.f1ca2df4.js"><link rel="prefetch" href="/java-note/assets/js/19.d907bdbe.js"><link rel="prefetch" href="/java-note/assets/js/20.ba076c76.js"><link rel="prefetch" href="/java-note/assets/js/21.f7bf66e3.js"><link rel="prefetch" href="/java-note/assets/js/22.941a47dc.js"><link rel="prefetch" href="/java-note/assets/js/23.b9156e83.js"><link rel="prefetch" href="/java-note/assets/js/24.07b1cd92.js"><link rel="prefetch" href="/java-note/assets/js/25.5be29da5.js"><link rel="prefetch" href="/java-note/assets/js/26.2dd5fb9f.js"><link rel="prefetch" href="/java-note/assets/js/27.02358944.js"><link rel="prefetch" href="/java-note/assets/js/28.306847f8.js"><link rel="prefetch" href="/java-note/assets/js/29.270a4d53.js"><link rel="prefetch" href="/java-note/assets/js/3.313cba90.js"><link rel="prefetch" href="/java-note/assets/js/30.bfc6c248.js"><link rel="prefetch" href="/java-note/assets/js/31.fffd5f77.js"><link rel="prefetch" href="/java-note/assets/js/32.ac467fad.js"><link rel="prefetch" href="/java-note/assets/js/33.70479154.js"><link rel="prefetch" href="/java-note/assets/js/34.4e48aa0b.js"><link rel="prefetch" href="/java-note/assets/js/35.724f00a7.js"><link rel="prefetch" href="/java-note/assets/js/36.170daa7d.js"><link rel="prefetch" href="/java-note/assets/js/37.53f51c04.js"><link rel="prefetch" href="/java-note/assets/js/38.4e8ccf8d.js"><link rel="prefetch" href="/java-note/assets/js/39.4677e6bb.js"><link rel="prefetch" href="/java-note/assets/js/4.953ceea1.js"><link rel="prefetch" href="/java-note/assets/js/40.b55e76ef.js"><link rel="prefetch" href="/java-note/assets/js/41.fe541156.js"><link rel="prefetch" href="/java-note/assets/js/42.6f36570a.js"><link rel="prefetch" href="/java-note/assets/js/43.f7e4b8ba.js"><link rel="prefetch" href="/java-note/assets/js/44.668b7294.js"><link rel="prefetch" href="/java-note/assets/js/45.02de4e09.js"><link rel="prefetch" href="/java-note/assets/js/46.0b9a3a33.js"><link rel="prefetch" href="/java-note/assets/js/47.6978a7f4.js"><link rel="prefetch" href="/java-note/assets/js/48.036c9aa2.js"><link rel="prefetch" href="/java-note/assets/js/49.a77067f4.js"><link rel="prefetch" href="/java-note/assets/js/5.5d5d288a.js"><link rel="prefetch" href="/java-note/assets/js/50.50d9308b.js"><link rel="prefetch" href="/java-note/assets/js/51.f5490448.js"><link rel="prefetch" href="/java-note/assets/js/52.446d87e0.js"><link rel="prefetch" href="/java-note/assets/js/53.8779543f.js"><link rel="prefetch" href="/java-note/assets/js/54.94dc9f6f.js"><link rel="prefetch" href="/java-note/assets/js/55.8d7d0d45.js"><link rel="prefetch" href="/java-note/assets/js/56.69820a1b.js"><link rel="prefetch" href="/java-note/assets/js/57.fcaa4ea6.js"><link rel="prefetch" href="/java-note/assets/js/58.0fd49238.js"><link rel="prefetch" href="/java-note/assets/js/59.79c04a76.js"><link rel="prefetch" href="/java-note/assets/js/6.3c0fcba4.js"><link rel="prefetch" href="/java-note/assets/js/60.f35494a3.js"><link rel="prefetch" href="/java-note/assets/js/61.39888619.js"><link rel="prefetch" href="/java-note/assets/js/62.0d59237f.js"><link rel="prefetch" href="/java-note/assets/js/63.6d693cde.js"><link rel="prefetch" href="/java-note/assets/js/64.47d66d8e.js"><link rel="prefetch" href="/java-note/assets/js/65.fbcd58d8.js"><link rel="prefetch" href="/java-note/assets/js/66.962b42b1.js"><link rel="prefetch" href="/java-note/assets/js/67.563f535c.js"><link rel="prefetch" href="/java-note/assets/js/68.0c74e1c4.js"><link rel="prefetch" href="/java-note/assets/js/69.242f9577.js"><link rel="prefetch" href="/java-note/assets/js/7.93de78a3.js"><link rel="prefetch" href="/java-note/assets/js/70.3a3fb003.js"><link rel="prefetch" href="/java-note/assets/js/vendors~docsearch.d01c1f3f.js">
    <link rel="stylesheet" href="/java-note/assets/css/0.styles.f5140cd9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/java-note/" class="home-link router-link-active"><!----> <span class="site-name">java</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java框架</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>微服务</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-note/Java/Java框架/微服务/微服务介绍.html" class="active sidebar-link">微服务介绍</a></li><li><a href="/java-note/Java/Java框架/微服务/Docker入门.html" class="sidebar-link">Docker入门</a></li><li><a href="/java-note/Java/Java框架/微服务/RabbitMQ入门.html" class="sidebar-link">RabbitMQ 入门</a></li><li><a href="/java-note/Java/Java框架/微服务/Elasticsearch入门.html" class="sidebar-link">Elasticsearch入门</a></li></ul></section></li><li><a href="/java-note/Java/Java框架/Kafka.html" class="sidebar-link">Kafka</a></li><li><a href="/java-note/Java/Java框架/SpringSecurity.html" class="sidebar-link">Spring Security</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>校园信息交流平台项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>简易RPC框架项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>内功</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>知识点自测速记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="认识微服务"><a href="#认识微服务" class="header-anchor">#</a> 认识微服务</h2> <h3 id="单体架构"><a href="#单体架构" class="header-anchor">#</a> 单体架构</h3> <p>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。</p> <div align="center"><img src="/java-note/assets/img/单体架构.99468535.png" width="100%"></div> <p>优点：</p> <ul><li>架构简单</li> <li>部署成本低</li></ul> <p>缺点：</p> <ul><li>耦合度高</li> <li>扩展性差</li></ul> <h3 id="分布式架构"><a href="#分布式架构" class="header-anchor">#</a> 分布式架构</h3> <p>分布式架构：根据业务功能对系统进行拆分，每个业务模块作为独立项目开发，称为一个服务。</p> <div align="center"><img src="/java-note/assets/img/分布式架构.1754b1f2.png" width="100%"></div> <p>优点：</p> <ul><li>降低服务耦合</li> <li>有利于服务升级拓展</li></ul> <p>缺点：</p> <ul><li>架构复杂，难度大</li> <li>部署成本高</li></ul> <p>分布式架构的要考虑的问题：</p> <ul><li>服务拆分粒度如何？</li> <li>服务集群地址如何维护？</li> <li>服务之间如何实现远程调用？</li> <li>服务健康状态如何感知？</li></ul> <h3 id="微服务"><a href="#微服务" class="header-anchor">#</a> 微服务</h3> <p>微服务是一种经过良好架构设计的 <strong>分布式</strong> 架构方案，微服务架构特征：</p> <ul><li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责，避免重复业务开发。</li> <li>面向服务：微服务对外暴露业务接口。</li> <li>自治：团队独立、技术独立、数据独立（每个服务可以有自己的数据库）、部署独立。</li> <li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题。</li></ul> <p>优点：拆分粒度更小、服务更独立、耦合度更低。<br>
缺点：架构非常复杂，运维、监控、部署难度提高。</p> <h4 id="微服务的架构"><a href="#微服务的架构" class="header-anchor">#</a> 微服务的架构</h4> <p>微服务的架构一般来说包括以下几个方面：</p> <ul><li>注册中心</li> <li>配置中心</li> <li>服务集群</li> <li>服务网关</li></ul> <div align="center"><img src="/java-note/assets/img/微服务基本结构.9c56b14f.png" width="100%"></div> <h4 id="几种常见微服务技术对比"><a href="#几种常见微服务技术对比" class="header-anchor">#</a> 几种常见微服务技术对比</h4> <div align="center"><img src="/java-note/assets/img/几种常见微服务技术对比.6601807f.png" width="100%"></div> <h2 id="服务拆分及远程调用"><a href="#服务拆分及远程调用" class="header-anchor">#</a> 服务拆分及远程调用</h2> <h3 id="服务拆分"><a href="#服务拆分" class="header-anchor">#</a> 服务拆分</h3> <p>服务拆分注意事项：</p> <ol><li>不同微服务，要做到单一职责，不要重复开发相同业务</li> <li>微服务数据独立，不要访问其他微服务的数据库</li> <li>微服务可以将自己的业务暴露为接口，供其他微服务使用</li></ol> <h3 id="远程调用"><a href="#远程调用" class="header-anchor">#</a> 远程调用</h3> <p>远程调用的其中一种方式是基于 <code>RestTemplate</code> 发起 HTTP 请求。HTTP 请求做远程调用是与语言无关的调用，只要知道对方的 ip、端口、接口路径、请求参数即可。</p> <p>基于 <code>RestTemplate</code> 远程调用的步骤：</p> <ol><li>注册 <code>RestTemplate</code>，将其注册为 bean</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@MapperScan</span><span class="token punctuation">(</span><span class="token string">&quot;cn.itcast.order.mapper&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderApplication</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">OrderApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
    
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>服务远程调用 <code>RestTemplate</code></li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Autowired</span>    
    <span class="token keyword">private</span> <span class="token class-name">RestTemplate</span> restTemplate<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.查询订单        </span>
        <span class="token class-name">Order</span> order <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>        
        <span class="token comment">// TODO 2.查询用户         </span>
        <span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">&quot;http://localhost:8081/user/&quot;</span> <span class="token operator">+</span>  order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 因为是 get 查询，所以是 getForObject</span>
        <span class="token comment">// 虽然通过 HTTP 请求返回的是 JSON 数据，但是该方法可以指定返回类型，从而自动将 JSON 转换为目标类型</span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        
        <span class="token comment">// 3.封装user信息        </span>
        order<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>        
        <span class="token comment">// 4.返回        </span>
        <span class="token keyword">return</span> order<span class="token punctuation">;</span>    
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="eureka-注册中心"><a href="#eureka-注册中心" class="header-anchor">#</a> Eureka 注册中心</h2> <h3 id="远程调用的问题"><a href="#远程调用的问题" class="header-anchor">#</a> 远程调用的问题</h3> <ul><li>服务消费者应该如何获取服务提供者的地址信息？</li> <li>如果有多个服务提供者，消费者应该如何选择？</li> <li>消费者如何得知服务提供者的健康状态？</li></ul> <h3 id="eureka-原理"><a href="#eureka-原理" class="header-anchor">#</a> Eureka 原理</h3> <p>消费者该如何获取服务提供者具体信息？</p> <ul><li>服务提供者启动时向 Eureka 注册自己的信息</li> <li>Eureka 保存这些信息</li> <li>消费者根据服务名称向 Eureka 拉取提供者信息</li></ul> <p>如果有多个服务提供者，消费者应该如何选择？<br>
服务消费者可以利用负载均衡算法，从服务列表中挑选一个</p> <p>消费者如何感知服务提供者健康状态？</p> <ul><li>服务提供者会每隔30秒向 EurekaServer 发送心跳请求，报告健康状态</li> <li>Eureka 会更新记录服务列表信息，心跳不正常会被剔除</li> <li>消费者因此可以拉取到最新的信息</li></ul> <h3 id="搭建-eurekaserver"><a href="#搭建-eurekaserver" class="header-anchor">#</a> 搭建 EurekaServer</h3> <p>搭建 EurekaServer 的服务步骤如下：</p> <ol><li>创建项目，引入 <code>spring-cloud-starter-netflix-eureka-server</code> 依赖。因为 EurekaServer 本身也是一个微服务项目，这也意味着它启动时需要将自己也注册上去。</li></ol> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-server<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="2"><li>编写启动类，添加 <code>@EnableEurekaServer</code> 注解</li> <li>添加 application.yml 文件，编写配置</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10086</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> eurekaServer  <span class="token comment"># eureka 的服务名称</span>
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>        <span class="token comment"># eureka 的地址信息</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka/
</code></pre></div><h3 id="服务注册"><a href="#服务注册" class="header-anchor">#</a> 服务注册</h3> <p>一个微服务向 Eureka 注册的步骤如下：</p> <ol><li>引入 <code>spring-cloud-starter-netflix-eureka-client</code> 依赖，注意，依赖末尾是 <code>client</code></li></ol> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-netflix-eureka-client<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="2"><li>在 application.yml 文件中编写配置信息</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>  
  <span class="token key atrule">application</span><span class="token punctuation">:</span>   
    <span class="token key atrule">name</span><span class="token punctuation">:</span> userservice      <span class="token comment"># 服务名称</span>
<span class="token key atrule">eureka</span><span class="token punctuation">:</span>  
  <span class="token key atrule">client</span><span class="token punctuation">:</span>    
    <span class="token key atrule">service-url</span><span class="token punctuation">:</span>            <span class="token comment"># eureka 的地址信息</span>
      <span class="token key atrule">defaultZone</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>10086/eureka/
</code></pre></div><h3 id="服务发现"><a href="#服务发现" class="header-anchor">#</a> 服务发现</h3> <p>基于 Eureka 做服务的拉取是基于服务名称获取服务列表，再对服务列表做负载均衡。</p> <p>基于 Eureka 做服务拉取的步骤如下：</p> <ol><li>修改访问的 url 路径，用服务名代替 ip、端口</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 原先的 url 路径</span>
<span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">&quot;http://127.0.0.1:8080/user/&quot;</span> <span class="token operator">+</span> order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//修改后的 url 路径</span>
<span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">&quot;http://userservice/user/&quot;</span> <span class="token operator">+</span> order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ol start="2"><li>在要做服务拉取的微服务中 <code>RestTemplate</code> 上添加 <code>@LoadBalanced</code> 注解;</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token annotation punctuation">@LoadBalanced</span>
<span class="token keyword">public</span> <span class="token class-name">RestTemplate</span> <span class="token function">restTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RestTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="ribbon-负载均衡"><a href="#ribbon-负载均衡" class="header-anchor">#</a> Ribbon 负载均衡</h2> <h3 id="负载均衡原理"><a href="#负载均衡原理" class="header-anchor">#</a> 负载均衡原理</h3> <div align="center"><img src="/java-note/assets/img/负载均衡流程.322d730e.png" width="100%"></div> <h3 id="负载均衡策略"><a href="#负载均衡策略" class="header-anchor">#</a> 负载均衡策略</h3> <p>Ribbon 的负载均衡规则是一个叫做 <code>IRule</code> 的接口来定义的，每一个子接口都是一种规则：<br></p><div align="center"><img src="/java-note/assets/img/IRule接口继承结构.a65f6fa4.png" width="100%"></div><p></p> <p>这些规则实现类的规则描述如下：<br></p><div align="center"><img src="/java-note/assets/img/负载均衡部分策略.12b625ae.png" width="100%"></div><p></p> <p>通过定义 <code>IRule</code> 的实现可以修改负载均衡策略，有两种方式：</p> <ol><li>代码方式：在 Application 启动类中，定义一个新的 <code>IRule</code> 并注册为 bean：</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">randomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>配置文件方式：在 application.yml 文件中，添加新的配置去修改：</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">userservice</span><span class="token punctuation">:</span>    <span class="token comment"># 要实现负载均衡的某个服务的名称</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule <span class="token comment"># 负载均衡规则</span>
</code></pre></div><h3 id="懒加载"><a href="#懒加载" class="header-anchor">#</a> 懒加载</h3> <p>Ribbon 默认是采用懒加载，即第一次访问时才回去创建 <code>LoadBalanceClient</code>，请求时间会比较长。<br>
而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
  <span class="token key atrule">eager-load</span><span class="token punctuation">:</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 开启饥饿加载 </span>
      <span class="token key atrule">clients</span><span class="token punctuation">:</span> userservice <span class="token comment"># 指定对 userservice 这个服务饥饿加载</span>
</code></pre></div><h2 id="nacos-注册中心"><a href="#nacos-注册中心" class="header-anchor">#</a> Nacos 注册中心</h2> <h3 id="认识-nacos"><a href="#认识-nacos" class="header-anchor">#</a> 认识 Nacos</h3> <p>Nacos 是阿里巴巴的产品，现在是 SpringCloud 的一个组件，相比于 Eureka 功能更加丰富，在国内受欢迎程度较高。</p> <p>Nacos 要使用前需要安装。<br>
安装完后需要进行端口的配置，Nacos 默认端口是 8848，若该端口已被占用，则可以修改配置文件 application.properties 中的端口。<br>
Nacos 的启动命令是：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>startup.cmd <span class="token parameter variable">-m</span> standalone   <span class="token comment"># 这个命令是单机启动的</span>
</code></pre></div><h3 id="服务注册到-nacos"><a href="#服务注册到-nacos" class="header-anchor">#</a> 服务注册到 Nacos</h3> <ol><li>在父工程中添加 <code>spring-cloud-alibaba</code> 的管理依赖，以管理版本。</li></ol> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-alibaba-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.2.6.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>type</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>type</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>import<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="2"><li>注释掉原有的 Eureka 依赖，因为它们可能会冲突。</li> <li>添加 Nacos 的客户端依赖：</li></ol> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="4"><li>修改 application.yml 文件，注释 Eureka 地址，添加 Nacos 地址：</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>     <span class="token comment"># Nacao 服务端地址</span>
</code></pre></div><h3 id="nacos-服务分级存储模型"><a href="#nacos-服务分级存储模型" class="header-anchor">#</a> Nacos 服务分级存储模型</h3> <p>Nacos 服务分级存储模型有三层：</p> <ol><li>一级是服务，例如 <code>userservice</code></li> <li>二级是集群，例如广州集群和深圳集群</li> <li>三级是实例，例如广州机房中的某台部署了 userservice 的服务器。</li></ol> <p>服务调用应尽可能选择本地集群的服务，跨集群调用延迟较高。本地集群不可访问时，再去访问其他集群。</p> <p>Nacos 修改服务所在集群的方式是修改 application.yml 文件，添加如下信息：</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment"># nacos 服务端地址</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> GZ <span class="token comment"># 配置集群名称，也就是机房位置，例如：GZ，广州</span>
</code></pre></div><h3 id="根据集群负载均衡"><a href="#根据集群负载均衡" class="header-anchor">#</a> 根据集群负载均衡</h3> <p>在修改服务所在的集群后，需要配置负载均衡规则，才能做到优先寻找与自己同集群的服务，这个规则是 <code>NacosRule</code>。</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">userservice</span><span class="token punctuation">:</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.alibaba.cloud.nacos.ribbon.NacosRule
</code></pre></div><p><code>NacosRule</code> 负载均衡策略的选择过程如下：</p> <ol><li>优先选择同集群服务实例列表</li> <li>本地集群找不到提供者，才去其他集群寻找，并且会报警告</li> <li>确定了可用实例列表之后，再采用随机负载均衡策略挑选实例。</li></ol> <p>此外，Nacos 还提供了权重配置来控制实例的访问频率，权重越大则访问频率越高，若权重为 0 则完全不会被访问。具体的配置步骤是在 Nacos 控制台选择实例进行权重编辑。</p> <div align="center"><img src="/java-note/assets/img/Nacos权重配置.47670804.png" width="100%"></div> <h3 id="环境隔离-namespace"><a href="#环境隔离-namespace" class="header-anchor">#</a> 环境隔离 - namespace</h3> <p>Nacos 中服务存储和数据存储的最外层都是一个名为 namespace 的东西，用以隔离不同环境。每个 namespace 都有唯一 id，不同 namespace 下的服务互相不可见。</p> <p>步骤如下：</p> <ol><li>在 Nacos 控制台创建 namespace，创建后该 namespace 会有一个唯一 id。</li> <li>修改具体服务中的 application.yml，给服务添加 namespace：</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">cluster-name</span><span class="token punctuation">:</span> GZ
        <span class="token key atrule">namespace</span><span class="token punctuation">:</span> 492a7d5d<span class="token punctuation">-</span>237b<span class="token punctuation">-</span>46a1<span class="token punctuation">-</span>a99a<span class="token punctuation">-</span>fa8e98e4b0f9 <span class="token comment"># 命名空间，填ID</span>
</code></pre></div><h3 id="nacos-注册中心原理细节"><a href="#nacos-注册中心原理细节" class="header-anchor">#</a> Nacos 注册中心原理细节</h3> <div align="center"><img src="/java-note/assets/img/Nacos注册中心原理细节.f62c2b85.png" width="100%"></div> <h3 id="临时实例和非临时实例"><a href="#临时实例和非临时实例" class="header-anchor">#</a> 临时实例和非临时实例</h3> <p>服务注册到 Nacos 时，可以选择注册为临时或非临时实例，通过下面的配置来设置：</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">discovery</span><span class="token punctuation">:</span>
        <span class="token key atrule">ephemeral</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>    <span class="token comment"># 设置为非临时实例</span>
</code></pre></div><p>临时实例宕机时，会从 Nacos 的服务列表中剔除，而非临时实例则不会。</p> <h3 id="nacos-与-eureka-对比"><a href="#nacos-与-eureka-对比" class="header-anchor">#</a> Nacos 与 Eureka 对比</h3> <p>Nacos 与 Eureka 共同点：</p> <ol><li>都支持服务注册和服务发现</li> <li>都支持服务提供者心跳方式做健康检测</li></ol> <p>Nacos 与 Eureka 区别：</p> <ol><li>Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式。</li> <li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除。</li> <li>Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时。</li> <li>Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 方式；Eureka 采用 AP 方式。</li></ol> <h2 id="nacos-配置管理"><a href="#nacos-配置管理" class="header-anchor">#</a> Nacos 配置管理</h2> <h3 id="统一配置管理"><a href="#统一配置管理" class="header-anchor">#</a> 统一配置管理</h3> <p>Nacos 提供了统一的配置管理功能，允许开发人员集中式地管理微服务架构中的配置信息，并在需要时动态刷新，无需重启微服务。</p> <p>Nacos 统一配置管理的步骤如下：</p> <ol><li><p>在 Nacos 控制台添加配置信息：
</p><div align="center"><img src="/java-note/assets/img/Nacos统一配置管理添加配置信息.bcf6e820.png" width="100%"></div><p></p></li> <li><p>在微服务中引入 Nacos 的配置管理客户端依赖：</p></li></ol> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token comment">&lt;!--nacos配置管理依赖--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-config<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="3"><li>在 resource 目录中添加一个 bootstrap.yml 文件，这个文件是引导文件，优先级高于 application.yml：</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> userservice <span class="token comment"># 服务名称</span>
  <span class="token key atrule">profiles</span><span class="token punctuation">:</span>
    <span class="token key atrule">active</span><span class="token punctuation">:</span> dev <span class="token comment"># 开发环境，这里是 dev </span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span> <span class="token comment"># Nacos地址</span>
      <span class="token key atrule">config</span><span class="token punctuation">:</span>
        <span class="token key atrule">file-extension</span><span class="token punctuation">:</span> yaml <span class="token comment"># 文件后缀名</span>
</code></pre></div><ol start="4"><li>将 application.yml 中原来关于这部分的配置注释掉</li></ol> <h4 id="为什么要新建一个-bootstrap-yml-文件去配置"><a href="#为什么要新建一个-bootstrap-yml-文件去配置" class="header-anchor">#</a> 为什么要新建一个 bootstrap.yml 文件去配置？</h4> <p>因为统一配置管理后，项目启动之后要先读取 Nacos 中配置文件的信息，再读取本地 application.yml 文件中的配置信息。而原来中对于 Nacos 的配置信息是在 application.yml 中，这样的话就无法在读取 Nacos 配置文件信息的时候找到 Nacos，因此要把 Nacos 配置信息放在更前的步骤中。bootstrap.yml 是引导文件，优先级更高，该文件的配置信息加载会优先于 Nacos 中统一配置文件信息的拉取。</p> <h3 id="配置热更新"><a href="#配置热更新" class="header-anchor">#</a> 配置热更新</h3> <p>Nacos 中的配置文件变更后，微服务无需重启就可以感知。不过需要通过下面两种配置实现：</p> <ol><li>在 <code>@Value</code> 注入的变量所在类上添加注解 <code>@RefreshScope</code></li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Slf4j</span>
<span class="token annotation punctuation">@RestController</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/user&quot;</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@RefreshScope</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserController</span><span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">&quot;${pattern.dateformat}&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> dateformat<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>使用 <code>@ConfigurationProperties</code> 注解读取配置</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Component</span>
<span class="token annotation punctuation">@Data</span>
<span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix<span class="token operator">=</span><span class="token string">&quot;pattern&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PatternProperties</span><span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> dateformat<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>注意：不是所有的配置都适合放到配置中心，维护起来比较麻烦，建议将一些关键参数，需要运行时调整的参数放到 nacos 配置中心</p></blockquote> <h3 id="配置共享"><a href="#配置共享" class="header-anchor">#</a> 配置共享</h3> <p>微服务启动时会从 nacos 读取多个配置文件：</p> <ol><li>[spring.application.name]-[spring.profile.active].yaml，例如 userservice-dev.yaml</li> <li>[spring.application.name].yaml，例如 userservice.yaml</li></ol> <p>无论 profile 如何变化，[spring.application.name].yaml 这个文件一定会加载，因此多环境共享配置可以写入这个文件。</p> <p>此外，不同微服务之间可以共享配置文件，通过下面的两种方式来指定：</p> <ol><li>方式一：</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">config</span><span class="token punctuation">:</span>
        <span class="token key atrule">shared-configs</span><span class="token punctuation">:</span>        <span class="token comment"># 多微服务间共享的配置列表</span>
          <span class="token key atrule">-dataId</span><span class="token punctuation">:</span> common.yaml  <span class="token comment"># 要共享的配置文件</span>
</code></pre></div><ol start="2"><li>方式二：</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">config</span><span class="token punctuation">:</span>
        <span class="token key atrule">extends-configs</span><span class="token punctuation">:</span>        <span class="token comment"># 多微服务间共享的配置列表</span>
          <span class="token key atrule">-dataId</span><span class="token punctuation">:</span> common.yaml  <span class="token comment"># 要共享的配置文件</span>
</code></pre></div><p>注意：这两种方式不支持热更新。</p> <p>若多个配置中有同一个配置，那么多种配置的优先级如下：</p> <ul><li>服务名称-profile.yaml &gt; 服务名称.yaml &gt; extension-config &gt; shared-config &gt; 本地配置</li></ul> <h3 id="搭建-nacos-集群"><a href="#搭建-nacos-集群" class="header-anchor">#</a> 搭建 Nacos 集群</h3> <p>Nacos 生产环境下一定要部署为集群状态，具体步骤可以搜，这里简要介绍一下步骤：</p> <ol><li>搭建 MySQL 集群并初始化数据库表，因为在集群模式下 Nacos 的配置信息等存放在数据库中</li> <li>下载解压 Nacos</li> <li>修改集群配置（节点信息）、数据库配置</li> <li>分别启动多个 Nacos 节点</li> <li>nginx 负载均衡和反向代理</li></ol> <h2 id="http-客户端-feign"><a href="#http-客户端-feign" class="header-anchor">#</a> http 客户端 Feign</h2> <h3 id="feign-替代-resttemplate"><a href="#feign-替代-resttemplate" class="header-anchor">#</a> Feign 替代 <code>RestTemplate</code></h3> <p>为什么要用 Feign 替代 <code>RestTemplate</code>？</p> <ol><li>代码可读性较差，编程体验不统一</li> <li>参数复杂的情况下 URL 难以维护</li></ol> <p>如下为 <code>RestTemplate</code> 发起远程调用的代码：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> url <span class="token operator">=</span> <span class="token string">&quot;http://userservice/user/&quot;</span> <span class="token operator">+</span> order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">User</span> user <span class="token operator">=</span> restTemplate<span class="token punctuation">.</span><span class="token function">getForObject</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token class-name">User</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Feign 是一个 <strong>声明式</strong> 的 HTTP 客户端，其作用就是帮助我们优雅地实现 HTTP 请求的发送，解决上面提到的问题。</p> <p>使用 Feign 的步骤如下：</p> <ol><li>引入依赖：</li></ol> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="2"><li>在服务的启动类添加 <code>@EnableFeignClients</code> 注解开启 Feign 的功能：</li> <li>编写 Feign 客户端：</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span><span class="token string">&quot;userservice&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserClient</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">&quot;/user/{id}&quot;</span><span class="token punctuation">)</span> 
    <span class="token class-name">User</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">&quot;id&quot;</span><span class="token punctuation">)</span> <span class="token class-name">Long</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它主要是基于 SpringMVC 的注解来声明远程调用的信息，比如：</p> <ul><li>服务名称：<code>userservice</code></li> <li>请求方式：<code>GET</code></li> <li>请求路径：<code>/user/{id}</code></li> <li>请求参数：<code>Long id</code></li> <li>返回值类型：<code>User</code></li></ul> <ol start="4"><li>使用 Feign 客户端中定义的方法代替 RestTemplate</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Autowired</span>
<span class="token keyword">private</span> <span class="token class-name">UserClient</span> userClient<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token class-name">Order</span> <span class="token function">queryOrderById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> orderId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Order</span> order <span class="token operator">=</span> orderMapper<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>orderId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 利用 Feign 发起 HTTP 请求，查询用户</span>
    <span class="token class-name">User</span> user <span class="token operator">=</span> userClient<span class="token punctuation">.</span><span class="token function">findById</span><span class="token punctuation">(</span>order<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    order<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> order<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="自定义配置"><a href="#自定义配置" class="header-anchor">#</a> 自定义配置</h3> <p>Feign 运行自定义配置来覆盖默认配置，可以修改的配置如下：
</p><div align="center"><img src="/java-note/assets/img/Feign自定义配置.10694748.png" width="100%"></div><p></p> <p>一般我们需要配置的就是日志级别。</p> <p>关于自定义 Feign 的配置，有两种方式：</p> <ol><li>通过配置文件的方式：</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">feign</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">config</span><span class="token punctuation">:</span> 
      <span class="token key atrule">default</span><span class="token punctuation">:</span> <span class="token comment"># 这里用 default 就是全局配置，如果是写服务名称如 userservice，则是针对某个微服务的配置</span>
        <span class="token key atrule">loggerLevel</span><span class="token punctuation">:</span> FULL <span class="token comment"># 日志级别 </span>
</code></pre></div><ol start="2"><li>通过 Java 代码的方式，不过需要先声明一个 Bean：</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FeignClientConfiguration</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">Logger<span class="token punctuation">.</span>Level</span> <span class="token function">feignLogLevel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Logger<span class="token punctuation">.</span>Level</span><span class="token punctuation">.</span><span class="token constant">BASIC</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>而后如果是全局配置，则把它放到 <code>@EnableFeignClients</code> 这个注解中：</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>defaultConfiguration <span class="token operator">=</span> <span class="token class-name">FeignClientConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> 
</code></pre></div><ul><li>如果是局部配置，则把它放到 <code>@FeignClient</code> 这个注解中：</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@FeignClient</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;userservice&quot;</span><span class="token punctuation">,</span> configuration <span class="token operator">=</span> <span class="token class-name">FeignClientConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> 
</code></pre></div><h3 id="feign-性能优化"><a href="#feign-性能优化" class="header-anchor">#</a> Feign 性能优化</h3> <p>Feign 底层的客户端实现：</p> <ul><li>URLConnection：默认实现，不支持连接池</li> <li>Apache HttpClient：支持连接池</li> <li>OKHttp：支持连接池</li></ul> <p>因此连接的重复创建会消耗大量资源，因此优化 Feign 的一个点就是使用连接池代替默认的 URLConnection。其次，FULL 和 HEADERS 的日志级别会打印大量日志，也会消耗资源，最好用 BASIC 或 NONE。</p> <p>对于连接池优化，以用 HttpClient 代替为例，步骤如下：</p> <ol><li>引入依赖：</li></ol> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token comment">&lt;!--httpClient的依赖 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.github.openfeign<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>feign-httpclient<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="2"><li>配置连接池：</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">feign</span><span class="token punctuation">:</span>
  <span class="token key atrule">client</span><span class="token punctuation">:</span>
    <span class="token key atrule">config</span><span class="token punctuation">:</span>
      <span class="token key atrule">default</span><span class="token punctuation">:</span>                      <span class="token comment"># default全局的配置</span>
      <span class="token key atrule">LoggerLevel</span><span class="token punctuation">:</span> BASIC            <span class="token comment"># 日志级别，BASIC就是基本的请求和响应信息 </span>
  <span class="token key atrule">httpclient</span><span class="token punctuation">:</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>                   <span class="token comment"># 开启feign对HttpClient的支持</span>
    <span class="token key atrule">max-connections</span><span class="token punctuation">:</span> <span class="token number">200</span>            <span class="token comment"># 最大的连接数</span>
    <span class="token key atrule">max-connections-per-route</span><span class="token punctuation">:</span> <span class="token number">50</span>   <span class="token comment"># 每个路径的最大连接数</span>
</code></pre></div><h3 id="feign-的最佳实践"><a href="#feign-的最佳实践" class="header-anchor">#</a> Feign 的最佳实践</h3> <p>之前使用 Feign 的缺点：</p> <ol><li>Feign 是在消费者端的，那么对于每一个消费者实例都要去做一个配置使用，这样相当于做了重复的开发，不好。</li> <li>其次，FeignClient 定义的方法要跟服务提供者提供的方法保持一致（方法名除外），不然调用不成功，也就是说，这两者是有很强的关系的，有点紧耦合的意思。</li></ol> <p>最佳实践的方式有两种：继承和抽取。<br>
方式一：继承。给消费者的 FeignClient 和服务提供者的 Controller 定义统一的父接口作为标准，如下所示：
</p><div align="center"><img src="/java-note/assets/img/Feign最佳实践之继承.2e442725.png" width="100%"></div><p></p> <p>这种方式也有缺点：一是服务紧耦合，二是父接口参数列表中的映射不会被继承。</p> <p>方式二：抽取。将 FeignClient 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。<br></p><div align="center"><img src="/java-note/assets/img/Feign最佳实践之抽取.78c59814.png" width="100%"></div><p></p> <p>对于这种方式，其实现步骤如下：</p> <ol><li>首先创建一个模块并命名，比如命名为 feign-api，然后引入 feign 的 starter 依赖。</li> <li>将微服务中编写的 Client、POJO 类、feign 的配置类等都复制到 feign-api 模块中。</li> <li>在微服务中引入 feign-api 的依赖。</li> <li>修改微服务中与迁移到 feign-api 中的类有关的 import 部分，改为导入 feign-api 中的包。</li> <li>重启服务。</li></ol> <p>由于对于 <code>FeignClient</code> 进行了迁移，因此定义的 <code>FeignClient</code> 不在 SpringBootApplication 的扫描包范围，无法创建为 bean 并注入，导致 <code>FeignClient</code> 无法使用。这种情况有两种方式可以解决：</p> <ol><li>方式一：在 <code>@EnableFeignClients</code> 注解中添加 basePackages：</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">&quot;com.helloworldyc.feign.clients&quot;</span><span class="token punctuation">)</span>
</code></pre></div><ol><li>方式二：在 <code>@EnableFeignClients</code> 注解中添加 <code>clients</code>，指定具体 <code>FeignClient</code> 的字节码（推荐）</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@EnableFeignClients</span><span class="token punctuation">(</span>clients <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token class-name">UserClient</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="统一网关-gateway"><a href="#统一网关-gateway" class="header-anchor">#</a> 统一网关 Gateway</h2> <h3 id="为什么需要网关"><a href="#为什么需要网关" class="header-anchor">#</a> 为什么需要网关</h3> <p>并不是所有的微服务都可以由外部访问的，网关可以管理对微服务的访问权限。总的来说，就是为了更好地管理和控制微服务之间的通信。</p> <p>网关有如下功能：</p> <ol><li>路由和负载均衡：微服务架构中有多个服务，它们可能分布在不同的主机和端口上。微服务网关可以用于路由请求到相应的服务实例，并在多个实例之间进行负载均衡，确保每个服务实例都能够处理适当的请求负载。</li> <li>协议转换：微服务可能使用不同的通信协议或数据格式。微服务网关可以充当协议转换器，将请求从一个协议或数据格式转换为另一个，从而使不同的服务能够相互通信。</li> <li>安全性和认证：微服务网关可以处理认证和授权，集中管理对微服务的访问权限。通过在网关层实施安全性，可以减轻每个微服务都必须处理这些方面的负担。</li> <li>监控和日志：微服务网关可以集中处理日志和监控功能，记录请求和响应的信息，以便进行故障排除、性能分析和系统优化。这有助于简化微服务的监控和管理。</li> <li>对用户请求做限流</li> <li>缓存和性能优化：微服务网关可以实现请求和响应的缓存，以减轻后端微服务的负担，提高性能和响应速度。</li> <li>降低复杂性：微服务网关可以为客户端提供一个简化的接口，隐藏底层微服务的复杂性。这有助于客户端与微服务之间的解耦，并使系统更易于理解和维护。</li></ol> <p>在 SpringCloud 中网关的实现包括两种：gateway 和 zuul。Zuul 是基于 Servlet 的实现，属于阻塞式编程。而 SpringCloudGateway 则是基于 Spring5 中提供的 WebFlux，属于响应式编程的实现，具备更好的性能。</p> <h3 id="gateway-快速入门"><a href="#gateway-快速入门" class="header-anchor">#</a> gateway 快速入门</h3> <p>网关本质上也是一个微服务，因此需要搭建网关服务，其步骤如下：</p> <ol><li>创建新的 module，引入 SpringCloudGateway 的依赖和 Nacos 的服务发现依赖：</li></ol> <div class="language-xml extra-class"><pre class="language-xml"><code><span class="token comment">&lt;!--网关依赖--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-gateway<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>

<span class="token comment">&lt;!--nacos服务发现依赖--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.alibaba.cloud<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-cloud-starter-alibaba-nacos-discovery<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> 
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><ol start="2"><li>配置 application.yml，编写路由配置及 Nacos 地址</li></ol> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10010</span>                       <span class="token comment"># 网关端口</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway                   <span class="token comment"># 服务名称</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>   <span class="token comment"># nacos 地址</span>
    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>
      <span class="token key atrule">routes</span><span class="token punctuation">:</span>                       <span class="token comment"># 网关路由配置</span>
        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user<span class="token punctuation">-</span>service           <span class="token comment"># 路由 id,自定义，只要唯一即可</span>
          <span class="token comment"># uri: http://127.0.0.1:8081# 路由的目标地址，写具体 ip 就是固定地址</span>
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//userservice       <span class="token comment"># 路由的目标地址，lb 就是负载均衡，后面跟服务名称，动态查询服务地址</span>
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>                 <span class="token comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span>
            <span class="token punctuation">-</span> Path=/user/<span class="token important">**</span>            <span class="token comment"># 这个是按照路径匹配，只要以/user/开头就符合要求</span>
</code></pre></div><p>网关路由可以配置的内容包括：</p> <ul><li>路由 id：路由的唯一标识，自定义，只要唯一即可。</li> <li>uri：路由目的地，支持 lb 和 http 两种。写 http 即具体 ip 就是固定地址；写 lb 就是负载均衡，后面跟服务名称，动态查询服务地址。</li> <li>predicates：路由断言，判断请求是否符合要求，符合则转发到路由目的地。</li> <li>filters：路由过滤器，处理请求或响应。</li></ul> <p>总的服务过程如下：
</p><div align="center"><img src="/java-note/assets/img/gateway之网关服务过程.43219c0d.png" width="100%"></div><p></p> <h3 id="路由断言工厂-route-predicate-factory"><a href="#路由断言工厂-route-predicate-factory" class="header-anchor">#</a> 路由断言工厂 Route Predicate Factory</h3> <p>我们在配置文件中写的断言规则只是字符串，这些字符串需要被 Predicate Factory 读取并处理，转变为路由判断的条件。<br>
例如，<code>Path=/user/**</code> 是按照路径匹配的，这个规则是由 <code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的。<br>
像这样的断言工厂在 SpringCloudGateway 还有十几个，也就是说还有十几种断言规则，如下：<br></p><div align="center"><img src="/java-note/assets/img/断言规则类型.355b1234.png" width="100%"></div><p></p> <h3 id="过滤器工厂"><a href="#过滤器工厂" class="header-anchor">#</a> 过滤器工厂</h3> <p>网关还可以用来做过滤，GatewayFilter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：<br></p><div align="center"><img src="/java-note/assets/img/gateway之网关过滤.fb7c0702.png" width="100%"></div><p></p> <p>Spring 提供了 31 种不同的路由过滤器工厂，例如：</p> <ul><li><code>AddRequestHeader</code>：给当前请求添加一个请求头</li> <li><code>RemoveRequestHeader</code>：移除请求中的一个请求头</li> <li><code>AddResponseHeader</code>：给响应结果中添加一个响应头</li> <li><code>RemoveResponseHeader</code>：从响应结果中移除一个响应头</li> <li><code>RequestRateLimiter</code>：限制请求的流量</li> <li>...</li></ul> <p>实现步骤为：在 gateway 中修改路由配置，给单个微服务的路由添加过滤器；如果要对所有路由都生效，则可以将过滤器工厂写到 default 下。</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">server</span><span class="token punctuation">:</span>
  <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">10010</span>                           <span class="token comment"># 网关端口</span>
<span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> gateway                       <span class="token comment"># 服务名称</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">nacos</span><span class="token punctuation">:</span>
      <span class="token key atrule">server-addr</span><span class="token punctuation">:</span> localhost<span class="token punctuation">:</span><span class="token number">8848</span>       <span class="token comment"># nacos 地址</span>
    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>
      <span class="token key atrule">routes</span><span class="token punctuation">:</span>                           <span class="token comment"># 网关路由配置</span>
        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> user<span class="token punctuation">-</span>service              <span class="token comment"># 路由 id,自定义，只要唯一即可</span>
          <span class="token comment"># uri: http://127.0.0.1:8081  # 路由的目标地址，写具体 ip 就是固定地址</span>
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//userservice         <span class="token comment"># 路由的目标地址，lb 就是负载均衡，后面跟服务名称，动态查询服务地址</span>
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>                   <span class="token comment"># 路由断言，也就是判断请求是否符合路由规则的条件</span>
            <span class="token punctuation">-</span> Path=/user/<span class="token important">**</span>             <span class="token comment"># 这个是按照路径匹配，只要以 /user/ 开头就符合要求</span>
          <span class="token key atrule">filters</span><span class="token punctuation">:</span>                      <span class="token comment"># 过滤器</span>
            <span class="token punctuation">-</span> AddRequestHeader=Fault<span class="token punctuation">,</span>Itcast is freaking awesome<span class="token tag">!</span>  <span class="token comment"># 添加请求头</span>
        <span class="token punctuation">-</span> <span class="token key atrule">id</span><span class="token punctuation">:</span> order<span class="token punctuation">-</span>service
          <span class="token key atrule">uri</span><span class="token punctuation">:</span> lb<span class="token punctuation">:</span>//orderservice
          <span class="token key atrule">predicates</span><span class="token punctuation">:</span>
            <span class="token punctuation">-</span> Path=order/<span class="token important">**</span>
      <span class="token key atrule">default-filters</span><span class="token punctuation">:</span>                  <span class="token comment"># 默认过滤器，会对所有的路由请求都生效</span>
        <span class="token punctuation">-</span> AddRequestHeader=Truth<span class="token punctuation">,</span> Itcast is freaking awesome<span class="token tag">!</span> <span class="token comment"># 添加请求头</span>
</code></pre></div><h3 id="全局过滤器"><a href="#全局过滤器" class="header-anchor">#</a> 全局过滤器</h3> <p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。<br>
区别在于 GatewayFilter 通过配置定义，处理逻辑是固定的。而 GlobalFilter 的逻辑需要自己写代码实现，可以自定义处理逻辑。<br>
定义方式是：自定义类，实现 GlobalFilter 接口，添加 <code>@Order</code> 注解或者实现 <code>Ordered</code> 接口。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// GlobalFilter 接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">GlobalFilter</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
     *  处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理
     *
     * @param exchange 请求上下文，里面可以获取Request、Response等信息
     * @param chain 用来把请求委托给下一个过滤器 
     * @return {@code Mono&lt;Void&gt;} 返回标示当前过滤器业务结束
     */</span>
    <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
 * 定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：
 * 参数中是否有authorization，
 * authorization参数值是否为admin
 * 如果同时满足则放行，否则拦截
 */</span>
<span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Component</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AuthorizeFilter</span> <span class="token keyword">implements</span> <span class="token class-name">GlobalFilter</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Mono</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Void</span><span class="token punctuation">&gt;</span></span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token class-name">ServerWebExchange</span> exchange<span class="token punctuation">,</span> <span class="token class-name">GatewayFilterChain</span> chain<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 1.获取请求参数</span>
        <span class="token class-name">MultiValueMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> params <span class="token operator">=</span> exchange<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQueryParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 2.获取authorization参数</span>
        <span class="token class-name">String</span> auth <span class="token operator">=</span> params<span class="token punctuation">.</span><span class="token function">getFirst</span><span class="token punctuation">(</span><span class="token string">&quot;authorization&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 3.校验</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;admin&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>auth<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 当前过滤器放行，到下一个过滤器或转给请求微服务</span>
            <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>exchange<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 4.拦截       </span>
        <span class="token comment">// 4.1.禁止访问</span>
        exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setStatusCode</span><span class="token punctuation">(</span><span class="token class-name">HttpStatus</span><span class="token punctuation">.</span><span class="token constant">FORBIDDEN</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 4.2.结束处理</span>
        <span class="token keyword">return</span> exchange<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="header-anchor">#</a> 过滤器执行顺序</h3> <p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter。<br>
请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器。</p> <p>具体的排序规则是：</p> <ol><li>按照每个过滤器的 order 值来排序，order 值越小，优先级越高，执行顺序越靠前</li> <li>当过滤器的 order 值一样时，会按照 DefaultFilter -&gt; 当前路由过滤器 -&gt; GlobalFilter 的顺序执行。</li></ol> <p>而过滤器的 order 值是这么确定的：</p> <ul><li>每一个过滤器都必须指定一个 int 类型的 order 值。</li> <li>GlobalFilter 通过实现 Ordered 接口，或者添加 <code>@Order</code> 注解来指定 order 值，由我们自己指定</li> <li>路由过滤器和 DefaultFilter 的 order 值由 Spring 指定，每种过滤器默认是按照声明顺序从 1 递增的，因此同一种过滤器不可能出现 order 值相等的情况。</li></ul> <h3 id="跨域问题处理"><a href="#跨域问题处理" class="header-anchor">#</a> 跨域问题处理</h3> <p>跨域：域名不一致就是跨域，主要包括：</p> <ul><li>域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com</li> <li>域名相同，端口不同：localhost:8080 和 localhost:8081</li></ul> <p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域 ajax 请求，请求被浏览器拦截的问题。<br>
解决方案：CORS。也就是浏览器会去服务端询问是否允许跨域请求。</p> <p>网关处理跨域采用的同样是 CROS 方案，并且只需要简单配置即可实现：</p> <div class="language-yml extra-class"><pre class="language-yml"><code><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">cloud</span><span class="token punctuation">:</span>
    <span class="token key atrule">gateway</span><span class="token punctuation">:</span>
      <span class="token comment"># 。。。</span>
      <span class="token key atrule">globalcors</span><span class="token punctuation">:</span> <span class="token comment"># 全局的跨域处理</span>
        <span class="token key atrule">add-to-simple-url-handler-mapping</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 解决 options 请求被拦截问题</span>
        <span class="token key atrule">corsConfigurations</span><span class="token punctuation">:</span>
          <span class="token key atrule">'[/**]'</span><span class="token punctuation">:</span>            
            <span class="token key atrule">allowedOrigins</span><span class="token punctuation">:</span> <span class="token comment"># 允许哪些网站的跨域请求 </span>
              <span class="token punctuation">-</span> <span class="token string">&quot;http://localhost:8090&quot;</span>
              <span class="token punctuation">-</span> <span class="token string">&quot;http://www.leyou.com&quot;</span>
            <span class="token key atrule">allowedMethods</span><span class="token punctuation">:</span> <span class="token comment"># 允许的跨域 ajax 的请求方式</span>
              <span class="token punctuation">-</span> <span class="token string">&quot;GET&quot;</span>            
              <span class="token punctuation">-</span> <span class="token string">&quot;POST&quot;</span>           
              <span class="token punctuation">-</span> <span class="token string">&quot;DELETE&quot;</span>      
              <span class="token punctuation">-</span> <span class="token string">&quot;PUT&quot;</span>
              <span class="token punctuation">-</span> <span class="token string">&quot;OPTIONS&quot;</span>
            <span class="token key atrule">allowedHeaders</span><span class="token punctuation">:</span> <span class="token string">&quot;*&quot;</span>     <span class="token comment"># 允许在请求中携带的头信息</span>
            <span class="token key atrule">allowCredentials</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>  <span class="token comment"># 是否允许携带 cookie</span>
            <span class="token key atrule">maxAge</span><span class="token punctuation">:</span> <span class="token number">360000</span>          <span class="token comment"># 这次跨域检测的有效期</span>
</code></pre></div><h3 id="限流过滤器"><a href="#限流过滤器" class="header-anchor">#</a> 限流过滤器</h3> <p>限流：对应用服务器的请求做限制，保护服务器，避免因过多请求而导致服务器过载甚至宕机。限流算法常见的包括三种：</p> <ul><li>计数器算法，又包括窗口计数器算法、滑动窗口计数器算法</li> <li>漏桶算法(Leaky Bucket)</li> <li>令牌桶算法（Token Bucket）</li></ul> <h4 id="限流过滤器-计数器算法"><a href="#限流过滤器-计数器算法" class="header-anchor">#</a> 限流过滤器——计数器算法</h4> <p>固定窗口计数器算法概念如下：</p> <ul><li>将时间划分为多个窗口</li> <li>在每个窗口内每有一次请求就将计数器加一，当时间到达下一个窗口时，计数器重置</li> <li>如果计数器超过了限制数量，则本窗口内所有请求都将被丢弃。</li></ul> <h4 id="限流过滤器-漏桶算法"><a href="#限流过滤器-漏桶算法" class="header-anchor">#</a> 限流过滤器——漏桶算法</h4> <p>漏桶算法说明：</p> <ul><li>将每个请求视作&quot;水滴&quot;放入&quot;漏桶&quot;进行存储；</li> <li>&quot;漏桶&quot;以固定速率向外&quot;漏&quot;出请求来执行，如果&quot;漏桶&quot;空了则停止&quot;漏水”；如果&quot;漏桶&quot;满了则多余的&quot;水滴&quot;会被直接丢弃。</li></ul> <h3 id="限流过滤器-令牌桶算法"><a href="#限流过滤器-令牌桶算法" class="header-anchor">#</a> 限流过滤器——令牌桶算法</h3> <p>令牌桶算法说明：</p> <ul><li>以固定的速率生成令牌，存入令牌桶中，如果令牌桶满了以后，多余令牌丢弃。</li> <li>请求进入后，必须先尝试从桶中获取令牌，获取到令牌后才可以被处理，如果令牌桶中没有令牌，则请求等待或丢弃。</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java-note/Java/Java基础/阻塞队列.html" class="prev">
        阻塞队列
      </a></span> <span class="next"><a href="/java-note/Java/Java框架/微服务/Docker入门.html">
        Docker入门
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/java-note/assets/js/app.b4e76d81.js" defer></script><script src="/java-note/assets/js/2.af1aff5f.js" defer></script><script src="/java-note/assets/js/1.b527e11e.js" defer></script><script src="/java-note/assets/js/14.cde1b595.js" defer></script>
  </body>
</html>
