<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>操作系统导论 | java</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/java-note/images/myfavicon.png">
    <meta name="description" content="java 学习笔记">
    
    <link rel="preload" href="/java-note/assets/css/0.styles.f5140cd9.css" as="style"><link rel="preload" href="/java-note/assets/js/app.b4e76d81.js" as="script"><link rel="preload" href="/java-note/assets/js/2.af1aff5f.js" as="script"><link rel="preload" href="/java-note/assets/js/1.b527e11e.js" as="script"><link rel="preload" href="/java-note/assets/js/27.02358944.js" as="script"><link rel="prefetch" href="/java-note/assets/js/10.a284a5f0.js"><link rel="prefetch" href="/java-note/assets/js/11.63d78869.js"><link rel="prefetch" href="/java-note/assets/js/12.411148a2.js"><link rel="prefetch" href="/java-note/assets/js/13.a6d8e7b5.js"><link rel="prefetch" href="/java-note/assets/js/14.cde1b595.js"><link rel="prefetch" href="/java-note/assets/js/15.c815dbff.js"><link rel="prefetch" href="/java-note/assets/js/16.f89ca76d.js"><link rel="prefetch" href="/java-note/assets/js/17.b43ef999.js"><link rel="prefetch" href="/java-note/assets/js/18.f1ca2df4.js"><link rel="prefetch" href="/java-note/assets/js/19.d907bdbe.js"><link rel="prefetch" href="/java-note/assets/js/20.ba076c76.js"><link rel="prefetch" href="/java-note/assets/js/21.f7bf66e3.js"><link rel="prefetch" href="/java-note/assets/js/22.941a47dc.js"><link rel="prefetch" href="/java-note/assets/js/23.b9156e83.js"><link rel="prefetch" href="/java-note/assets/js/24.07b1cd92.js"><link rel="prefetch" href="/java-note/assets/js/25.5be29da5.js"><link rel="prefetch" href="/java-note/assets/js/26.2dd5fb9f.js"><link rel="prefetch" href="/java-note/assets/js/28.306847f8.js"><link rel="prefetch" href="/java-note/assets/js/29.270a4d53.js"><link rel="prefetch" href="/java-note/assets/js/3.313cba90.js"><link rel="prefetch" href="/java-note/assets/js/30.bfc6c248.js"><link rel="prefetch" href="/java-note/assets/js/31.fffd5f77.js"><link rel="prefetch" href="/java-note/assets/js/32.ac467fad.js"><link rel="prefetch" href="/java-note/assets/js/33.70479154.js"><link rel="prefetch" href="/java-note/assets/js/34.4e48aa0b.js"><link rel="prefetch" href="/java-note/assets/js/35.724f00a7.js"><link rel="prefetch" href="/java-note/assets/js/36.170daa7d.js"><link rel="prefetch" href="/java-note/assets/js/37.53f51c04.js"><link rel="prefetch" href="/java-note/assets/js/38.4e8ccf8d.js"><link rel="prefetch" href="/java-note/assets/js/39.4677e6bb.js"><link rel="prefetch" href="/java-note/assets/js/4.953ceea1.js"><link rel="prefetch" href="/java-note/assets/js/40.b55e76ef.js"><link rel="prefetch" href="/java-note/assets/js/41.fe541156.js"><link rel="prefetch" href="/java-note/assets/js/42.6f36570a.js"><link rel="prefetch" href="/java-note/assets/js/43.f7e4b8ba.js"><link rel="prefetch" href="/java-note/assets/js/44.668b7294.js"><link rel="prefetch" href="/java-note/assets/js/45.02de4e09.js"><link rel="prefetch" href="/java-note/assets/js/46.0b9a3a33.js"><link rel="prefetch" href="/java-note/assets/js/47.6978a7f4.js"><link rel="prefetch" href="/java-note/assets/js/48.036c9aa2.js"><link rel="prefetch" href="/java-note/assets/js/49.a77067f4.js"><link rel="prefetch" href="/java-note/assets/js/5.5d5d288a.js"><link rel="prefetch" href="/java-note/assets/js/50.50d9308b.js"><link rel="prefetch" href="/java-note/assets/js/51.f5490448.js"><link rel="prefetch" href="/java-note/assets/js/52.446d87e0.js"><link rel="prefetch" href="/java-note/assets/js/53.8779543f.js"><link rel="prefetch" href="/java-note/assets/js/54.94dc9f6f.js"><link rel="prefetch" href="/java-note/assets/js/55.8d7d0d45.js"><link rel="prefetch" href="/java-note/assets/js/56.69820a1b.js"><link rel="prefetch" href="/java-note/assets/js/57.fcaa4ea6.js"><link rel="prefetch" href="/java-note/assets/js/58.0fd49238.js"><link rel="prefetch" href="/java-note/assets/js/59.79c04a76.js"><link rel="prefetch" href="/java-note/assets/js/6.3c0fcba4.js"><link rel="prefetch" href="/java-note/assets/js/60.f35494a3.js"><link rel="prefetch" href="/java-note/assets/js/61.39888619.js"><link rel="prefetch" href="/java-note/assets/js/62.0d59237f.js"><link rel="prefetch" href="/java-note/assets/js/63.6d693cde.js"><link rel="prefetch" href="/java-note/assets/js/64.47d66d8e.js"><link rel="prefetch" href="/java-note/assets/js/65.fbcd58d8.js"><link rel="prefetch" href="/java-note/assets/js/66.962b42b1.js"><link rel="prefetch" href="/java-note/assets/js/67.563f535c.js"><link rel="prefetch" href="/java-note/assets/js/68.0c74e1c4.js"><link rel="prefetch" href="/java-note/assets/js/69.242f9577.js"><link rel="prefetch" href="/java-note/assets/js/7.93de78a3.js"><link rel="prefetch" href="/java-note/assets/js/70.3a3fb003.js"><link rel="prefetch" href="/java-note/assets/js/vendors~docsearch.d01c1f3f.js">
    <link rel="stylesheet" href="/java-note/assets/css/0.styles.f5140cd9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/java-note/" class="home-link router-link-active"><!----> <span class="site-name">java</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>校园信息交流平台项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>简易RPC框架项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>内功</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>MySQL</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Redis</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>操作系统</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-note/Java/内功/操作系统/导论.html" class="active sidebar-link">操作系统导论</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>知识点自测速记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="什么是操作系统"><a href="#什么是操作系统" class="header-anchor">#</a> 什么是操作系统</h2> <ul><li><p>是计算机硬件和应用之间的一层软件</p> <ul><li>方便我们使用硬件，如使用显存</li> <li>高效的使用硬件，如开多个终端（窗口）
<div align="center"><img src="/java-note/assets/img/操作系统与应用软件和计算机硬件之间的关系.6c0b7ad6.png" width="70%"></div></li></ul></li> <li><p>管理哪些硬件</p> <ul><li><strong>CPU管理</strong>、<strong>内存管理</strong>、<strong>终端管理</strong>、<strong>磁盘管理</strong>、<strong>文件管理</strong></li> <li>网络管理、电源管理、多核管理</li></ul></li> <li><p>计算机怎么工作？<strong>取指执行</strong></p></li> <li><p>计算机的第一段引导程序：bootsect.s</p></li> <li><p>执行流程：bootsect.s -&gt; setup.s -&gt; head.s -&gt; main.c</p></li> <li><p>head.s是system模块（目标代码）中的第一部分代码</p></li></ul> <h2 id="操作系统接口"><a href="#操作系统接口" class="header-anchor">#</a> 操作系统接口</h2> <ul><li>连接谁？连接操作系统和应用软件</li> <li>如何连接？C语言程序</li> <li>接口表现为函数调用，又由系统提供，所以称为<strong>系统调用(system call)</strong></li></ul> <h3 id="系统调用的实现"><a href="#系统调用的实现" class="header-anchor">#</a> 系统调用的实现</h3> <ul><li>将内核程序和用户程序<strong>隔离</strong> <ul><li>区分<strong>内核态和用户态</strong>：一种处理器“硬件设计”方式实现。
<ul><li>内核态可以访问任何数据，用户态只能访问用户段数据。对于指令跳转也一样，实现了隔离</li> <li>当前程序执行在什么态（哪层环）？由于CS:IP是当前指令，所以用CS的最低两位来表示（CPL）：0是内核态，3是用户态</li> <li>目标数据特权级在什么态？在GDT表中的表项DPL：0是内核态，3是用户态</li></ul></li></ul></li> <li>硬件提供了“主动进入内核的方法”
<ul><li>对于Intel x86，就是中断指令<code>int 0x80</code>（通过IDT表获取中断处理函数入口/地址）
<ul><li><strong>int指令将使CS中的CPL改为0，“进入内核”</strong></li> <li>int中断是用户程序发起的调用内核代码的唯一方式</li></ul></li></ul></li> <li>系统调用的核心：
<ul><li>用户程序中包含一段包含int指令的代码</li> <li>操作系统写中断处理，获取想调程序的编号</li> <li>操作系统根据编号执行相应代码</li></ul></li></ul> <h2 id="cpu管理"><a href="#cpu管理" class="header-anchor">#</a> CPU管理</h2> <h3 id="管理cpu的最直观方法-利用效率低"><a href="#管理cpu的最直观方法-利用效率低" class="header-anchor">#</a> 管理CPU的最直观方法（利用效率低）</h3> <p>设好PC初值就完事！（因为CPU不断自动地取指执行）</p> <h3 id="管理好cpu核心-提高cpu利用效率"><a href="#管理好cpu核心-提高cpu利用效率" class="header-anchor">#</a> 管理好CPU核心（提高CPU利用效率）</h3> <ul><li>一个CPU上交替的执行多个程序：<strong>并发</strong></li> <li>怎么做？
<ul><li>修改寄存器PC</li> <li>记录程序信息：每个程序有一个存放信息的结构：PCB(Process Control Block)</li></ul></li> <li>运行中的程序和静态程序不一样！
<ul><li><strong>进程是进行（执行）中的程序</strong>，它跟静态程序不一样，有开始和结束，需要记录ax，bx等一些信息，这些信息记录在PCB中</li></ul></li></ul> <h2 id="多进程图像"><a href="#多进程图像" class="header-anchor">#</a> 多进程图像</h2> <p>多个进程（PID）使用CPU的图像<br>
多进程图像从启动开始到关机结束</p> <h3 id="多进程图像-多进程如何组织"><a href="#多进程图像-多进程如何组织" class="header-anchor">#</a> 多进程图像：多进程如何组织？</h3> <p>将多个进程对应的PCB分别放在多个地方（正在执行的、就绪队列、磁盘等待队列）<br>
多进程的组织：PCB + 状态 + 队列
</p><div align="center"><img src="/java-note/assets/img/多进程的组织.800ddaa4.png" width="70%"></div><p></p> <h3 id="多进程图像-多进程如何交替"><a href="#多进程图像-多进程如何交替" class="header-anchor">#</a> 多进程图像：多进程如何交替？</h3> <p>交替的三个部分：队列操作 + 调度 + 切换</p> <div class="language- extra-class"><pre class="language-text"><code>eg.
启动磁盘读写；
pCur.state = &quot;W&quot;;
将pCur放到DiskWaitQueue
schedule();

schedule(){
  pNew = getNext(ReadyQueue); // 调度
  switch_to(pCur, pNew); // 保存当前进程现场（记录PCB），切换到下一个进程
}
</code></pre></div><h3 id="多进程图像-多进程如何影响"><a href="#多进程图像-多进程如何影响" class="header-anchor">#</a> 多进程图像：多进程如何影响？</h3> <ul><li>多个进程同时存在于内存有可能会出现内存相互访问的问题</li> <li>解决的方法：<strong>限制对地址的读写</strong>，<strong>进程的内存进行映射</strong></li> <li>多进程的地址空间分离：<strong>内存管理的主要内容</strong></li></ul> <h3 id="多进程图像-多进程如何合作"><a href="#多进程图像-多进程如何合作" class="header-anchor">#</a> 多进程图像：多进程如何合作？</h3> <p>核心在于进程同步（合理的推进顺序）</p> <h2 id="用户级线程"><a href="#用户级线程" class="header-anchor">#</a> 用户级线程</h2> <ul><li><p><strong>进程 = 资源 + 指令执行序列</strong></p> <ul><li>将资源和指令分开</li> <li>一个资源 + 多个指令执行序列</li></ul></li> <li><p>线程：保留了并发的优点，避免了进程切换代价。<strong>实质就是映射表不变而PC指针改变</strong></p> <ul><li>线程切换时，TCB(Thread Control Block)记录栈的地址，栈记录当前线程的信息，包括返回地址，每个线程有自己的栈
<div align="center"><img src="/java-note/assets/img/线程切换.e2e4fe99.png" width="70%"></div></li></ul></li> <li><p><strong>Yield</strong>：属于用户级，但用户不可见，调度点由系统决定</p></li> <li><p><strong>ThreadCreate</strong>：是系统调用，会进入内核，内核管理TCB，内核负责切换线程</p></li></ul> <h2 id="核心级线程"><a href="#核心级线程" class="header-anchor">#</a> 核心级线程</h2> <ul><li>多处理器：有多个CPU，每个CPU有它自己的 cache 和 MMU（内存管理单元，即映射表）</li> <li>多核：有多个CPU，但多个CPU共用一个 cache 和 MMU （即每个CPU相当于一个线程），多核可以<strong>并行</strong>（注意区别<strong>并发</strong>）</li></ul> <h3 id="和用户级相比-核心级线程有什么不同"><a href="#和用户级相比-核心级线程有什么不同" class="header-anchor">#</a> 和用户级相比，核心级线程有什么不同？</h3> <ul><li><strong>ThreadCreate</strong>：是系统调用，会进入内核，内核管理TCB，内核负责切换线程</li> <li><strong>如何让切换成型？内核栈，TCB</strong> <ul><li>用户栈是否还要用？执行的代码仍然在用户态，还要进行函数调用</li> <li><strong>一个栈到一套栈（用户栈和内核栈）；两个栈到两套栈</strong></li></ul></li></ul> <h3 id="核心级线程切换过程"><a href="#核心级线程切换过程" class="header-anchor">#</a> 核心级线程切换过程</h3> <ul><li>当前用户态线程进入内核态（由中断进入）</li> <li>内核栈保存当前用户态线程的上下文信息，包括程序计数器PC、寄存器、用户栈指针</li> <li>当前内核态线程的TCB记录当前内核栈的地址，将自己变为阻塞态或就绪态</li> <li>内核从就绪队列中选择下一运行的内核态线程，并从其TCB中得到内核栈指针寄存器（esp寄存器），即内核栈地址</li> <li>从内核栈中弹出对应的用户态线程的上下文信息，包括PC、寄存器、用户栈指针</li> <li>注意：若是进程的切换还需多上一步：地址映射表的切换（内存管理的内容）</li></ul> <h2 id="cpu调度策略-进程切换时怎么选择就绪队列中的进程"><a href="#cpu调度策略-进程切换时怎么选择就绪队列中的进程" class="header-anchor">#</a> CPU调度策略（进程切换时怎么选择就绪队列中的进程）</h2> <p><strong>需要折中，需要综合</strong></p> <ul><li>吞吐量和响应时间之间有矛盾
<ul><li>响应时间小 -&gt; 切换次数多 -&gt; 系统内耗大 -&gt; 吞吐量小</li></ul></li> <li>前台任务和后台任务的关注点不同：前台任务关注响应时间，后台任务关注周转时间
<ul><li>响应时间：从提交请求到产生响应所用的时间</li> <li>周转时间：从作业（进程）提交给系统开始，直至其完成并退出系统为止所经历的时间</li></ul></li> <li>IO约束型任务和CPU约束型任务有各自的特点（一般IO约束型优先级较高一点）</li></ul> <h3 id="各种cpu调度算法"><a href="#各种cpu调度算法" class="header-anchor">#</a> 各种CPU调度算法</h3> <ul><li>Fist Come，First Served (FCFS) （不算算法）</li> <li><strong>SJF</strong>：短作业优先，平均周转时间最短</li> <li><strong>RR</strong>：轮转调度，按时间片来轮转调度
<ul><li>属于折中：时间片10-100ms，切换时间0.1-1ms(1%)</li></ul></li> <li><strong>优先级</strong></li></ul> <h2 id="进程同步与信号量"><a href="#进程同步与信号量" class="header-anchor">#</a> 进程同步与信号量</h2> <ul><li>进程合作：多进程共同完成一个任务</li> <li>阻塞是进程同步的基础</li> <li>信号量：一种特殊整型变量，用来记录可使用资源的数量，信号用来sleep和wakeup</li></ul> <h3 id="信号量临界区保护"><a href="#信号量临界区保护" class="header-anchor">#</a> 信号量临界区保护</h3> <ul><li>为什么需要保护？共同修改信号量会引起问题</li> <li>竞争条件(Race Condition)：和调度有关的共享数据语义错误
<ul><li>错误由多个进程并发操作共享数据引起</li> <li>错误和调度顺序有关，难于发现和调试</li></ul></li> <li>解决竞争条件的直观想法：上锁，在写共享变量时阻止其他进程访问</li> <li><strong>临界区(Critical Section)</strong>：一次只允许一个进程进入的该进程的那一段代码，<strong>读写信号量的代码一定是临界区</strong> <ul><li><strong>基本原则：互斥进入</strong>：如果一个进程在临界区中执行，则其他进程不允许进入
<ul><li>这些进程间的约束关系称为<strong>互斥(mutual exclusion)</strong></li> <li>这保证了是临界区</li></ul></li> <li>好的临界区保护原则
<ul><li><strong>有空让进</strong>：若干进程要求进入空闲临界区时，应尽快使一进程进入临界区</li> <li><strong>有限等待</strong>：从进程发出进入请求到允许进入，不能无限等待</li></ul></li></ul></li></ul> <h3 id="信号量临界区保护解法"><a href="#信号量临界区保护解法" class="header-anchor">#</a> 信号量临界区保护解法</h3> <ul><li>软件解法
<ul><li>两个进程：<strong>PeterSon算法</strong>：标记和轮转的结合</li> <li>多个进程：<strong>面包店算法</strong>：仍然是标记和轮转的结合，每个进程都获得一个序号，序号最小的进临界区</li></ul></li> <li>硬件解法
<ul><li>临界区<strong>只允许一个进程进入</strong>，另一个进程进入意味着<strong>被调度</strong>，因此只要关闭中断入口即可，但这种方法只有单核才有效，多CPU情况下不好使</li> <li>硬件原子指令法：可以适用于多CPU的情况，但需要在实现时考虑不同CPU之间的缓存同步和多CPU的竞争情况。</li></ul></li></ul> <h3 id="信号量的代码实现"><a href="#信号量的代码实现" class="header-anchor">#</a> 信号量的代码实现</h3> <ul><li>信号量包括value和等待的PCB队列，需要被各个进程都看到，信号量应该在内核里实现，通过系统调用来获取。</li></ul> <h2 id="死锁处理"><a href="#死锁处理" class="header-anchor">#</a> 死锁处理</h2> <p><strong>死锁</strong>：多个进程由于<strong>互相等待对方持有的资源</strong>而造成的谁都无法执行的情况叫<strong>死锁</strong></p> <h3 id="死锁的成因"><a href="#死锁的成因" class="header-anchor">#</a> 死锁的成因</h3> <ul><li>资源<strong>互斥</strong>使用，一旦占有别人无法使用</li> <li>进程<strong>占有</strong>了一些资源，又不释放，再去<strong>申请</strong>其他资源</li> <li>各自占有的资源和互相申请的资源形成了<strong>环路等待</strong></li></ul> <h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="header-anchor">#</a> 死锁的四个必要条件</h3> <ul><li><strong>互斥使用(Mutual exclusion)</strong>，资源的固有特性</li> <li><strong>不可抢占(No preemption)</strong>，资源只能自愿放弃</li> <li><strong>请求和保持(Hold and wait)</strong>，进程必须占有资源，再去申请</li> <li><strong>循环等待(Circular wait)</strong>，在资源分配图中存在一个环路</li></ul> <h3 id="死锁处理方法"><a href="#死锁处理方法" class="header-anchor">#</a> 死锁处理方法</h3> <ul><li><strong>死锁预防</strong>：破坏死锁出现的条件
<ul><li>在进程执行前，<strong>一次性申请所有需要的资源</strong>，不会占有资源再去申请其他资源
<ul><li>缺点1：需要预知未来，编程困难</li> <li>缺点2：许多资源分配后很长时间后才使用，资源利用率低</li></ul></li> <li>对资源类型进行排序，<strong>资源申请必须按序进行</strong>，不会出现环路等待
<ul><li>缺点：仍然造成资源浪费</li></ul></li></ul></li> <li><strong>死锁避免</strong>：检测每个资源请求，如果造成死锁就拒绝
<ul><li>如果系统中的所有进程存在一个可完成的执行序列P1，……，Pn（<strong>安全序列</strong>），则称系统处于<strong>安全状态</strong>，判断的算法为<strong>银行家算法</strong></li></ul></li> <li><strong>死锁检测 + 恢复</strong>：检测到死锁出现时，让一些进程回滚，让出资源
<ul><li>定时检测或者发现资源利用率低时检测</li></ul></li> <li><strong>死锁忽略</strong>：就好像没有出现死锁一样，许多通用操作系统，如Windows和Linux，都采用此方法，可以通过重启处理</li></ul> <h2 id="内存使用与分段"><a href="#内存使用与分段" class="header-anchor">#</a> 内存使用与分段</h2> <ul><li><strong>内存使用：将程序放到内存中，PC指向开始地址</strong></li> <li>在内存中找到一段空闲内存，将程序载入到这段空闲内存中，重定位后再设置好PC，不断取指执行</li> <li>重定位：修改程序中的逻辑地址（是相对地址），修改为物理内存中的实际地址（绝对地址）</li> <li>什么时候完成重定位？ （嵌入式系统可以在编译时）
<ul><li>编译时重定位的程序只能放在内存固定位置</li> <li>载入时重定位的程序一旦载入内存就不能动了</li> <li>重定位最合适的时机——<strong>运行时重定位</strong></li> <li>理由：程序载入后还需要移动，比如进程睡眠时要换出内存给另一进程，即<strong>交换</strong>，充分利用内存</li></ul></li> <li>运行时重定位：在运行每条指令时才完成重定位
<ul><li>每执行一条指令都要从逻辑地址算出物理地址：<strong>地址翻译</strong>，基地址base + 偏移offset</li> <li>每个进程都有各自的基地址，放在了PCB里，执行指令时第一步先从PCB中取出这个基地址</li></ul></li></ul> <h3 id="分段"><a href="#分段" class="header-anchor">#</a> 分段</h3> <ul><li>程序<strong>由若干部分（段）组成，每个段有各自的特点、用途</strong>：代码段只读，代码/数据段不会动态增长
<ul><li>符合用户观点：用户可独立考虑每个段（<strong>分治</strong>）</li> <li>怎么定位具体指令（数据）：<strong>&lt;段号，段内偏移&gt;</strong>，如 <code>mov [es:bx], ax</code></li></ul></li> <li>不是将整个程序，是将各段分别放入内存</li> <li>每个段都有基址，可在段表中查到，而每个进程都有一个段表LDT。对于操作系统，也可以认为是一个进程，它的段表即为GDT表。
<div align="center"><img src="/java-note/assets/img/分段中GDT和LDT.2cd87622.png" width="70%"></div></li></ul> <h2 id="内存分区与分页"><a href="#内存分区与分页" class="header-anchor">#</a> 内存分区与分页</h2></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java-note/Java/内功/Redis/Redis一点点细节.html" class="prev">
        Redis一点点细节
      </a></span> <span class="next"><a href="/java-note/Java/知识点自测速记/知识点自测速记之Java基础.html">
        知识点自测速记之Java基础
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/java-note/assets/js/app.b4e76d81.js" defer></script><script src="/java-note/assets/js/2.af1aff5f.js" defer></script><script src="/java-note/assets/js/1.b527e11e.js" defer></script><script src="/java-note/assets/js/27.02358944.js" defer></script>
  </body>
</html>
