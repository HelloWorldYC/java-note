---
title: 'Redis一点点细节'
---

## Redis 持久化机制
### AOF 重写
AOF 重写（rewrite）是一个有歧义的名字，该功能是**通过读取数据库中的键值对来实现**，程序**无须**对现有 AOF 文件进行任何读写、分析或者写入操作。  
AOF 重写触发时机有两种，一种是通过设置AOF文件大小，默认是 64 MB，超过则重写；另一种是设置当前 AOF 大小和上一次重写时 AOF 大小的比值，超过比值则重写。  
**既然 AOF 重写是读取数据库中键值对来实现的，为什么不直接采用 RDB，那样不是会更简单吗？**  
这个问题其实也就是 AOF 和 RDB 的优劣势问题，各有优势也各有短板，AOF 主要比 RDB 好的地方就是实时性比较好，数据安全性比较高，可以导出 AOF 文件进行分析调错。


## Redis 事务
Redis 事务实际上是一系列命令的打包执行，与 MySQL 这些的事务不一样。  
Redis 事务不支持原子性，但支持持久性（AOF 和 RDB）。  
**如何解决 Redis 事务的缺陷？** 可以使用 Lua 脚本，一段 Lua 脚本可以当作一条命令来执行，一段 Lua 脚本的执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被打断（**隔离性**）。但是，如果操作失败并不会回滚数据，因此使用 Lua 脚本也不满足原子性。


## Redis 性能优化
- 使用批量操作减少网络传输：减少了 Round Trip Time (RTT，往返时间)，即数据在网络上传输的时间；也减少了 发送命令的 socket I/O 成本。  
- 大量 key 集中过期问题：定期删除过期 key 任务需要在主线程中执行，若在这过程有大量 key 过期，会影响请求的响应。解决方法一是给 key 设置随机过期时间；二是开启 lazy-free 延迟释放，让 redis 采用异步方式延迟释放 key 使用的内存，交给子线程处理。
- 处理 Redis big key：一是分割 big key；二是手动清理；三是采用合适的数据结构。
- 处理 redis hotkey：一是读写分离；二是使用 Redis 集群，将热点数据分散存储在多个节点上；三是使用二级缓存，将热点数据存放一份到 JVM 本地内存中。

### 惰性删除（lazy deletion）和延迟释放（lazy free）的区别？
"Lazy Free" 和 "Lazy Deletion" 都是 Redis 中与内存管理和键的过期相关的概念，但它们有不同的含义和用途。

1. **Lazy Free（惰性释放）：**
   - "Lazy Free" 是指 Redis 在内存管理方面的一种策略。
   - 当一个键被删除或过期时，Redis 并不立即释放与该键相关联的内存。相反，它会将这些键的内存标记为 "tombstone"（墓碑），并稍后在内存需要时，通过回收这些标记为 "tombstone" 的内存来进行重用。
   - 这种策略的优势在于避免了频繁的内存分配和释放操作，从而减少了内存碎片的产生，提高了性能。然而，它可能会导致 Redis 的内存占用在键被删除或过期后仍然会有一定时间的增加。

2. **Lazy Deletion（惰性删除）：**
   - "Lazy Deletion" 是指 Redis 在处理键的过期时的一种策略。
   - 当一个键过期时，并不会立即将它从数据库中删除。相反，它会等到有客户端请求访问该键时，才会在访问时检查键是否过期，并在需要时删除。
   - 这种策略的优势在于避免了在键过期时产生立即的删除操作，从而减轻了对性能的影响。然而，它可能会导致过期键在数据库中积压，直到有客户端请求访问这些键。

综上所述，"Lazy Free" 主要关注内存管理，通过延迟释放内存来提高性能并减少内存碎片。"Lazy Deletion" 则关注键的过期处理，通过延迟实际删除过期键来减轻性能影响。这两种策略在 Redis 中都是为了优化性能和内存使用而采取的手段。

## Redis 内存碎片
Redis 内存碎片率计算公式：mem_fragmentation_ratio （内存碎片率）= used_memory_rss (操作系统实际分配给 Redis 的物理内存空间大小)/ used_memory(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)  
**一定不要误认为 used_memory_rss 减去 used_memory 值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。**


## Redis 生产问题
- 缓存穿透：大量请求的 key 不合理，根本不存在于缓存中，也不存在于数据库中。解决方法一是缓存无效 key，二是使用布隆过滤器。**布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。**
- 缓存击穿：请求的 key 对应的是热点数据 ，该数据存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）。解决方法一是设置热点数据永不过期或过期时间较长，二是提前将热点数据存入缓存并设置合理过期时间，三是设置互斥锁保证只有一个请求落到数据库。
- 缓存雪崩：缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力，比如实例宕机。针对 Redis 服务不可用解决方法一是采用集群避免单机出现问题，二是限流避免同时处理大量请求；针对热点缓存同时失效解决方法一是随机设置不同的过期时间，二是缓存永不失效，三是设置二级缓存。