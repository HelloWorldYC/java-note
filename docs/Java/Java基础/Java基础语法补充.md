---
title: 'Java基础语法补充'
---


## 成员变量和局部变量的区别

 <div align="center"><img src="./pictures/java基础语法补充/成员变量和局部变量的区别.png" width="100%"/></div>  


## 键盘录入

```java
//第一套体系：遇到空格、制表符、回车就停止接收，这些符号后面的数据就不会接收了
nextInt();      //接收整数
nextDouble();   //接收小数
next();         //接收字符串 

//第二套体系：遇到回车才停止
nextLine();     //接收字符串
```


## static 

- 注意事项：
  - 静态方法只能访问静态变量和静态方法
  - 非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法
  - 静态方法中是没有this关键字


## 三种类

- JavaBean类： 用来描述一类事物的类。比如，Student,Teacher,Dog,Cat等
- 测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口
- 工具类：不是用来描述一类事物的，而是帮我们做一些事情的类。  
工具类构造时要：1.类名见名知义；2.私有化构造方法；3.方法定义为静态；


## 继承

1. Java只能单继承：一个类只能继承一个直接父类；
2. Java不支持多继承、但是支持多层继承。
3. Java中所有的类都直接或者间接继承于Object类。（即Object类是所有类的原始父类）
4. 子类只能访问父类中非私有的成员。
5. **虚方法表中的成员方法可以被继承，不在表中的成员方法不能被继承**
6. 继承中成员变量访问特点：**就近原则**  
先在局部位置找，本类成员位置找，父类成员位置找，逐级往上
7. 若出现了重名的成员变量：

```java
System.out.println(name); //从局部位置开始往上找
System.out.println(this.name);//从本类成员位置开始往上找
System.out.println(super.name);//从父类成员位置开始往上找
```

方法重写的本质:  
<div align="left"><img src="./pictures/java基础语法补充/方法重写的本质.png" width="100%"/></div> 


## 代码块

- 局部代码块(已淘汰)  
作用：提前结束变量的生命周期，节省空间
- 构造代码块（不够灵活）  
  - 写在成员位置的代码块
  - 作用：可以把多个构造方法中重复的代码抽取出来
  - 执行时机：再创建本类对象的时候会先执行构造代码块再执行构造方法
- 静态代码块（重点掌握）
  - 格式：static{}
  - 特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次
  - 作用：数据的初始化


## 多态

格式：`父类类型 变量名 = new 子类类型`  
- 调用成员变量时：**编译看左边，运行看左边**  
编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。  
运行看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值。

- 调用成员方法时：**编译看左边，运行看右边**  
编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。
运行看右边：java运行代码的时候，实际上运行的是子类中的方法。

- 能调用哪些方法，由引用类型决定，具体执行情况，由实际内存对象类型决定

- java执行方法时，会根据引用的类型得到相应的方法，如果不存在编译时会报错，真正执行时，会动态去匹配，如果真正的对象是子类的话，且此方法在子类中被覆盖的话，就会执行子类方法。   
java类型匹配时，如果不能匹配的话就做向上类型转换，转换为父类，直到能够匹配为止，若一直不能匹配在编译时会报错


## 接口

- **JDK7以前**：接口中只能定义抽象方法。
- **JDK8的新特性**：接口中可以定义有方法体的方法。（默认方法、静态方法）
- **JDK9的新特性**：接口中可以定义私有方法。

### JDK8以后接口中新增的默认方法

- 允许在接口中定义默认方法，需要使用关键字default修饰。  
  作用：解决接口升级的问题

- 接口中**默认方法**的定义格式：
  - 格式：`public default 返回值类型 方法名（参数列表）{}`
  - 范例：`public default void show() {}`

- 接口中默认方法的注意事项：
  - 默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字。
  - public 可以省略，default 不能省略。
  - 如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写。

### JDK8以后接口中新增的静态方法

- 允许在接口中定义静态方法，需要用 static 修饰
- 接口中**静态方法**的定义格式：
  - 格式：`public static 返回值类型 方法名（参数列表）`
  - 范例：`public static void show(){}`

- 接口中静态方法的注意事项：
  - 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用
  - public 可以省略，static 不能省略

### JDK9以后接口中新增的私有方法

**此方法只为接口提供服务，不需要外类访问**
- 接口中私有方法的定义格式：
  - 格式1：`private 返回值类型 方法名（参数列表）{}`  
    范例1：`private void show(){} //普通的私有方法，给默认方法服务的`
  - 格式2：`private static 返回值类型 方法名 （参数列表）{}`  
    范例2：`private static void method(){} //静态的私有方法，给静态方法服务的`

### 接口的应用

- 接口代表规则，是行为的抽象。想要让哪个类拥有一个行为，就让这个类实现对应的接口就可以了。
- 当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态。


## 内部类

类的五大成员：属性、方法、构造方法、代码块、内部类  
内部类的访问特点：
- 内部类可以直接访问外部类的成员，包括私有
- 外部类要访问内部类的成员，必须创建对象


## 常用API

### System

- 也是一个工具类，提供了一些与系统相关的方法
- 时间原点：1970年1月1日 0:0:0，我国在东八区，有8小时时差，因此原点为1970年1月1日 8:0:0
- 1秒 = 1000 毫秒
- 常见方法
  - exit：停止虚拟机
  - currentTimeMillis：过去当前时间的毫秒值
  - arraycopy：拷贝数组

### Runtime

表示当前虚拟机的运行环境，是一个类但不能直接建立对象，要用 getRuntime 获取.
```java
public static Runtime getRuntime() //当前系统的运行环境对象
public void exit(int status)       //停止虚拟机
public int availableProcessors()   //获得CPU的线程数
public long maxMemory()            //JVM能从系统钟获取总内存大小（单位byte）
public long totalMemory()          //JVM已经从系统中获取总内存大小（单位byte）
public long freeMemory()           //JVM剩余内存大小（单位byte）
public Process exec(String command)//运行 cmd 命令
```


## Lambda表达式（JDK8后）

- 函数式编程（Functional programming）是一种思想特点，忽略面向对象的复杂语法，强调做什么，而不是谁去做。Lambda表达式就是函数式思想的体现。
- 面向对象：先找对象，让对象做事情 
- 注意点：
  - Lambda表达式可以用来简化匿名内部类的书写
  - Lambda表达式只能简化函数式接口的匿名内部类的写法
  - 函数式接口：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@FunctionalInterface注解
- Lambda的省略规则：
  - 1.参数类型可以省略不写
  - 2.如果只有一个参数，参数类型可以省略，同时()也可以省略
  - 3.如果Lambda表达式的方法体只有一行，大括号，分号，return可以省略不写，需要同时省略。

```java
()->{
}
```


## 泛型

泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。   
**泛型的格式**：<数据类型>  
注意：泛型只能支持引用数据类型。  
使用泛型的原因：如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型，此时可以往集合中添加任意的数据类型。但带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。  
扩展知识点：Java中的泛型是伪泛型  

### 泛型的好处

- 统一数据类型
- 把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来。

### 泛型的细节

- 泛型中不能写基本数据类型
- 指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型
- 如果不写泛型，类型默认是 **Object**

### 泛型类

如果一个类不确定类型，那么这个类就可以定义为泛型类，在类名后面定义泛型。

### 泛型方法

方法中形参类型不确定时，
- 1. 可以使用类名后面定义的泛型 `<E>`
- 2. 在方法申明上定义自己的泛型

```java
修饰符 <类型> 返回值类型 方法名(类型 变量名){
}

public <T> void show(T t){
}
//此处可以理解为变量，但是不是用来记录数据的，而是记录类型的，可以写成：T、E、K、V等
```

### 泛型接口

```java
修饰符 interface 接口名<类型>{
}

public interface List<E>{
}
```

泛型接口的两种使用方式：
1. 实现类给出具体的类型
2. 实现类延续泛型，创建实现类对象时再确定类型

### 泛型的继承和通配符

- 泛型不具备继承性（不能通过多态传递子类对象），但是数据具备继承性（指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型）  
```java
public static void method(ArrayList<Animal> list){
}//在调用method方法时只能是Animal类型，不能传递其子类，因为泛型不具备继承性

ArrayList<Ye> list1 = new ArrayList<>();
list1.add(new Ye());//数据具备继承性
list1.add(new Fu());
list1.add(new Zi());
```

- 泛型的通配符：
  - ? 也表示不确定的类型，可以进行类型范围的限定
  - ? extends E ：表示可以传递E或者E的所有的子类类型
  - ? super E ：表示可以传递E或者E所有的父类类型
  - 应用场景：如果在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以使用泛型的通配符。