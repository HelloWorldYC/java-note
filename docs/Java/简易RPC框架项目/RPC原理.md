---
title: 'RPC原理'
---

## 什么是 RPC？
RPC (Remote Procedure Call)，即远程过程调用，实现跟本地调用一样的效果，客户端通过发送调用方法名称及参数等给服务端，等客户端处理后返回结果到调用处。中间还需要一个媒介作为统筹管理的，给服务端注册服务。

## RPC 有哪些组成部分？
<div align="center"><img src="./asserts/RPC框架组成.png" width="100%"/></div> 

- 注册中心：负责服务地址的注册与查找，存储着服务名称以及对应的服务地址（服务端地址）。
- 服务端：提供远程方法的一端。
- 服务端 Stub：这个不是代理类，负责将传输过来的方法、参数反序列化，调用服务端方法，将调用结果序列化，通过网络传输到客户端。
- 客户端：调用远程方法的一端。
- 客户端 Stub：其实是一个代理类，负责将方法、参数等序列化，通过网络传输到服务端，以及将返回结果反序列化，返回到调用处。
- 监控中心：负责统计服务的调用次数和调用时间。


## 为什么 RPC 中要用到动态代理？
因为我们在调用远程方法的时候，不需要关心远程方法调用的细节比如网络传输，所以要屏蔽掉远程方法调用的底层细节。当我们在调用远程方法的时候，实际会通过代理对象来传输网络请求（client stub）。


## 为什么不推荐使用 JDK 自带的序列化？
主要有以下几个原因：  
- 不支持跨语言调用：如果调用的是其他语言开发的服务的时候就不支持了。
- 性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。
- 存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化代码的数据可被用户控制，那么攻击者可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的恶意代码。


## 为什么要采用 kyro 作为序列化方式？
因为 JDK 自带的序列化方式不太友好，protobuf 和 protostuff 虽然性能优秀，也支持跨语言，但使用较为繁琐。而 kyro 则是专门针对 Java 语言序列化的，并且性能非常好。项目尚不需要跨语言，所以使用 kyro 比较方便一些。



### 参考博客
- https://www.cnblogs.com/luffsama/articles/17219842.html

