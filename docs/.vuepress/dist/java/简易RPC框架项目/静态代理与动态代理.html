<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>静态代理与动态代理 | The Note of HelloWorldYC</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/Note/assets/css/0.styles.e7ea4a54.css" as="style"><link rel="preload" href="/Note/assets/js/app.d6f962c2.js" as="script"><link rel="preload" href="/Note/assets/js/3.f13ea13a.js" as="script"><link rel="preload" href="/Note/assets/js/49.eea223ac.js" as="script"><link rel="prefetch" href="/Note/assets/js/10.6675e027.js"><link rel="prefetch" href="/Note/assets/js/11.87307cba.js"><link rel="prefetch" href="/Note/assets/js/12.ec65cb79.js"><link rel="prefetch" href="/Note/assets/js/13.4aa2a872.js"><link rel="prefetch" href="/Note/assets/js/14.8e9bb48e.js"><link rel="prefetch" href="/Note/assets/js/15.66febbed.js"><link rel="prefetch" href="/Note/assets/js/16.dd138829.js"><link rel="prefetch" href="/Note/assets/js/17.b6b3b551.js"><link rel="prefetch" href="/Note/assets/js/18.08d09012.js"><link rel="prefetch" href="/Note/assets/js/19.d893289c.js"><link rel="prefetch" href="/Note/assets/js/2.e2b74cb0.js"><link rel="prefetch" href="/Note/assets/js/20.cc630c63.js"><link rel="prefetch" href="/Note/assets/js/21.84d0ce12.js"><link rel="prefetch" href="/Note/assets/js/22.463c1301.js"><link rel="prefetch" href="/Note/assets/js/23.6dca4996.js"><link rel="prefetch" href="/Note/assets/js/24.c99ed31c.js"><link rel="prefetch" href="/Note/assets/js/25.7442eb8d.js"><link rel="prefetch" href="/Note/assets/js/26.e630a00d.js"><link rel="prefetch" href="/Note/assets/js/27.b70c0e79.js"><link rel="prefetch" href="/Note/assets/js/28.12588708.js"><link rel="prefetch" href="/Note/assets/js/29.eaf51c45.js"><link rel="prefetch" href="/Note/assets/js/30.4bfbbfe1.js"><link rel="prefetch" href="/Note/assets/js/31.fdad4f5a.js"><link rel="prefetch" href="/Note/assets/js/32.745fe228.js"><link rel="prefetch" href="/Note/assets/js/33.2bf695af.js"><link rel="prefetch" href="/Note/assets/js/34.e8f40437.js"><link rel="prefetch" href="/Note/assets/js/35.f20c2c59.js"><link rel="prefetch" href="/Note/assets/js/36.67b5d288.js"><link rel="prefetch" href="/Note/assets/js/37.00f7053e.js"><link rel="prefetch" href="/Note/assets/js/38.43552331.js"><link rel="prefetch" href="/Note/assets/js/39.38251187.js"><link rel="prefetch" href="/Note/assets/js/4.98ddd51f.js"><link rel="prefetch" href="/Note/assets/js/40.d4638ab4.js"><link rel="prefetch" href="/Note/assets/js/41.abbf3f9f.js"><link rel="prefetch" href="/Note/assets/js/42.d102e5f4.js"><link rel="prefetch" href="/Note/assets/js/43.6eba663b.js"><link rel="prefetch" href="/Note/assets/js/44.e76d94a0.js"><link rel="prefetch" href="/Note/assets/js/45.75c4b07d.js"><link rel="prefetch" href="/Note/assets/js/46.18701aaf.js"><link rel="prefetch" href="/Note/assets/js/47.e530e427.js"><link rel="prefetch" href="/Note/assets/js/48.fc8e85ed.js"><link rel="prefetch" href="/Note/assets/js/5.c76159c1.js"><link rel="prefetch" href="/Note/assets/js/50.ff79d351.js"><link rel="prefetch" href="/Note/assets/js/51.21d38537.js"><link rel="prefetch" href="/Note/assets/js/52.c63759cb.js"><link rel="prefetch" href="/Note/assets/js/53.d51f411c.js"><link rel="prefetch" href="/Note/assets/js/54.37e7117b.js"><link rel="prefetch" href="/Note/assets/js/55.34d90add.js"><link rel="prefetch" href="/Note/assets/js/56.98359155.js"><link rel="prefetch" href="/Note/assets/js/57.29988177.js"><link rel="prefetch" href="/Note/assets/js/58.c650bac7.js"><link rel="prefetch" href="/Note/assets/js/59.29b53807.js"><link rel="prefetch" href="/Note/assets/js/6.771e7053.js"><link rel="prefetch" href="/Note/assets/js/60.b618a5bf.js"><link rel="prefetch" href="/Note/assets/js/61.ad67d84d.js"><link rel="prefetch" href="/Note/assets/js/62.aafeb3d9.js"><link rel="prefetch" href="/Note/assets/js/63.74197080.js"><link rel="prefetch" href="/Note/assets/js/64.e1a3b362.js"><link rel="prefetch" href="/Note/assets/js/65.cbc39846.js"><link rel="prefetch" href="/Note/assets/js/66.c87b0be4.js"><link rel="prefetch" href="/Note/assets/js/7.2aea5681.js"><link rel="prefetch" href="/Note/assets/js/8.874d71a8.js"><link rel="prefetch" href="/Note/assets/js/9.cc85cdbd.js">
    <link rel="stylesheet" href="/Note/assets/css/0.styles.e7ea4a54.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Note/" class="home-link router-link-active"><!----> <span class="site-name">The Note of HelloWorldYC</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>matlab</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>无人机项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数字图像处理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深度学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>信源数估计</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Java框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>校园信息交流平台项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>简易RPC框架项目</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Note/Java/简易RPC框架项目/RPC原理.html" class="sidebar-link">RPC原理</a></li><li><a href="/Note/Java/简易RPC框架项目/Socket网络通信.html" class="sidebar-link">Socket网络通信</a></li><li><a href="/Note/Java/简易RPC框架项目/Netty从入门到网络通信实战.html" class="sidebar-link">Netty从入门到网络通信实战</a></li><li><a href="/Note/Java/简易RPC框架项目/项目网络传输模块细节.html" class="sidebar-link">项目网络传输模块细节</a></li><li><a href="/Note/Java/简易RPC框架项目/项目注册中心模块细节.html" class="sidebar-link">项目注册中心模块细节</a></li><li><a href="/Note/Java/简易RPC框架项目/Zookeeper.html" class="sidebar-link">Zookeeper</a></li><li><a href="/Note/Java/简易RPC框架项目/服务注册与消费细节.html" class="sidebar-link">服务注册与消费细节</a></li><li><a href="/Note/Java/简易RPC框架项目/负载均衡细节.html" class="sidebar-link">负载均衡细节</a></li><li><a href="/Note/Java/简易RPC框架项目/静态代理与动态代理.html" class="active sidebar-link">静态代理与动态代理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Note/Java/简易RPC框架项目/静态代理与动态代理.html#代理模式" class="sidebar-link">代理模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Note/Java/简易RPC框架项目/静态代理与动态代理.html#代理模式和-aop-有什么区别" class="sidebar-link">代理模式和 AOP 有什么区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/Note/Java/简易RPC框架项目/静态代理与动态代理.html#静态代理" class="sidebar-link">静态代理</a></li><li class="sidebar-sub-header"><a href="/Note/Java/简易RPC框架项目/静态代理与动态代理.html#动态代理" class="sidebar-link">动态代理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/Note/Java/简易RPC框架项目/静态代理与动态代理.html#jdk-动态代理机制" class="sidebar-link">JDK 动态代理机制</a></li><li class="sidebar-sub-header"><a href="/Note/Java/简易RPC框架项目/静态代理与动态代理.html#cglib-动态代理" class="sidebar-link">CGLIB 动态代理</a></li><li class="sidebar-sub-header"><a href="/Note/Java/简易RPC框架项目/静态代理与动态代理.html#jdk-动态代理和-cglib-动态代理对比" class="sidebar-link">JDK 动态代理和 CGLIB 动态代理对比</a></li></ul></li><li class="sidebar-sub-header"><a href="/Note/Java/简易RPC框架项目/静态代理与动态代理.html#静态代理和动态代理的对比" class="sidebar-link">静态代理和动态代理的对比</a></li><li class="sidebar-sub-header"><a href="/Note/Java/简易RPC框架项目/静态代理与动态代理.html#参考博客" class="sidebar-link">参考博客</a></li></ul></li><li><a href="/Note/Java/简易RPC框架项目/Docker.html" class="sidebar-link">Docker</a></li><li><a href="/Note/Java/简易RPC框架项目/项目过程中遇到的bug.html" class="sidebar-link">项目过程中遇到的bug</a></li><li><a href="/Note/Java/简易RPC框架项目/项目问题.html" class="sidebar-link">项目可能问的问题</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>内功</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="代理模式"><a href="#代理模式" class="header-anchor">#</a> 代理模式</h2> <p>代理模式是一种比较好理解的设计模式。简单来说就是，<strong>我们使用代理对象来代替真实对象（real object）的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong><br> <strong>代理模式的主要作用就是扩展目标对象的功能，比如说在目标对象的某个方法执行前后可以增加一些自定义的操作。（与 AOP 很像，但不是同一个概念）</strong><br>
代理模式有<strong>静态代理</strong>和<strong>动态代理</strong>两种实现方式。</p> <h3 id="代理模式和-aop-有什么区别"><a href="#代理模式和-aop-有什么区别" class="header-anchor">#</a> 代理模式和 AOP 有什么区别</h3> <ol><li>目的和关注点：代理模式的主要目的是控制对对象的访问，并在访问前后执行额外的逻辑。它的关注点是对象的访问控制和增加附加功能。而 AOP 的主要目的是将横切关注点（如日志记录、事务管理、安全性等）从核心业务逻辑中分离出来，使代码更加模块化和可维护。</li> <li>引入方式：代理模式通过创建一个代理对象来实现对目标对象的间接访问。代理对象封装了目标对象，并在必要时对目标对象的方法进行拦截和处理。AOP 通过在运行时将切面织入到目标对象中来实现横切关注点的功能。切面可以通过编译时或运行时的方式来实现。</li> <li>范围：代理模式通常局限于单个对象的访问控制和功能增强，代理对象与目标对象一一对应。而 AOP 可以应用于整个应用程序的多个对象，并跨越不同的业务逻辑。</li> <li>修改原始代码：代理模式不需要修改目标对象的原始代码，代理对象在运行时通过封装目标对象来进行控制。而 AOP 的实现通常需要修改目标对象的字节码或运行时生成代理对象，以便将切面织入到目标对象的方法中。</li></ol> <p>尽管代理模式和 AOP 是不同的概念，但可以使用代理模式来实现 AOP。在 AOP 中，代理对象可以充当切面，通过拦截目标对象的方法调用来执行横切逻辑。代理对象可以在方法调用之前或之后执行所需的操作，从而实现与 AOP 类似的功能。因此，代理模式可以作为实现 AOP 的一种方式。<br>
总的来说，代理模式和 AOP 都是为了增加代码的灵活性和可维护性，但它们的实现方式、关注点和应用范围有所不同。代理模式主要用于对象访问控制和功能增强，而 AOP 主要用于将横切关注点从核心业务逻辑中分离出来。</p> <h2 id="静态代理"><a href="#静态代理" class="header-anchor">#</a> 静态代理</h2> <p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦（需要对每个目标类都单独写一个代理类）。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。<br>
从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p> <p>静态代理实现步骤：</p> <ol><li>定义一个接口及其实现类；</li> <li>创建一个代理类同样实现这个接口；</li> <li>将目标对象注入到代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些增强操作。</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 定义接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SmsService</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义接口的实现类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmsServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SmsService</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;send message: &quot;</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 创建代理类并实现接口</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmsProxy</span> <span class="token keyword">implements</span> <span class="token class-name">SmsService</span> <span class="token punctuation">{</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">SmsProxy</span><span class="token punctuation">(</span><span class="token class-name">SmsService</span> smsService<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>smsService <span class="token operator">=</span> smsService<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用方法前的增强操作</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;before method send()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        smsService<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用方法后的增强</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;after method send()&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实际使用时</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SmsService</span> smsService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmsServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">SmsProxy</span> smsProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SmsProxy</span><span class="token punctuation">(</span>smsService<span class="token punctuation">)</span><span class="token punctuation">;</span>
        smsProxy<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;java&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="动态代理"><a href="#动态代理" class="header-anchor">#</a> 动态代理</h2> <p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB 动态代理机制)。<br> <strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</strong><br>
说到动态代理，Spring AOP、RPC 框架应该是两个不得不提的，它们的实现都依赖了动态代理。<br>
就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理、CGLIB 动态代理</strong>等等。</p> <h3 id="jdk-动态代理机制"><a href="#jdk-动态代理机制" class="header-anchor">#</a> JDK 动态代理机制</h3> <p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong><br> <code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * @param loader        类加载器，用于加载代理对象
 * @param interfaces    被代理类实现的一些接口
 * @param h             实现了 InvocationHandler 接口的对象
 * @throws Exception
 */</span>
 <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token class-name">ClassLoader</span> loader<span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces<span class="token punctuation">,</span>
 <span class="token class-name">InvocationHandler</span> h<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IllegalArgumentException</span>
    <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>通过 <code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code> 方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p> <p>JDK 动态代理类使用步骤：</p> <ol><li>定义一个接口及其实现类；</li> <li>自定义 <code>InvocationHandler</code> 并重写 <code>invoke()</code> 方法，在 <code>invoke()</code> 方法中调用原生方法（被代理类的方法）并自定义一些处理逻辑（增强）；</li> <li>通过 <code>Proxy.newProxyInstance()</code> 方法创建代理对象;</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 定义接口</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">SmsService</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义实现类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SmsServiceImpl</span> <span class="token keyword">implements</span> <span class="token class-name">SmsService</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;send message:&quot;</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义 JDK 动态代理类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DebugInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>
    <span class="token comment">// 代理类中的真实对象</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">DebugInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 invoke() 方法，然后 invoke() 方法代替我们去调用了被代理对象的原生方法。</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InvocationTargetException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalAccessException</span> <span class="token punctuation">{</span>
        <span class="token comment">// 调用方法前的增强操作</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;before method &quot;</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 通过 Method 对象的 invoke 方法来动态调用方法。</span>
        <span class="token comment">// 通过 Method 对象，可以传递方法所属的对象实例、方法的参数值，并调用该方法。</span>
        <span class="token class-name">Object</span> result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 调用方法后的增强操作</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;after method &quot;</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取代理对象的工厂类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JdkProxyFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>
                target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// 目标类的类加载器</span>
                target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>  <span class="token comment">// 代理需要实现的接口，可指定多个</span>
                <span class="token keyword">new</span> <span class="token class-name">DebugInvocationHandler</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span>  <span class="token comment">// 代理对象对应的自定义 InvocationHandler</span>
        <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实际使用时</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">SmsService</span> smsService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">SmsService</span><span class="token punctuation">)</span> <span class="token class-name">JdkProxyFactory</span><span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SmsServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        smsService<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;java&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="cglib-动态代理"><a href="#cglib-动态代理" class="header-anchor">#</a> CGLIB 动态代理</h3> <p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。</strong><br> <strong>为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p> <p>CGLIB (Code Generation Library) 是一个基于 ASM 的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了 CGLIB， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p> <p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong>  需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MethodInterceptor</span> <span class="token keyword">extends</span> <span class="token class-name">Callback</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
      * 拦截被代理类中的方法 
      * @param obj       被代理的对象（需要增强的对象）
      * @param method    被拦截的方法（需要增强的方法）
      * @param args      方法参数
      * @param proxy     用于调用原始方法
      * @throws Exception
    */</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span><span class="token class-name">MethodProxy</span> proxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>可以通过 <code>Enhancer</code> 类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p> <p>CGLIB 动态代理使用步骤：</p> <ol><li>定义一个类；</li> <li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept()</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke()</code> 方法类似；</li> <li>通过 <code>Enhancer</code> 类的 <code>create()</code> 方法创建代理类；</li></ol> <div class="language-xml extra-class"><pre class="language-xml"><code>// 添加依赖
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.3.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 自定义一个类</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AliSmsService</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">send</span><span class="token punctuation">(</span><span class="token class-name">String</span> message<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;send message:&quot;</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> message<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 自定义 MethodInterceptor 方法拦截器</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DebugMethodInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
      * 拦截被代理类中的方法 
      * @param obj       被代理的对象（需要增强的对象）
      * @param method    被拦截的方法（需要增强的方法）
      * @param args      方法参数
      * @param proxy     用于调用原始方法
      * @throws Exception
    */</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>
        <span class="token comment">// 方法调用前的增强操作</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;before method &quot;</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Object</span> object <span class="token operator">=</span> methodProxy<span class="token punctuation">.</span><span class="token function">invokeSuper</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 方法调用后的增强操作</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;after method &quot;</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> object<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 获取代理类,通过 `Enhancer` 类的 `create()` 方法创建代理类；</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CglibProxyFactory</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> <span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 创建动态代理增强类</span>
        <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置类加载器</span>
        enhancer<span class="token punctuation">.</span><span class="token function">setClassLoader</span><span class="token punctuation">(</span>clazz<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置被代理类</span>
        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>clazz<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 设置方法拦截器</span>
        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">DebugMethodInterceptor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 创建代理类</span>
        <span class="token keyword">return</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 实际使用时</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">AliSmsService</span> aliSmsService <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">AliSmsService</span><span class="token punctuation">)</span> <span class="token class-name">CglibProxyFactory</span><span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token class-name">AliSmsService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        aliSmsService<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&quot;java&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="jdk-动态代理和-cglib-动态代理对比"><a href="#jdk-动态代理和-cglib-动态代理对比" class="header-anchor">#</a> JDK 动态代理和 CGLIB 动态代理对比</h3> <ol><li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， **CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，**因此不能代理声明为 final 类型的类和方法。</li> <li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li></ol> <h2 id="静态代理和动态代理的对比"><a href="#静态代理和动态代理的对比" class="header-anchor">#</a> 静态代理和动态代理的对比</h2> <ol><li><strong>灵活性</strong>：动态代理更加灵活，不需要必须实现接口（CGLIB 动态代理），可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li> <li><strong>JVM 层面</strong>：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li></ol> <h2 id="参考博客"><a href="#参考博客" class="header-anchor">#</a> 参考博客</h2> <ul><li>https://javaguide.cn/java/basis/proxy.html</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/Note/Java/简易RPC框架项目/负载均衡细节.html" class="prev">
        负载均衡细节
      </a></span> <span class="next"><a href="/Note/Java/简易RPC框架项目/Docker.html">
        Docker
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/Note/assets/js/app.d6f962c2.js" defer></script><script src="/Note/assets/js/3.f13ea13a.js" defer></script><script src="/Note/assets/js/49.eea223ac.js" defer></script>
  </body>
</html>
