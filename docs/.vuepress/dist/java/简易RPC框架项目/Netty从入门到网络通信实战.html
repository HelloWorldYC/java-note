<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Netty从入门到网络通信实战 | java</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/java-note/images/myfavicon.png">
    <meta name="description" content="java 学习笔记">
    
    <link rel="preload" href="/java-note/assets/css/0.styles.708fcbbf.css" as="style"><link rel="preload" href="/java-note/assets/js/app.4802240e.js" as="script"><link rel="preload" href="/java-note/assets/js/2.834e1286.js" as="script"><link rel="preload" href="/java-note/assets/js/1.56911593.js" as="script"><link rel="preload" href="/java-note/assets/js/63.75fdcace.js" as="script"><link rel="prefetch" href="/java-note/assets/js/10.7f863a77.js"><link rel="prefetch" href="/java-note/assets/js/11.6b66a110.js"><link rel="prefetch" href="/java-note/assets/js/12.8440333d.js"><link rel="prefetch" href="/java-note/assets/js/13.1f1fe7b4.js"><link rel="prefetch" href="/java-note/assets/js/14.65ef5a04.js"><link rel="prefetch" href="/java-note/assets/js/15.f60694df.js"><link rel="prefetch" href="/java-note/assets/js/16.efadbd73.js"><link rel="prefetch" href="/java-note/assets/js/17.d9390df8.js"><link rel="prefetch" href="/java-note/assets/js/18.2f93832a.js"><link rel="prefetch" href="/java-note/assets/js/19.e21d8298.js"><link rel="prefetch" href="/java-note/assets/js/20.c801663f.js"><link rel="prefetch" href="/java-note/assets/js/21.ed1b35e4.js"><link rel="prefetch" href="/java-note/assets/js/22.33b69923.js"><link rel="prefetch" href="/java-note/assets/js/23.d0cb6ea3.js"><link rel="prefetch" href="/java-note/assets/js/24.77c390b0.js"><link rel="prefetch" href="/java-note/assets/js/25.93636fbb.js"><link rel="prefetch" href="/java-note/assets/js/26.17ffe540.js"><link rel="prefetch" href="/java-note/assets/js/27.903242ff.js"><link rel="prefetch" href="/java-note/assets/js/28.dc5daf82.js"><link rel="prefetch" href="/java-note/assets/js/29.95e7dd6e.js"><link rel="prefetch" href="/java-note/assets/js/3.5c83221f.js"><link rel="prefetch" href="/java-note/assets/js/30.ab86d2f2.js"><link rel="prefetch" href="/java-note/assets/js/31.bb5e7344.js"><link rel="prefetch" href="/java-note/assets/js/32.a33b149c.js"><link rel="prefetch" href="/java-note/assets/js/33.e5f25c3c.js"><link rel="prefetch" href="/java-note/assets/js/34.30d8a274.js"><link rel="prefetch" href="/java-note/assets/js/35.5d8fa2f0.js"><link rel="prefetch" href="/java-note/assets/js/36.1e873df7.js"><link rel="prefetch" href="/java-note/assets/js/37.594daa95.js"><link rel="prefetch" href="/java-note/assets/js/38.bc0467b7.js"><link rel="prefetch" href="/java-note/assets/js/39.dd90bf94.js"><link rel="prefetch" href="/java-note/assets/js/4.f186242d.js"><link rel="prefetch" href="/java-note/assets/js/40.70522d96.js"><link rel="prefetch" href="/java-note/assets/js/41.1f09c6b9.js"><link rel="prefetch" href="/java-note/assets/js/42.49f51f5c.js"><link rel="prefetch" href="/java-note/assets/js/43.29326b6e.js"><link rel="prefetch" href="/java-note/assets/js/44.8408958a.js"><link rel="prefetch" href="/java-note/assets/js/45.a061f8ad.js"><link rel="prefetch" href="/java-note/assets/js/46.7b5df9fc.js"><link rel="prefetch" href="/java-note/assets/js/47.990d3a28.js"><link rel="prefetch" href="/java-note/assets/js/48.4ae8f2d5.js"><link rel="prefetch" href="/java-note/assets/js/49.880752cc.js"><link rel="prefetch" href="/java-note/assets/js/5.377eaaa7.js"><link rel="prefetch" href="/java-note/assets/js/50.a0ba8023.js"><link rel="prefetch" href="/java-note/assets/js/51.34976563.js"><link rel="prefetch" href="/java-note/assets/js/52.23629959.js"><link rel="prefetch" href="/java-note/assets/js/53.8ad3e7eb.js"><link rel="prefetch" href="/java-note/assets/js/54.018f6f49.js"><link rel="prefetch" href="/java-note/assets/js/55.f7b9ff66.js"><link rel="prefetch" href="/java-note/assets/js/56.c1a1091c.js"><link rel="prefetch" href="/java-note/assets/js/57.a314e87a.js"><link rel="prefetch" href="/java-note/assets/js/58.b3b40ad4.js"><link rel="prefetch" href="/java-note/assets/js/59.6ca124ae.js"><link rel="prefetch" href="/java-note/assets/js/6.d127c244.js"><link rel="prefetch" href="/java-note/assets/js/60.62927391.js"><link rel="prefetch" href="/java-note/assets/js/61.9f3ed6b5.js"><link rel="prefetch" href="/java-note/assets/js/62.186bc77d.js"><link rel="prefetch" href="/java-note/assets/js/64.e3d406b8.js"><link rel="prefetch" href="/java-note/assets/js/65.b6b92143.js"><link rel="prefetch" href="/java-note/assets/js/66.a832b085.js"><link rel="prefetch" href="/java-note/assets/js/67.a165eb09.js"><link rel="prefetch" href="/java-note/assets/js/68.b710e3a6.js"><link rel="prefetch" href="/java-note/assets/js/69.8d29ae2a.js"><link rel="prefetch" href="/java-note/assets/js/7.8472e88f.js"><link rel="prefetch" href="/java-note/assets/js/70.25a2b7b3.js"><link rel="prefetch" href="/java-note/assets/js/71.fe7a34d2.js"><link rel="prefetch" href="/java-note/assets/js/vendors~docsearch.3f62eedb.js">
    <link rel="stylesheet" href="/java-note/assets/css/0.styles.708fcbbf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/java-note/" class="home-link router-link-active"><!----> <span class="site-name">java</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>校园信息交流平台项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>简易RPC框架项目</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-note/Java/简易RPC框架项目/RPC原理.html" class="sidebar-link">RPC原理</a></li><li><a href="/java-note/Java/简易RPC框架项目/Socket网络通信.html" class="sidebar-link">Socket网络通信</a></li><li><a href="/java-note/Java/简易RPC框架项目/Netty从入门到网络通信实战.html" class="active sidebar-link">Netty从入门到网络通信实战</a></li><li><a href="/java-note/Java/简易RPC框架项目/项目网络传输模块细节.html" class="sidebar-link">项目网络传输模块细节</a></li><li><a href="/java-note/Java/简易RPC框架项目/项目注册中心模块细节.html" class="sidebar-link">项目注册中心模块细节</a></li><li><a href="/java-note/Java/简易RPC框架项目/Zookeeper.html" class="sidebar-link">Zookeeper</a></li><li><a href="/java-note/Java/简易RPC框架项目/服务注册与消费细节.html" class="sidebar-link">服务注册与消费细节</a></li><li><a href="/java-note/Java/简易RPC框架项目/负载均衡细节.html" class="sidebar-link">负载均衡细节</a></li><li><a href="/java-note/Java/简易RPC框架项目/静态代理与动态代理.html" class="sidebar-link">静态代理与动态代理</a></li><li><a href="/java-note/Java/简易RPC框架项目/Docker.html" class="sidebar-link">Docker</a></li><li><a href="/java-note/Java/简易RPC框架项目/项目过程中遇到的bug.html" class="sidebar-link">项目过程中遇到的bug</a></li><li><a href="/java-note/Java/简易RPC框架项目/项目问题.html" class="sidebar-link">项目可能问的问题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>内功</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>知识点自测速记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="nio"><a href="#nio" class="header-anchor">#</a> NIO</h2> <p>要理解 Netty，首先要了解 NIO。</p> <h3 id="nio、bio、aio"><a href="#nio、bio、aio" class="header-anchor">#</a> NIO、BIO、AIO</h3> <p>BIO、NIO 是基于 Linux 的后端开发的重要 I/O 模型。</p> <ul><li>NIO(Non-blocking I/O)：非阻塞 I/O，</li></ul> <h2 id="netty"><a href="#netty" class="header-anchor">#</a> Netty</h2> <h3 id="什么是-netty"><a href="#什么是-netty" class="header-anchor">#</a> 什么是 Netty？</h3> <ol><li>Netty 是一个基于 NIO 的 client-server 框架，使用它可以快速简单地开发网络应用程序。</li> <li>它极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程，并且性能以及安全性等很多方面甚至都要更好。</li> <li>支持多种协议如 FTP、SMTP、HTTP 以及各种二进制和基于文本的传统协议。</li></ol> <blockquote><p>用官方的总结：Netty 成功找到了一种在不妥协可维护性和性能的情况下实现易于开发、性能、稳定性和灵活性的方法。</p></blockquote> <h3 id="netty-特点"><a href="#netty-特点" class="header-anchor">#</a> Netty 特点？</h3> <h3 id="使用-netty-能做什么"><a href="#使用-netty-能做什么" class="header-anchor">#</a> 使用 Netty 能做什么？</h3> <h3 id="为什么使用-netty-而不用原生的-nio"><a href="#为什么使用-netty-而不用原生的-nio" class="header-anchor">#</a> 为什么使用 Netty 而不用原生的 NIO？</h3> <ul><li>Netty 的框架底层封装了 NIO。</li> <li>NIO 存 API 复杂难用，尤其是 ByteBuffer 的指针切来切去，在 Netty 当中封装了好用的 ByteBuf。</li> <li>NIO 子设计的可靠性不易保证，断线重连、半包粘包、网络拥塞统统需要自己考虑。</li></ul> <h2 id="eventloopgroup-和-eventloop"><a href="#eventloopgroup-和-eventloop" class="header-anchor">#</a> EventLoopGroup 和 EventLoop</h2> <ul><li>EventLoopGroup 是一组 EventLoop 的容器，用于管理和调度多个 EventLoop。它通常在启动 Netty 服务器或客户端时创建，用于处理所有的网络请求和事件。EventLoopGroup 负责为每个 Channel 分配 EventLoop，并负责管理这些 EventLoop 的生命周期。</li> <li>EventLoop 是 Netty中的事件循环，它负责处理一个或多个 Channel 上的事件，相当于一个线程。每个 Channel 都会被分配到一个 EventLoop 上，而一个 EventLoop 可以处理多个 Channel。EventLoop 内部维护着一个事件循环，通过不断地循环等待事件的发生，并执行相应的任务来处理这些事件。EventLoop 使用单线程来处理事件，因此是线程安全的。</li> <li>一个 EventLoopGroup 通常包含多个 EventLoop，这些 EventLoop 共享一个线程池（也称为执行器），用于执行事件处理任务。EventLoopGroup 在创建时会初始化一组 EventLoop，并在需要时将 Channel 分配给其中一个 EventLoop 来处理。这种方式能够实现高效的事件处理和并发连接管理。</li></ul> <h3 id="bosseventloopgroup-和-workereventloopgroup"><a href="#bosseventloopgroup-和-workereventloopgroup" class="header-anchor">#</a> bossEventLoopGroup 和 workerEventLoopGroup</h3> <p>在 Netty 服务器端编程中，我们需要设置 BossEventLoopGroup 和 WorkerEventLoopGroup 两个 EventLoopGroup 来进行工作。</p> <p>BossEventLoopGroup 通常是一个单线程的 EventLoop，这个 EventLoop 维护着一个注册了 ServerSocketChannel 的 Selector 实例，它的实现涵盖 IO 事件的分离，和分发（Dispatcher），充当 Reactor 模式中的分发（Dispatcher）的角色。所以通常可以将 BossEventLoopGroup 的线程数参数为 1。</p> <p>BossEventLoop 只负责处理连接，故开销非常小，连接到来，马上按照策略将 SocketChannel 转发给 WorkerEventLoopGroup，WorkerEventLoopGroup 会由 next() 选择其中一个 EventLoop 来将这个SocketChannel 注册到其维护的 Selector 并对其后续的 IO 事件进行处理。</p> <blockquote><p>在实际中，总共有多个线程组以及一个初始线程：</p> <ul><li>初始线程（/主线程）：负责设置 serverBootstrap，包括 BossEventLoopGroup、workerEventLoopGroup、Handler 等多个设置，绑定服务端监听客户端请求的端口（这个端口是服务端本地的端口），以及监听端口的关闭（意味着服务端关闭，服务结束）。</li> <li>BossEventLoopGroup：负责处理连接的单线程池。</li> <li>WorkerEventLoopGroup：负责对 SocketChannel 后续的 IO 事件进行处理的线程池。</li> <li>ServiceHandlerGroup：一般是处理自定义服务器 Handler 的线程池，也就是处理解码解压缩之后的真正的请求的线程池。</li></ul></blockquote> <h3 id="eventloopgroup-使用"><a href="#eventloopgroup-使用" class="header-anchor">#</a> EventLoopGroup 使用</h3> <ul><li>EventLoopGroup 可以通过构造方法设置 EventLoop 的个数，默认创建的 EventLoop 是 <code>CPU 核心数 × 2</code></li> <li><code>EventLoopGroup.next()</code>：该方法返回下一个将要使用的 EventLoop，相当于线程池返回下一个用来处理任务的线程。</li></ul> <h3 id="defaulteventloop-和-nioeventloop-区别"><a href="#defaulteventloop-和-nioeventloop-区别" class="header-anchor">#</a> DefaultEventLoop 和 NioEventLoop 区别</h3> <ol><li>NioEventLoop 是一个线程，用于 IO Read Write 监控</li> <li>DefaultEventLoop 是一个普通线程，工作内容可以由程序员决定，不做 IO 监控</li></ol> <blockquote><p>后续 Netty 进行多线程开发，推荐大家优先考虑 DefaultEventLoop。</p></blockquote> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token comment">//  DefaultEventLoop 使用</span>
<span class="token class-name">EventLoopGroup</span> defaultEventLoopGroups <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">EventLoop</span> defaultEventLoop <span class="token operator">=</span> defaultEventLoopGroups<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//submit就是我们要干的事。</span>
defaultEventLoop<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
    log<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="handler"><a href="#handler" class="header-anchor">#</a> Handler</h2> <h3 id="什么是-handler"><a href="#什么是-handler" class="header-anchor">#</a> 什么是 Handler</h3> <p>当建立连接之后，实际上后面要进行 IO 操作，IO 操作是由 Handler 来操作。Handler 是一组的，基于一种各司其职的思想，不论是客户端还是服务端，数据里路过来之后，我们经过一系列的数据处理，就可以进行后续业务的开发。</p> <p>一系列 Handler 基于 PipeLine 整合在一起，PipeLine 是它的管理者。这是一种典型的责任链的设计模式，把一个工作分成一个链条，对数据进行不同的加工。</p> <p>作为我们的 Handler 来讲是有方向的：读入数据的 Handler 和写出数据的 Handler<br>
读入数据的 Handler：ChannelInboundHandlerAdapter<br>
写出数据的 Handler：ChannelOutboundHandlerAdapter</p> <h3 id="handler-的使用"><a href="#handler-的使用" class="header-anchor">#</a> Handler 的使用</h3> <p>Handler 是由 EventLoopGroup 当中的线程执行的。<br>
Handler 的处理中，<code>object msg</code> 就是客户端传输过来的数据，只是这时候，接收到的还是在 ByteBuffer 中，Netty 中我们叫做 ByteBuf。</p> <h3 id="读数据多个-handler-之间如何进行数据传递"><a href="#读数据多个-handler-之间如何进行数据传递" class="header-anchor">#</a> 读数据多个 Handler 之间如何进行数据传递？</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">channelRead</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> s<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将一个 Handler 处理完的数据交给下一个 Handler</span>
</code></pre></div><p>上面的方法就是把一个 Handler 处理完的数据交给下一个 Handler，第一个参数是 Handler 整个上下文环境数据，第二个参数 msg 代表着要带给下一个 Handler 的数据，而下一个 Handler 是通过接口函数中的 <code>object msg</code> 接收的。</p> <p>当一个 Handler 处理完消息后，消息在处理链中以原始的数据类型进行传递。如果前一个 Handler 处理的是 ByteBuf，则下一个 Handler 接收到的仍然是 ByteBuf。这样的设计有助于高效处理数据和减少内存拷贝。但根据业务需求，可以进行类型转换，将数据转换为其他形式的消息对象，并将其传递给下一个 Handler。</p> <blockquote><p>最后一个 Handler 是不需要调用 super 的。</p></blockquote> <p>super.channelRead() 方法真正操作的是 <code>ctx.fireChannelRead(msg)</code> 方法，只有这个 ctx 才具有传递数据的能力，因为这个是上下文环境。</p> <p>多个 Handler 依次顺序执行，在 Netty 执行的时候默认会为我们添加两个 Handler，分别是 head 和 tail，即执行顺序是：<strong>head -&gt; handler1 -&gt; handler2 -&gt; ... -&gt; tail</strong></p> <h3 id="handler-和-childhandler"><a href="#handler-和-childhandler" class="header-anchor">#</a> Handler 和 ChildHandler</h3> <p>在Netty中，Handler 和 ChildHandler 是用于配置 ChannelPipeline 的两个方法，它们的区别在于作用范围和生效对象的不同。</p> <ul><li>Handler：
<ul><li>handler 方法用于配置 ServerBootstrap 或 Bootstrap 的 ChannelPipeline 中的处理器。</li> <li>handler 方法添加的处理器是针对服务端或客户端整体的，对于每个连接或 Channel 都会生效。</li> <li>通常用于配置全局共享的处理器，例如处理服务器启动事件、服务器关闭事件处理、连接的建立和关闭事件、心跳处理等。</li> <li>该方法一般在服务器启动前调用。</li></ul></li> <li>ChildHandler：
<ul><li>childHandler 方法用于配置 ServerBootstrap 的子 Channel（即接受客户端连接后创建的Channel）的 ChannelPipeline 中的处理器。</li> <li>childHandler 方法添加的处理器是针对每个连接的，对于每个子 Channel 都会生效。</li> <li>通常在 childHandler 方法中配置的处理器用于处理与客户端连接相关的业务逻辑，如协议解析、数据处理等。</li> <li>该方法一般在服务器启动后的 Channel 创建时调用。</li></ul></li></ul> <h3 id="什么叫接受客户端连接后创建的子-channel"><a href="#什么叫接受客户端连接后创建的子-channel" class="header-anchor">#</a> 什么叫接受客户端连接后创建的子 channel？</h3> <p>在 Netty 中，服务器在接受客户端连接时会为每个客户端连接创建一个子 Channel，这个子 Channel 代表了与客户端的具体连接，通过该通道可以进行数据的读取和写入。这个子 Channel 是由服务器的 ServerChannel 接受连接后创建的。每个子 Channel 都拥有自己的 ChannelPipeline 和事件处理器，可以根据具体业务需求配置相应的处理逻辑。</p> <p>在服务器端的编程模型中，主要有两个层次的通道：</p> <ol><li>服务器的 ServerChannel：负责监听端口、接受客户端连接，并创建子 Channel。服务器的 ServerChannel 通常是通过 ServerBootstrap 的 channel() 方法指定的。</li> <li>客户端的子 Channel：由服务器的 ServerChannel 接受连接后创建的子 Channel，用于与客户端进行实际的数据通信。每个子 Channel 都有自己的 ChannelPipeline 和处理器链。</li></ol> <p>通过使用子 Channel，服务器可以同时处理多个客户端的连接请求，每个连接都有独立的通道进行数据的读写和处理。</p> <h2 id="netty-中的异步设计"><a href="#netty-中的异步设计" class="header-anchor">#</a> Netty 中的异步设计</h2> <p>Netty 是异步的，很多操作都是异步的。所有涉及到网络和 IO 的相关操作都会进行异步处理。对于这些操作我们需要执行两种操作，要么主线程同步阻塞，要么辅助线程执行异步回调（异步监听，不阻塞主线程）。</p> <h3 id="异步和多线程的关系及区别"><a href="#异步和多线程的关系及区别" class="header-anchor">#</a> 异步和多线程的关系及区别</h3> <p>异步也是多线程编程，所谓的异步编程和我们的多线程编程在应用过程中有着一些区别。</p> <ul><li>多线程编程：JavaWeb 中多个客户端对应的后台线程是平等的关系。</li> <li>异步多线程：它有一个线程是主要的，除却主要的部分，有复杂的和耗时的操作交给另一个线程来做，这两个线程配合地去完成一系列的操作。而且往往这个主线程还需要这个辅助线程将结果交给它。</li></ul> <h2 id="参考博客"><a href="#参考博客" class="header-anchor">#</a> 参考博客</h2> <ul><li>https://blog.csdn.net/lic721/article/details/126842761</li> <li>https://blog.csdn.net/Facial_Mask/article/details/127589593</li> <li>https://blog.csdn.net/twt936457991/article/details/89854851</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java-note/Java/简易RPC框架项目/Socket网络通信.html" class="prev">
        Socket网络通信
      </a></span> <span class="next"><a href="/java-note/Java/简易RPC框架项目/项目网络传输模块细节.html">
        项目网络传输模块细节
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/java-note/assets/js/app.4802240e.js" defer></script><script src="/java-note/assets/js/2.834e1286.js" defer></script><script src="/java-note/assets/js/1.56911593.js" defer></script><script src="/java-note/assets/js/63.75fdcace.js" defer></script>
  </body>
</html>
