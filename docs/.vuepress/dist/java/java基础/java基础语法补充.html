<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java基础语法补充 | java</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/java-note/images/myfavicon.png">
    <meta name="description" content="java 学习笔记">
    
    <link rel="preload" href="/java-note/assets/css/0.styles.708fcbbf.css" as="style"><link rel="preload" href="/java-note/assets/js/app.4802240e.js" as="script"><link rel="preload" href="/java-note/assets/js/2.834e1286.js" as="script"><link rel="preload" href="/java-note/assets/js/1.56911593.js" as="script"><link rel="preload" href="/java-note/assets/js/33.e5f25c3c.js" as="script"><link rel="prefetch" href="/java-note/assets/js/10.7f863a77.js"><link rel="prefetch" href="/java-note/assets/js/11.6b66a110.js"><link rel="prefetch" href="/java-note/assets/js/12.8440333d.js"><link rel="prefetch" href="/java-note/assets/js/13.1f1fe7b4.js"><link rel="prefetch" href="/java-note/assets/js/14.65ef5a04.js"><link rel="prefetch" href="/java-note/assets/js/15.f60694df.js"><link rel="prefetch" href="/java-note/assets/js/16.efadbd73.js"><link rel="prefetch" href="/java-note/assets/js/17.d9390df8.js"><link rel="prefetch" href="/java-note/assets/js/18.2f93832a.js"><link rel="prefetch" href="/java-note/assets/js/19.e21d8298.js"><link rel="prefetch" href="/java-note/assets/js/20.c801663f.js"><link rel="prefetch" href="/java-note/assets/js/21.ed1b35e4.js"><link rel="prefetch" href="/java-note/assets/js/22.33b69923.js"><link rel="prefetch" href="/java-note/assets/js/23.d0cb6ea3.js"><link rel="prefetch" href="/java-note/assets/js/24.77c390b0.js"><link rel="prefetch" href="/java-note/assets/js/25.93636fbb.js"><link rel="prefetch" href="/java-note/assets/js/26.17ffe540.js"><link rel="prefetch" href="/java-note/assets/js/27.903242ff.js"><link rel="prefetch" href="/java-note/assets/js/28.dc5daf82.js"><link rel="prefetch" href="/java-note/assets/js/29.95e7dd6e.js"><link rel="prefetch" href="/java-note/assets/js/3.5c83221f.js"><link rel="prefetch" href="/java-note/assets/js/30.ab86d2f2.js"><link rel="prefetch" href="/java-note/assets/js/31.bb5e7344.js"><link rel="prefetch" href="/java-note/assets/js/32.a33b149c.js"><link rel="prefetch" href="/java-note/assets/js/34.30d8a274.js"><link rel="prefetch" href="/java-note/assets/js/35.5d8fa2f0.js"><link rel="prefetch" href="/java-note/assets/js/36.1e873df7.js"><link rel="prefetch" href="/java-note/assets/js/37.594daa95.js"><link rel="prefetch" href="/java-note/assets/js/38.bc0467b7.js"><link rel="prefetch" href="/java-note/assets/js/39.dd90bf94.js"><link rel="prefetch" href="/java-note/assets/js/4.f186242d.js"><link rel="prefetch" href="/java-note/assets/js/40.70522d96.js"><link rel="prefetch" href="/java-note/assets/js/41.1f09c6b9.js"><link rel="prefetch" href="/java-note/assets/js/42.49f51f5c.js"><link rel="prefetch" href="/java-note/assets/js/43.29326b6e.js"><link rel="prefetch" href="/java-note/assets/js/44.8408958a.js"><link rel="prefetch" href="/java-note/assets/js/45.a061f8ad.js"><link rel="prefetch" href="/java-note/assets/js/46.7b5df9fc.js"><link rel="prefetch" href="/java-note/assets/js/47.990d3a28.js"><link rel="prefetch" href="/java-note/assets/js/48.4ae8f2d5.js"><link rel="prefetch" href="/java-note/assets/js/49.880752cc.js"><link rel="prefetch" href="/java-note/assets/js/5.377eaaa7.js"><link rel="prefetch" href="/java-note/assets/js/50.a0ba8023.js"><link rel="prefetch" href="/java-note/assets/js/51.34976563.js"><link rel="prefetch" href="/java-note/assets/js/52.23629959.js"><link rel="prefetch" href="/java-note/assets/js/53.8ad3e7eb.js"><link rel="prefetch" href="/java-note/assets/js/54.018f6f49.js"><link rel="prefetch" href="/java-note/assets/js/55.f7b9ff66.js"><link rel="prefetch" href="/java-note/assets/js/56.c1a1091c.js"><link rel="prefetch" href="/java-note/assets/js/57.a314e87a.js"><link rel="prefetch" href="/java-note/assets/js/58.b3b40ad4.js"><link rel="prefetch" href="/java-note/assets/js/59.6ca124ae.js"><link rel="prefetch" href="/java-note/assets/js/6.d127c244.js"><link rel="prefetch" href="/java-note/assets/js/60.62927391.js"><link rel="prefetch" href="/java-note/assets/js/61.9f3ed6b5.js"><link rel="prefetch" href="/java-note/assets/js/62.186bc77d.js"><link rel="prefetch" href="/java-note/assets/js/63.75fdcace.js"><link rel="prefetch" href="/java-note/assets/js/64.e3d406b8.js"><link rel="prefetch" href="/java-note/assets/js/65.b6b92143.js"><link rel="prefetch" href="/java-note/assets/js/66.a832b085.js"><link rel="prefetch" href="/java-note/assets/js/67.a165eb09.js"><link rel="prefetch" href="/java-note/assets/js/68.b710e3a6.js"><link rel="prefetch" href="/java-note/assets/js/69.8d29ae2a.js"><link rel="prefetch" href="/java-note/assets/js/7.8472e88f.js"><link rel="prefetch" href="/java-note/assets/js/70.25a2b7b3.js"><link rel="prefetch" href="/java-note/assets/js/71.fe7a34d2.js"><link rel="prefetch" href="/java-note/assets/js/vendors~docsearch.3f62eedb.js">
    <link rel="stylesheet" href="/java-note/assets/css/0.styles.708fcbbf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/java-note/" class="home-link router-link-active"><!----> <span class="site-name">java</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-note/Java/Java基础/编程常识.html" class="sidebar-link">编程常识</a></li><li><a href="/java-note/Java/Java基础/Java基础语法补充.html" class="active sidebar-link">Java基础语法补充</a></li><li><a href="/java-note/Java/Java基础/字符串.html" class="sidebar-link">字符串</a></li><li><a href="/java-note/Java/Java基础/集合.html" class="sidebar-link">集合</a></li><li><a href="/java-note/Java/Java基础/Java内存分配.html" class="sidebar-link">Java内存分配</a></li><li><a href="/java-note/Java/Java基础/数据结构.html" class="sidebar-link">数据结构</a></li><li><a href="/java-note/Java/Java基础/Java并发编程.html" class="sidebar-link">Java并发编程</a></li><li><a href="/java-note/Java/Java基础/阻塞队列.html" class="sidebar-link">阻塞队列</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>校园信息交流平台项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>简易RPC框架项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>内功</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>知识点自测速记</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="header-anchor">#</a> 成员变量和局部变量的区别</h2> <div align="center"><img src="/java-note/assets/img/成员变量和局部变量的区别.ecdeff42.png" width="100%"></div> <h2 id="键盘录入"><a href="#键盘录入" class="header-anchor">#</a> 键盘录入</h2> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">//第一套体系：遇到空格、制表符、回车就停止接收，这些符号后面的数据就不会接收了</span>
<span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//接收整数</span>
<span class="token function">nextDouble</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//接收小数</span>
<span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//接收字符串 </span>

<span class="token comment">//第二套体系：遇到回车才停止</span>
<span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//接收字符串</span>
</code></pre></div><h2 id="static"><a href="#static" class="header-anchor">#</a> static</h2> <ul><li>注意事项：
<ul><li>静态方法只能访问静态变量和静态方法</li> <li>非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法</li> <li>静态方法中是没有this关键字</li></ul></li></ul> <h2 id="三种类"><a href="#三种类" class="header-anchor">#</a> 三种类</h2> <ul><li>JavaBean类： 用来描述一类事物的类。比如，Student,Teacher,Dog,Cat等</li> <li>测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口</li> <li>工具类：不是用来描述一类事物的，而是帮我们做一些事情的类。<br>
工具类构造时要：1.类名见名知义；2.私有化构造方法；3.方法定义为静态；</li></ul> <h2 id="继承"><a href="#继承" class="header-anchor">#</a> 继承</h2> <ol><li>Java只能单继承：一个类只能继承一个直接父类；</li> <li>Java不支持多继承、但是支持多层继承。</li> <li>Java中所有的类都直接或者间接继承于Object类。（即Object类是所有类的原始父类）</li> <li>子类只能访问父类中非私有的成员。</li> <li><strong>虚方法表中的成员方法可以被继承，不在表中的成员方法不能被继承</strong></li> <li>继承中成员变量访问特点：<strong>就近原则</strong><br>
先在局部位置找，本类成员位置找，父类成员位置找，逐级往上</li> <li>若出现了重名的成员变量：</li></ol> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从局部位置开始往上找</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从本类成员位置开始往上找</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">super</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//从父类成员位置开始往上找</span>
</code></pre></div><p>方法重写的本质:<br></p><div align="left"><img src="/java-note/assets/img/方法重写的本质.9485dcb8.png" width="100%"></div><p></p> <h2 id="代码块"><a href="#代码块" class="header-anchor">#</a> 代码块</h2> <ul><li>局部代码块(已淘汰)<br>
作用：提前结束变量的生命周期，节省空间</li> <li>构造代码块（不够灵活）
<ul><li>写在成员位置的代码块</li> <li>作用：可以把多个构造方法中重复的代码抽取出来</li> <li>执行时机：再创建本类对象的时候会先执行构造代码块再执行构造方法</li></ul></li> <li>静态代码块（重点掌握）
<ul><li>格式：static{}</li> <li>特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次</li> <li>作用：数据的初始化</li></ul></li></ul> <h2 id="多态"><a href="#多态" class="header-anchor">#</a> 多态</h2> <p>格式：<code>父类类型 变量名 = new 子类类型</code></p> <ul><li><p>调用成员变量时：<strong>编译看左边，运行看左边</strong><br>
编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。<br>
运行看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值。</p></li> <li><p>调用成员方法时：<strong>编译看左边，运行看右边</strong><br>
编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。
运行看右边：java运行代码的时候，实际上运行的是子类中的方法。</p></li> <li><p>能调用哪些方法，由引用类型决定，具体执行情况，由实际内存对象类型决定</p></li> <li><p>java执行方法时，会根据引用的类型得到相应的方法，如果不存在编译时会报错，真正执行时，会动态去匹配，如果真正的对象是子类的话，且此方法在子类中被覆盖的话，就会执行子类方法。<br>
java类型匹配时，如果不能匹配的话就做向上类型转换，转换为父类，直到能够匹配为止，若一直不能匹配在编译时会报错</p></li></ul> <h2 id="接口"><a href="#接口" class="header-anchor">#</a> 接口</h2> <ul><li><strong>JDK7以前</strong>：接口中只能定义抽象方法。</li> <li><strong>JDK8的新特性</strong>：接口中可以定义有方法体的方法。（默认方法、静态方法）</li> <li><strong>JDK9的新特性</strong>：接口中可以定义私有方法。</li></ul> <h3 id="jdk8以后接口中新增的默认方法"><a href="#jdk8以后接口中新增的默认方法" class="header-anchor">#</a> JDK8以后接口中新增的默认方法</h3> <ul><li><p>允许在接口中定义默认方法，需要使用关键字default修饰。<br>
作用：解决接口升级的问题</p></li> <li><p>接口中<strong>默认方法</strong>的定义格式：</p> <ul><li>格式：<code>public default 返回值类型 方法名（参数列表）{}</code></li> <li>范例：<code>public default void show() {}</code></li></ul></li> <li><p>接口中默认方法的注意事项：</p> <ul><li>默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字。</li> <li>public 可以省略，default 不能省略。</li> <li>如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写。</li></ul></li></ul> <h3 id="jdk8以后接口中新增的静态方法"><a href="#jdk8以后接口中新增的静态方法" class="header-anchor">#</a> JDK8以后接口中新增的静态方法</h3> <ul><li><p>允许在接口中定义静态方法，需要用 static 修饰</p></li> <li><p>接口中<strong>静态方法</strong>的定义格式：</p> <ul><li>格式：<code>public static 返回值类型 方法名（参数列表）</code></li> <li>范例：<code>public static void show(){}</code></li></ul></li> <li><p>接口中静态方法的注意事项：</p> <ul><li>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</li> <li>public 可以省略，static 不能省略</li></ul></li></ul> <h3 id="jdk9以后接口中新增的私有方法"><a href="#jdk9以后接口中新增的私有方法" class="header-anchor">#</a> JDK9以后接口中新增的私有方法</h3> <p><strong>此方法只为接口提供服务，不需要外类访问</strong></p> <ul><li>接口中私有方法的定义格式：
<ul><li>格式1：<code>private 返回值类型 方法名（参数列表）{}</code><br>
范例1：<code>private void show(){} //普通的私有方法，给默认方法服务的</code></li> <li>格式2：<code>private static 返回值类型 方法名 （参数列表）{}</code><br>
范例2：<code>private static void method(){} //静态的私有方法，给静态方法服务的</code></li></ul></li></ul> <h3 id="接口的应用"><a href="#接口的应用" class="header-anchor">#</a> 接口的应用</h3> <ul><li>接口代表规则，是行为的抽象。想要让哪个类拥有一个行为，就让这个类实现对应的接口就可以了。</li> <li>当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态。</li></ul> <h2 id="内部类"><a href="#内部类" class="header-anchor">#</a> 内部类</h2> <p>类的五大成员：属性、方法、构造方法、代码块、内部类<br>
内部类的访问特点：</p> <ul><li>内部类可以直接访问外部类的成员，包括私有</li> <li>外部类要访问内部类的成员，必须创建对象</li></ul> <h2 id="常用api"><a href="#常用api" class="header-anchor">#</a> 常用API</h2> <h3 id="system"><a href="#system" class="header-anchor">#</a> System</h3> <ul><li>也是一个工具类，提供了一些与系统相关的方法</li> <li>时间原点：1970年1月1日 0:0:0，我国在东八区，有8小时时差，因此原点为1970年1月1日 8:0:0</li> <li>1秒 = 1000 毫秒</li> <li>常见方法
<ul><li>exit：停止虚拟机</li> <li>currentTimeMillis：过去当前时间的毫秒值</li> <li>arraycopy：拷贝数组</li></ul></li></ul> <h3 id="runtime"><a href="#runtime" class="header-anchor">#</a> Runtime</h3> <p>表示当前虚拟机的运行环境，是一个类但不能直接建立对象，要用 getRuntime 获取.</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Runtime</span> <span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//当前系统的运行环境对象</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token keyword">int</span> status<span class="token punctuation">)</span>       <span class="token comment">//停止虚拟机</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">//获得CPU的线程数</span>
<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">maxMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">//JVM能从系统钟获取总内存大小（单位byte）</span>
<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">totalMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>          <span class="token comment">//JVM已经从系统中获取总内存大小（单位byte）</span>
<span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment">//JVM剩余内存大小（单位byte）</span>
<span class="token keyword">public</span> <span class="token class-name">Process</span> <span class="token function">exec</span><span class="token punctuation">(</span><span class="token class-name">String</span> command<span class="token punctuation">)</span><span class="token comment">//运行 cmd 命令</span>
</code></pre></div><h2 id="lambda表达式-jdk8后"><a href="#lambda表达式-jdk8后" class="header-anchor">#</a> Lambda表达式（JDK8后）</h2> <ul><li>函数式编程（Functional programming）是一种思想特点，忽略面向对象的复杂语法，强调做什么，而不是谁去做。Lambda表达式就是函数式思想的体现。</li> <li>面向对象：先找对象，让对象做事情</li> <li>注意点：
<ul><li>Lambda表达式可以用来简化匿名内部类的书写</li> <li>Lambda表达式只能简化函数式接口的匿名内部类的写法</li> <li>函数式接口：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@FunctionalInterface注解</li></ul></li> <li>Lambda的省略规则：
<ul><li>1.参数类型可以省略不写</li> <li>2.如果只有一个参数，参数类型可以省略，同时()也可以省略</li> <li>3.如果Lambda表达式的方法体只有一行，大括号，分号，return可以省略不写，需要同时省略。</li></ul></li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="泛型"><a href="#泛型" class="header-anchor">#</a> 泛型</h2> <p>泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。<br> <strong>泛型的格式</strong>：&lt;数据类型&gt;<br>
注意：泛型只能支持引用数据类型。<br>
使用泛型的原因：如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型，此时可以往集合中添加任意的数据类型。但带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。<br>
扩展知识点：Java中的泛型是伪泛型</p> <h3 id="泛型的好处"><a href="#泛型的好处" class="header-anchor">#</a> 泛型的好处</h3> <ul><li>统一数据类型</li> <li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来。</li></ul> <h3 id="泛型的细节"><a href="#泛型的细节" class="header-anchor">#</a> 泛型的细节</h3> <ul><li>泛型中不能写基本数据类型</li> <li>指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型</li> <li>如果不写泛型，类型默认是 <strong>Object</strong></li></ul> <h3 id="泛型类"><a href="#泛型类" class="header-anchor">#</a> 泛型类</h3> <p>如果一个类不确定类型，那么这个类就可以定义为泛型类，在类名后面定义泛型。</p> <h3 id="泛型方法"><a href="#泛型方法" class="header-anchor">#</a> 泛型方法</h3> <p>方法中形参类型不确定时，</p> <ul><li><ol><li>可以使用类名后面定义的泛型 <code>&lt;E&gt;</code></li></ol></li> <li><ol start="2"><li>在方法申明上定义自己的泛型</li></ol></li></ul> <div class="language-java extra-class"><pre class="language-java"><code>修饰符 <span class="token operator">&lt;</span>类型<span class="token operator">&gt;</span> 返回值类型 方法名<span class="token punctuation">(</span>类型 变量名<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">T</span> t<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token comment">//此处可以理解为变量，但是不是用来记录数据的，而是记录类型的，可以写成：T、E、K、V等</span>
</code></pre></div><h3 id="泛型接口"><a href="#泛型接口" class="header-anchor">#</a> 泛型接口</h3> <div class="language-java extra-class"><pre class="language-java"><code>修饰符 <span class="token keyword">interface</span> 接口名<span class="token operator">&lt;</span>类型<span class="token operator">&gt;</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span>
<span class="token punctuation">}</span>
</code></pre></div><p>泛型接口的两种使用方式：</p> <ol><li>实现类给出具体的类型</li> <li>实现类延续泛型，创建实现类对象时再确定类型</li></ol> <h3 id="泛型的继承和通配符"><a href="#泛型的继承和通配符" class="header-anchor">#</a> 泛型的继承和通配符</h3> <ul><li>泛型不具备继承性（不能通过多态传递子类对象），但是数据具备继承性（指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型）</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Animal</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">)</span><span class="token punctuation">{</span>
<span class="token punctuation">}</span><span class="token comment">//在调用method方法时只能是Animal类型，不能传递其子类，因为泛型不具备继承性</span>

<span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Ye</span><span class="token punctuation">&gt;</span></span> list1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Ye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//数据具备继承性</span>
list1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Fu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
list1<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Zi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>泛型的通配符：
<ul><li>? 也表示不确定的类型，可以进行类型范围的限定</li> <li>? extends E ：表示可以传递E或者E的所有的子类类型</li> <li>? super E ：表示可以传递E或者E所有的父类类型</li> <li>应用场景：如果在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以使用泛型的通配符。</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java-note/Java/Java基础/编程常识.html" class="prev">
        编程常识
      </a></span> <span class="next"><a href="/java-note/Java/Java基础/字符串.html">
        字符串
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/java-note/assets/js/app.4802240e.js" defer></script><script src="/java-note/assets/js/2.834e1286.js" defer></script><script src="/java-note/assets/js/1.56911593.js" defer></script><script src="/java-note/assets/js/33.e5f25c3c.js" defer></script>
  </body>
</html>
