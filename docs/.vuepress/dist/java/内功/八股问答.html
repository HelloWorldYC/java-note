<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>八股问答 | The Note of HelloWorldYC</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/Note/images/myfavicon.png">
    <meta name="description" content="Just playing around">
    
    <link rel="preload" href="/Note/assets/css/0.styles.44b4951f.css" as="style"><link rel="preload" href="/Note/assets/js/app.e371fa6c.js" as="script"><link rel="preload" href="/Note/assets/js/3.f13ea13a.js" as="script"><link rel="preload" href="/Note/assets/js/39.a3b7063b.js" as="script"><link rel="prefetch" href="/Note/assets/js/10.96adacd6.js"><link rel="prefetch" href="/Note/assets/js/11.3306ac33.js"><link rel="prefetch" href="/Note/assets/js/12.c6ec3b17.js"><link rel="prefetch" href="/Note/assets/js/13.6fd90bb8.js"><link rel="prefetch" href="/Note/assets/js/14.d2796fb6.js"><link rel="prefetch" href="/Note/assets/js/15.71825424.js"><link rel="prefetch" href="/Note/assets/js/16.69fe96f8.js"><link rel="prefetch" href="/Note/assets/js/17.6422db44.js"><link rel="prefetch" href="/Note/assets/js/18.bef0a5a8.js"><link rel="prefetch" href="/Note/assets/js/19.a6fadc0d.js"><link rel="prefetch" href="/Note/assets/js/2.96565d4b.js"><link rel="prefetch" href="/Note/assets/js/20.cc630c63.js"><link rel="prefetch" href="/Note/assets/js/21.84d0ce12.js"><link rel="prefetch" href="/Note/assets/js/22.2ae8180f.js"><link rel="prefetch" href="/Note/assets/js/23.1ee24d88.js"><link rel="prefetch" href="/Note/assets/js/24.5cc62c6d.js"><link rel="prefetch" href="/Note/assets/js/25.0266f62e.js"><link rel="prefetch" href="/Note/assets/js/26.79e8e570.js"><link rel="prefetch" href="/Note/assets/js/27.9cb81067.js"><link rel="prefetch" href="/Note/assets/js/28.bec84c38.js"><link rel="prefetch" href="/Note/assets/js/29.8411b6a0.js"><link rel="prefetch" href="/Note/assets/js/30.4bfbbfe1.js"><link rel="prefetch" href="/Note/assets/js/31.214d2c09.js"><link rel="prefetch" href="/Note/assets/js/32.7079239e.js"><link rel="prefetch" href="/Note/assets/js/33.d8cb1746.js"><link rel="prefetch" href="/Note/assets/js/34.ea58bbfc.js"><link rel="prefetch" href="/Note/assets/js/35.55034762.js"><link rel="prefetch" href="/Note/assets/js/36.46bd4ff5.js"><link rel="prefetch" href="/Note/assets/js/37.d1572595.js"><link rel="prefetch" href="/Note/assets/js/38.badb0163.js"><link rel="prefetch" href="/Note/assets/js/4.20687415.js"><link rel="prefetch" href="/Note/assets/js/40.74351d6a.js"><link rel="prefetch" href="/Note/assets/js/41.4efaa171.js"><link rel="prefetch" href="/Note/assets/js/42.0b3c1bcf.js"><link rel="prefetch" href="/Note/assets/js/43.84b7d7c1.js"><link rel="prefetch" href="/Note/assets/js/44.0b47ccbe.js"><link rel="prefetch" href="/Note/assets/js/45.955b6048.js"><link rel="prefetch" href="/Note/assets/js/46.2141e252.js"><link rel="prefetch" href="/Note/assets/js/47.645a9b50.js"><link rel="prefetch" href="/Note/assets/js/48.cde4ae1f.js"><link rel="prefetch" href="/Note/assets/js/49.e744e599.js"><link rel="prefetch" href="/Note/assets/js/5.0f586f5f.js"><link rel="prefetch" href="/Note/assets/js/50.65030a6a.js"><link rel="prefetch" href="/Note/assets/js/51.9452762b.js"><link rel="prefetch" href="/Note/assets/js/52.971525fc.js"><link rel="prefetch" href="/Note/assets/js/53.7608ac83.js"><link rel="prefetch" href="/Note/assets/js/54.00f97db1.js"><link rel="prefetch" href="/Note/assets/js/55.d0a27a03.js"><link rel="prefetch" href="/Note/assets/js/56.2af364aa.js"><link rel="prefetch" href="/Note/assets/js/57.1840d8bd.js"><link rel="prefetch" href="/Note/assets/js/58.b9b19a76.js"><link rel="prefetch" href="/Note/assets/js/59.51b325d0.js"><link rel="prefetch" href="/Note/assets/js/6.bd27afd1.js"><link rel="prefetch" href="/Note/assets/js/60.c0d12417.js"><link rel="prefetch" href="/Note/assets/js/61.d74bff09.js"><link rel="prefetch" href="/Note/assets/js/62.e8dd995e.js"><link rel="prefetch" href="/Note/assets/js/63.2040b659.js"><link rel="prefetch" href="/Note/assets/js/64.a49f7bc6.js"><link rel="prefetch" href="/Note/assets/js/65.aa4bc4a6.js"><link rel="prefetch" href="/Note/assets/js/66.ec3e1eb9.js"><link rel="prefetch" href="/Note/assets/js/7.ee931d89.js"><link rel="prefetch" href="/Note/assets/js/8.0118dbfd.js"><link rel="prefetch" href="/Note/assets/js/9.f1a20ae7.js">
    <link rel="stylesheet" href="/Note/assets/css/0.styles.44b4951f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/Note/" class="home-link router-link-active"><!----> <span class="site-name">The Note of HelloWorldYC</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>matlab</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/Note/matlab/常用函数.html" class="sidebar-link">常用函数</a></li><li><a href="/Note/matlab/语法.html" class="sidebar-link">语法</a></li><li><a href="/Note/matlab/matlab安装Matconvnet.html" class="sidebar-link">matlab安装Matconvnet</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>无人机项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数字图像处理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>深度学习</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>信源数估计</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="线程池有哪几种状态"><a href="#线程池有哪几种状态" class="header-anchor">#</a> 线程池有哪几种状态</h3> <ul><li>Running</li> <li>SHUTDOWN：不接受新的任务，但会继续执行队列中的任务</li> <li>STOP：直接停掉所有任务</li> <li>TIDYING：线程池在没有线程运行后进入该状态，并且会调用terminated()方法，该方法是空方法</li> <li>Terminated：terminated()方法执行完后进入该状态</li></ul> <h3 id="sychronized-和-reentrantlock-有哪些不同点"><a href="#sychronized-和-reentrantlock-有哪些不同点" class="header-anchor">#</a> Sychronized 和 ReentrantLock 有哪些不同点</h3> <h3 id="threadlocal有哪些应用场景-它底层是如何实现的"><a href="#threadlocal有哪些应用场景-它底层是如何实现的" class="header-anchor">#</a> ThreadLocal有哪些应用场景？它底层是如何实现的？</h3> <p>经典的应用场景就是连接管理，因为ThreadLocal通过ThreadLocalMap可以保存数据，在同一个线程所处理的不同方法之间传递，key是ThreadLocal对象，value是数据。但是可能会造成内存泄漏问题，因为线程池中的线程不会被垃圾回收，就会导致使用完的数据仍占用内存空间，随着线程的任务不断进行，保存的数据越来越多，就会导致内存泄漏。解决方法是使用完数据手动清理remove().</p> <h3 id="reentrantlock分为公平锁和非公平锁-那底层分别是如何实现的"><a href="#reentrantlock分为公平锁和非公平锁-那底层分别是如何实现的" class="header-anchor">#</a> ReentrantLock分为公平锁和非公平锁，那底层分别是如何实现的？</h3> <p>ReetrantLock默认是非公平锁，如果要实现公平锁，传入参数是true；</p> <ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁；</li> <li>非公平锁：当线程要获取锁时（调用lock方法），先通过CAS操作去抢锁，如果没抢到，会和公平锁一样进入到tryAcquire方法，在tryAcquire方法中，如果发现锁这个时候被释放(state == 0)，非公平锁会直接CAS抢锁，但是公平锁会判断等待队列是否有线程处于等待状态，如果有则不去抢锁，乖乖排到队列后面。非公平锁会有更好的性能，因为它的吞吐量比较大，但是会让获取锁的时间变得更加不确定，可能会导致在阻塞队列中的线程长期处于饥饿状态。</li></ul> <h3 id="sychronized的锁升级过程是怎样的"><a href="#sychronized的锁升级过程是怎样的" class="header-anchor">#</a> Sychronized的锁升级过程是怎样的</h3> <p>偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁<br>
轻量级锁底层通过自旋实现，并不会阻塞线程。</p> <h3 id="tomcat中为什么要使用自定义类加载器"><a href="#tomcat中为什么要使用自定义类加载器" class="header-anchor">#</a> Tomcat中为什么要使用自定义类加载器</h3> <p>用于隔离不同应用之间的相同全类名的类（待详细）
还可以利用自定义类加载器实现热加载功能</p> <h3 id="jdk、jre、jvm之间的区别"><a href="#jdk、jre、jvm之间的区别" class="header-anchor">#</a> JDK、JRE、JVM之间的区别</h3> <h3 id="hashcode-与equals-之间的关系"><a href="#hashcode-与equals-之间的关系" class="header-anchor">#</a> hashCode()与equals()之间的关系</h3> <p>在比较是否相同时，会先调用hashCode()方法得到哈希值，如果哈希值不同，就认为两个对象不相同，如果哈希值相同，再调用equals方法进行比较，如果这也相同，两个对象才相同。</p> <h3 id="string、stringbuilder、stringbuffer的区别"><a href="#string、stringbuilder、stringbuffer的区别" class="header-anchor">#</a> String、StringBuilder、StringBuffer的区别</h3> <p>String是常量，在字符串常量池中，StringBuilder和StringBuffer是可变的，但是StringBuffer是线程安全的，有很多方法都具备锁机制，而StringBuilder中方法是没有锁机制的，线程不一定安全。</p> <h3 id="泛型中extends和super的区别"><a href="#泛型中extends和super的区别" class="header-anchor">#</a> 泛型中extends和super的区别</h3> <p><code>&lt;? extends T&gt;</code> 表示包括T在内的任何T的子类<br> <code>&lt;? super T&gt;</code> 表示包括T在内的任何T的父类</p> <h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="header-anchor">#</a> 重载和重写的区别</h3> <p>重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、或者顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。（决定因素在参数）<br>
重写：发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符大于等于父类；如果父类方法访问修饰符为private则子类不能重写该方法。</p> <h3 id="list和set的区别"><a href="#list和set的区别" class="header-anchor">#</a> List和Set的区别</h3> <ul><li>List:有序，按对象进入的顺序保存对象，可重复，允许多个Null元素对象，可以使用Iterator取出所有元素，再逐一遍历，也可以使用get(int index)获取指定下标的元素</li> <li>Set：无序，不可重复，最多允许有一个Null元素对象，取元素时只能用Iterator接口取得所有元素，再逐一遍历各个元素</li></ul> <h3 id="arraylist和linkedlist的区别"><a href="#arraylist和linkedlist的区别" class="header-anchor">#</a> ArrayList和LinkedList的区别</h3> <p>ArrayList底层实现是数组，LinkedList底层实现是链表</p> <h3 id="谈谈concurrenthashmap的扩容机制"><a href="#谈谈concurrenthashmap的扩容机制" class="header-anchor">#</a> 谈谈ConcurrentHashMap的扩容机制</h3> <ul><li>jdk1.7时扩容是对每个segment里面的HashMap去扩容（有一个segment数组，数组每个元素是一个segment，保存着一个HashMap，里面的元素还可能挂载着链表），扩容的逻辑和HashMap的扩容逻辑类似，扩容的判断也是每个segment内部单独判断的，判断是否有超过阈值</li> <li>jdk1.8时concurrentHashMap只有一个Segment数组，所以扩容时扩的是segment数组（扩容时是多线程转移）
<ul><li>当某个线程进行put时，如果发现有ConcurrentHashMap正在进行扩容，那么该线程一起进行扩容</li> <li>如果某个线程put时，发现没有正在扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，超过了则进行扩容</li> <li>concurrentHashMap是支持多个线程同时进行扩容的</li> <li>扩容之前先生成一个新的数组</li> <li>在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作</li></ul></li></ul> <h3 id="jdk1-7到jdk1-8-hashmap发生了什么变化-底层"><a href="#jdk1-7到jdk1-8-hashmap发生了什么变化-底层" class="header-anchor">#</a> jdk1.7到jdk1.8 HashMap发生了什么变化（底层）</h3> <ul><li>1.7底层是数组+链表，1.8底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率</li> <li>1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8中插入key和value时需要判断链表元素个数，所以需要遍历链表统计链表元素个数，所以正好直接就使用了尾插法</li> <li>1.7中哈希算法比较复杂，存在各种右移与异或运算，1.8中进行了简化，因为复杂的哈希算法的目的就是为了提高散列性，来提供HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源</li></ul> <h3 id="hashmap的put方法"><a href="#hashmap的put方法" class="header-anchor">#</a> HashMap的Put方法</h3> <h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="header-anchor">#</a> 深拷贝和浅拷贝</h3> <h3 id="hashmap的扩容机制原理"><a href="#hashmap的扩容机制原理" class="header-anchor">#</a> HashMap的扩容机制原理</h3> <h3 id="copyonwritearraylist的底层原理是怎样的"><a href="#copyonwritearraylist的底层原理是怎样的" class="header-anchor">#</a> CopyOnWriteArrayList的底层原理是怎样的</h3> <p>（ArrayList是线程不安全的，所以需要一个线程安全的，所以诞生了CopyOnWriteArrayList）</p> <ul><li>首先CopyOnWriteArrayList内部也是用数组来实现的，在向CopyOnWriteArrayList添加元素时，会复制一个新的数组，写操作在新数组上进行，读操作在原数组上进行</li> <li>并且，写操作会加锁，防止出现并发写入丢失数据</li> <li>写操作结束后会把原数组指向新数组</li> <li>CopyOnWriteArrayList 允许在写操作时来读取数据，大大提高了读的性能，因此适合读多写少的应用场景，但会比较占内存，同时读到的数据不是实时最新的数据，所以不太适合实时性要求很高的场景</li></ul> <h3 id="什么是字节码-采用字节码的好处是什么"><a href="#什么是字节码-采用字节码的好处是什么" class="header-anchor">#</a> 什么是字节码？采用字节码的好处是什么？</h3> <h3 id="java中的异常体系是怎样的"><a href="#java中的异常体系是怎样的" class="header-anchor">#</a> Java中的异常体系是怎样的？</h3> <h3 id="factorybean-和-beanfactory-的区别"><a href="#factorybean-和-beanfactory-的区别" class="header-anchor">#</a> FactoryBean 和 BeanFactory 的区别？</h3> <ul><li>FactoryBean可简化Bean的实例化过程：
<ul><li>1.通过 FactoryBean 封装 Bean 的实例化过程</li> <li>2.将 FactoryBean 装配到 Spring 容器里</li> <li>3.将 FactoryBean 注入给其他的 Bean</li> <li>4.该 Bean 得到的是 FactoryBean 所管理的对象实例</li></ul></li></ul> <h3 id="java-为什么只有值传递"><a href="#java-为什么只有值传递" class="header-anchor">#</a> Java 为什么只有值传递？</h3> <p>值传递：方法接收的是实参值的拷贝，会创建副本。<br>
引用传递：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。<br>
Java 对引用类型参数<strong>不是采用引用传递</strong>，而是值传递，只是传入的是实参的地址，因此造成了方法内部对形参的修改会影响到实参。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/Note/assets/js/app.e371fa6c.js" defer></script><script src="/Note/assets/js/3.f13ea13a.js" defer></script><script src="/Note/assets/js/39.a3b7063b.js" defer></script>
  </body>
</html>
