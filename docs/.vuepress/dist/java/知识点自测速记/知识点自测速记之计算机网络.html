<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>知识点自测速记之计算机网络 | java</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/java-note/images/myfavicon.png">
    <meta name="description" content="java 学习笔记">
    
    <link rel="preload" href="/java-note/assets/css/0.styles.708fcbbf.css" as="style"><link rel="preload" href="/java-note/assets/js/app.4802240e.js" as="script"><link rel="preload" href="/java-note/assets/js/2.834e1286.js" as="script"><link rel="preload" href="/java-note/assets/js/1.56911593.js" as="script"><link rel="preload" href="/java-note/assets/js/61.9f3ed6b5.js" as="script"><link rel="prefetch" href="/java-note/assets/js/10.7f863a77.js"><link rel="prefetch" href="/java-note/assets/js/11.6b66a110.js"><link rel="prefetch" href="/java-note/assets/js/12.8440333d.js"><link rel="prefetch" href="/java-note/assets/js/13.1f1fe7b4.js"><link rel="prefetch" href="/java-note/assets/js/14.65ef5a04.js"><link rel="prefetch" href="/java-note/assets/js/15.f60694df.js"><link rel="prefetch" href="/java-note/assets/js/16.efadbd73.js"><link rel="prefetch" href="/java-note/assets/js/17.d9390df8.js"><link rel="prefetch" href="/java-note/assets/js/18.2f93832a.js"><link rel="prefetch" href="/java-note/assets/js/19.e21d8298.js"><link rel="prefetch" href="/java-note/assets/js/20.c801663f.js"><link rel="prefetch" href="/java-note/assets/js/21.ed1b35e4.js"><link rel="prefetch" href="/java-note/assets/js/22.33b69923.js"><link rel="prefetch" href="/java-note/assets/js/23.d0cb6ea3.js"><link rel="prefetch" href="/java-note/assets/js/24.77c390b0.js"><link rel="prefetch" href="/java-note/assets/js/25.93636fbb.js"><link rel="prefetch" href="/java-note/assets/js/26.17ffe540.js"><link rel="prefetch" href="/java-note/assets/js/27.903242ff.js"><link rel="prefetch" href="/java-note/assets/js/28.dc5daf82.js"><link rel="prefetch" href="/java-note/assets/js/29.95e7dd6e.js"><link rel="prefetch" href="/java-note/assets/js/3.5c83221f.js"><link rel="prefetch" href="/java-note/assets/js/30.ab86d2f2.js"><link rel="prefetch" href="/java-note/assets/js/31.bb5e7344.js"><link rel="prefetch" href="/java-note/assets/js/32.a33b149c.js"><link rel="prefetch" href="/java-note/assets/js/33.e5f25c3c.js"><link rel="prefetch" href="/java-note/assets/js/34.30d8a274.js"><link rel="prefetch" href="/java-note/assets/js/35.5d8fa2f0.js"><link rel="prefetch" href="/java-note/assets/js/36.1e873df7.js"><link rel="prefetch" href="/java-note/assets/js/37.594daa95.js"><link rel="prefetch" href="/java-note/assets/js/38.bc0467b7.js"><link rel="prefetch" href="/java-note/assets/js/39.dd90bf94.js"><link rel="prefetch" href="/java-note/assets/js/4.f186242d.js"><link rel="prefetch" href="/java-note/assets/js/40.70522d96.js"><link rel="prefetch" href="/java-note/assets/js/41.1f09c6b9.js"><link rel="prefetch" href="/java-note/assets/js/42.49f51f5c.js"><link rel="prefetch" href="/java-note/assets/js/43.29326b6e.js"><link rel="prefetch" href="/java-note/assets/js/44.8408958a.js"><link rel="prefetch" href="/java-note/assets/js/45.a061f8ad.js"><link rel="prefetch" href="/java-note/assets/js/46.7b5df9fc.js"><link rel="prefetch" href="/java-note/assets/js/47.990d3a28.js"><link rel="prefetch" href="/java-note/assets/js/48.4ae8f2d5.js"><link rel="prefetch" href="/java-note/assets/js/49.880752cc.js"><link rel="prefetch" href="/java-note/assets/js/5.377eaaa7.js"><link rel="prefetch" href="/java-note/assets/js/50.a0ba8023.js"><link rel="prefetch" href="/java-note/assets/js/51.34976563.js"><link rel="prefetch" href="/java-note/assets/js/52.23629959.js"><link rel="prefetch" href="/java-note/assets/js/53.8ad3e7eb.js"><link rel="prefetch" href="/java-note/assets/js/54.018f6f49.js"><link rel="prefetch" href="/java-note/assets/js/55.f7b9ff66.js"><link rel="prefetch" href="/java-note/assets/js/56.c1a1091c.js"><link rel="prefetch" href="/java-note/assets/js/57.a314e87a.js"><link rel="prefetch" href="/java-note/assets/js/58.b3b40ad4.js"><link rel="prefetch" href="/java-note/assets/js/59.6ca124ae.js"><link rel="prefetch" href="/java-note/assets/js/6.d127c244.js"><link rel="prefetch" href="/java-note/assets/js/60.62927391.js"><link rel="prefetch" href="/java-note/assets/js/62.186bc77d.js"><link rel="prefetch" href="/java-note/assets/js/63.75fdcace.js"><link rel="prefetch" href="/java-note/assets/js/64.e3d406b8.js"><link rel="prefetch" href="/java-note/assets/js/65.b6b92143.js"><link rel="prefetch" href="/java-note/assets/js/66.a832b085.js"><link rel="prefetch" href="/java-note/assets/js/67.a165eb09.js"><link rel="prefetch" href="/java-note/assets/js/68.b710e3a6.js"><link rel="prefetch" href="/java-note/assets/js/69.8d29ae2a.js"><link rel="prefetch" href="/java-note/assets/js/7.8472e88f.js"><link rel="prefetch" href="/java-note/assets/js/70.25a2b7b3.js"><link rel="prefetch" href="/java-note/assets/js/71.fe7a34d2.js"><link rel="prefetch" href="/java-note/assets/js/vendors~docsearch.3f62eedb.js">
    <link rel="stylesheet" href="/java-note/assets/css/0.styles.708fcbbf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/java-note/" class="home-link router-link-active"><!----> <span class="site-name">java</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java框架</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>校园信息交流平台项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>简易RPC框架项目</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>内功</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>知识点自测速记</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之Java基础.html" class="sidebar-link">知识点自测速记之Java基础</a></li><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之Java集合.html" class="sidebar-link">知识点自测速记之Java集合</a></li><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之Java并发编程.html" class="sidebar-link">知识点自测速记之Java并发编程</a></li><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之JVM.html" class="sidebar-link">知识点自测速记之JVM</a></li><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之计算机网络.html" class="active sidebar-link">知识点自测速记之计算机网络</a></li><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之操作系统.html" class="sidebar-link">知识点自测速记之操作系统</a></li><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之数据库基础.html" class="sidebar-link">知识点自测速记之数据库基础</a></li><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之MySQL.html" class="sidebar-link">知识点自测速记之MySQL</a></li><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之Redis.html" class="sidebar-link">知识点自测速记之Redis</a></li><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之Spring.html" class="sidebar-link">知识点自测速记之Spring</a></li><li><a href="/java-note/Java/知识点自测速记/知识点自测速记之Mybatis.html" class="sidebar-link">知识点自测速记之Mybatis</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><blockquote><p>这篇文章以问答的形式用于快速回顾知识点以及用于自测。<br>
因为知识点相当多，即使在看时能够理解记住，但过后也往往只是有印象，大概知道是什么东西，但想回答出来却总是卡壳，看了忘，忘了看。因此，这篇文章用于帮助速记回忆，自测时可以由这些点延伸。
注：参考的主要是 Guide 哥的网站内容以及 chatGPT。</p></blockquote> <h2 id="osi-七层模型"><a href="#osi-七层模型" class="header-anchor">#</a> OSI 七层模型</h2> <h4 id="osi-七层模型是哪七层-各自有什么功能"><a href="#osi-七层模型是哪七层-各自有什么功能" class="header-anchor">#</a> OSI 七层模型是哪七层？各自有什么功能？</h4> <ul><li><strong>应用层</strong>：为计算机用户提供服务</li> <li><strong>表示层</strong>：数据处理（编解码、加密解密、压缩解压缩）</li> <li><strong>会话层</strong>：管理（建立、维护、重连）应用程序之间的会话</li> <li><strong>传输层</strong>：为两台主机进程之间的通信提供通用的数据传输服务</li> <li><strong>网络层</strong>：路由和寻址（决定数据在网络的游走路径）</li> <li><strong>数据链路层</strong>：帧编码和误差纠正控制</li> <li><strong>物理层</strong>：透明地传送比特流</li></ul> <h4 id="tcp-ip-四层模型是哪四层"><a href="#tcp-ip-四层模型是哪四层" class="header-anchor">#</a> TCP/IP 四层模型是哪四层？</h4> <ul><li><strong>应用层</strong>：相当于 OSI 七层中的应用层、表示层、会话层的结合。主要提供了两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。应用层交互数据称为报文。</li> <li><strong>传输层</strong>：为两台终端设备的进程之间通信提供通用的数据传输服务。传输层数据称为 TCP 段或者 UDP 数据报。</li> <li><strong>网络层</strong>：路由和寻址，负责为分组交换网上的不同主机提供通信服务。网络层数据称为 IP 数据报，简称为数据报。</li> <li><strong>网络接口层</strong>：相当于 OSI 七层中的数据链路层、物理层的结合。</li></ul> <h4 id="各层对应的有哪些常见的协议"><a href="#各层对应的有哪些常见的协议" class="header-anchor">#</a> 各层对应的有哪些常见的协议？</h4> <ul><li>应用层：HTTP、HTTPS、SMTP、POP3/IMAP、FTP、Telnet、SSH、RTP、DNS</li> <li>传输层：TCP、UDP</li> <li>网络层：IP、ARP、ICMP（控制报文协议）、NAT（网络地址转换协议）、OSPF（开放式最短路径优先）、RIP（路由信息协议）、BGP（边界网关协议）</li> <li>网络接口层：差错检测技术、多路访问协议（信道复用技术）、CSMA/CD 协议</li></ul> <h4 id="为什么要进行网络分层"><a href="#为什么要进行网络分层" class="header-anchor">#</a> 为什么要进行网络分层？</h4> <ul><li>各层之间相互独立，每一层只专注做一类事情</li> <li>提高了整体灵活性，每一层可以使用最合适的技术实现</li> <li>大问题化小，使复杂的问题简单化</li></ul> <h2 id="tcp-和-udp"><a href="#tcp-和-udp" class="header-anchor">#</a> TCP 和 UDP</h2> <h4 id="tcp-和-udp-的区别"><a href="#tcp-和-udp-的区别" class="header-anchor">#</a> TCP 和 UDP 的区别？</h4> <ol><li><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li> <li><strong>是否是可靠传输</strong>：TCP 是可靠传输，而 UDP 不是可靠传输。TCP 除了三握四挥之外，在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li> <li><strong>是否有状态</strong>：TCP 是有状态的，它会去记录自己发送消息的状态比如是发送了、是否接收了等等。而 UDP 则无状态，简单说就是不管发出去之后的事情。</li> <li><strong>传输效率</strong>：由于 TCP 进行传输时多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li> <li><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</li> <li><strong>首部开销</strong>：TCP 首部开销是 20~60 字节，UDP 首部开销是 8 字节。</li> <li><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多。</li></ol> <h4 id="什么时候选择-tcp-什么时候选择-udp"><a href="#什么时候选择-tcp-什么时候选择-udp" class="header-anchor">#</a> 什么时候选择 TCP？什么时候选择 UDP？</h4> <ul><li><strong>UDP 一般用于即时通信</strong>，比如：语音、视频、直播等。</li> <li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，如文件传输、发送和接收邮件、远程登录等。</li></ul> <h4 id="http-是基于-tcp-还是基于-udp"><a href="#http-是基于-tcp-还是基于-udp" class="header-anchor">#</a> HTTP 是基于 TCP 还是基于 UDP？</h4> <p>HTTP3.0 之前是基于 TCP 协议的，而 HTTP3.0 改用基于 UDP 的 QUIC 协议。</p> <h4 id="使用-tcp-的协议有哪些-使用-udp-的协议有哪些"><a href="#使用-tcp-的协议有哪些-使用-udp-的协议有哪些" class="header-anchor">#</a> 使用 TCP 的协议有哪些？使用 UDP 的协议有哪些？</h4> <ul><li>运行在 <strong>TCP</strong> 之上的协议：HTTP、HTTPS、FTP、SMTP、POP3/IMAP、TelNet、SSH。</li> <li>运行在 <strong>UDP</strong> 之上的协议：DHCP 协议（动态主机配置协议、动态配置 IP 地址）、DNS 协议（支持 TCP 和 UDP）。</li></ul> <h4 id="tcp-的三次握手-过程中的状态"><a href="#tcp-的三次握手-过程中的状态" class="header-anchor">#</a> TCP 的三次握手？过程中的状态？</h4> <ul><li><strong>一次握手</strong>：客户端发送带有 <code>SYN（SEQ=x）</code> 标志的数据包给服务端，然后客户端进入 <strong><code>SYN_SEND</code></strong> 状态，等待服务器的确认。</li> <li><strong>二次握手</strong>：服务端发送带有 <code>SYN+ACK（SEQ=y，ACK=x+1）</code> 标志的数据包给客户端，然后服务端进入 <strong><code>SYN_RECV</code></strong> 状态。</li> <li><strong>三次握手</strong>：客户端发送带有 <code>ACK（ACK=y+1）</code> 标志的数据包给服务端，然后客户端和服务端都进入 <strong><code>ESTABLISHED</code></strong> 状态，完成三次握手。</li></ul> <h4 id="第二次握手传回了-ack-为什么还要传回-syn"><a href="#第二次握手传回了-ack-为什么还要传回-syn" class="header-anchor">#</a> 第二次握手传回了 ACK，为什么还要传回 SYN？</h4> <p>服务端传回发送端所发送的 <code>ACK</code> 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 <code>SYN</code> 则是为了建立并确认从服务端到客户端的通信。</p> <h4 id="tcp-的四次挥手-过程中的状态"><a href="#tcp-的四次挥手-过程中的状态" class="header-anchor">#</a> TCP 的四次挥手？过程中的状态？</h4> <ul><li><strong>一次挥手</strong>：客户端发送一个 <code>FIN（SEQ=x）</code> 标志的数据包到服务端，然后客户端进入 <strong><code>FIN-WAIT-1</code></strong> 状态。</li> <li><strong>二次挥手</strong>：服务器收到这个 <code>FIN（SEQ=x）</code> 标志的数据包后，它发送一个 <strong><code>ACK（ACK=x+1）</code></strong> 标志的数据包到客户端。然后服务端进入 <strong><code>CLOSED-WAIT</code></strong> 状态，客户端进入 <strong><code>FIN-WAIT-2</code></strong> 状态。</li> <li><strong>三次挥手</strong>：服务端发送一个 <code>FIN（SEQ=y）</code> 标志的数据包到客户端，然后服务端进入 <strong><code>LAST-ACK</code></strong> 状态。</li> <li><strong>四次挥手</strong>：客户端发送 <code>ACK（ACK=y+1）</code> 标志的数据包到服务端，然后客户端进入 <strong><code>TIME-WAIT</code></strong> 状态。服务端在收到 <code>ACK</code> 标志的数据包后进入 <strong><code>CLOSED</code></strong> 状态。此时如果客户端等待 <code>2MSL</code> 后依然没有收到回复，就证明服务端已经正常关闭，随后客户端也可以关闭连接了。</li></ul> <p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据。</strong></p> <h4 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="header-anchor">#</a> 为什么要四次挥手？</h4> <p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p> <p>只有经过了四次挥手才能保证服务端和客户端都没有信息要发送了。</p> <ul><li>第一次挥手，表明客户端没有数据要传输了，请求关闭连接。</li> <li>第二次挥手，表明服务端收到了客户端的关闭请求，但服务端可能还有数据要传输给客户端，所以不能和第三次挥手合并。</li> <li>第三次挥手，表明服务端没有数据要传输了，服务端也请求关闭连接，但服务端发送请求后就关闭了。</li> <li>第四次挥手，表明客户端收到服务端的关闭请求，发送确认请求后等待 <code>2MSL</code> 后仍没有应答，说明服务端关闭了，那么客户端也可以关闭了。</li></ul> <h4 id="为什么不能把服务端的-ack-和-fin-合并起来-变成了三次挥手"><a href="#为什么不能把服务端的-ack-和-fin-合并起来-变成了三次挥手" class="header-anchor">#</a> 为什么不能把服务端的 ACK 和 FIN 合并起来，变成了三次挥手？</h4> <p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 <code>ACK</code>，表示接收到了断开连接的请求。等到数据发完之后再发 <code>FIN</code>，断开服务器到客户端的数据传送。</p> <h4 id="如果第二次挥手-ack-没有送达客户端会怎么样"><a href="#如果第二次挥手-ack-没有送达客户端会怎么样" class="header-anchor">#</a> 如果第二次挥手 ACK 没有送达客户端会怎么样？</h4> <p>客户端没有收到 <code>ACK</code> 确认，会重新发送 <code>FIN</code> 请求。</p> <h4 id="为什么第四次挥手客户端要等待-2msl-时间后才进入-closed-状态"><a href="#为什么第四次挥手客户端要等待-2msl-时间后才进入-closed-状态" class="header-anchor">#</a> 为什么第四次挥手客户端要等待 2MSL 时间后才进入 CLOSED 状态？</h4> <p>第四次挥手时，客户端发送给服务器的 <code>ACK</code> 有可能丢失，如果服务端因为某些原因而没有收到 <code>ACK</code> 的话，服务端就会重发 <code>FIN</code>，如果客户端在 <code>2*MSL</code> 的时间内收到了 <code>FIN</code>，就会重新发送 <code>ACK</code> 并再次等待 <code>2MSL</code>，防止 Server 没有收到 <code>ACK</code> 而不断重发 <code>FIN</code>。</p> <h4 id="tcp-怎么保证传输的可靠性"><a href="#tcp-怎么保证传输的可靠性" class="header-anchor">#</a> TCP 怎么保证传输的可靠性？</h4> <ol><li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li> <li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li> <li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li> <li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。</li> <li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li> <li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li></ol> <h4 id="tcp-如何实现流量控制"><a href="#tcp-如何实现流量控制" class="header-anchor">#</a> TCP 如何实现流量控制？</h4> <p>TCP 利用 <strong>滑动窗口</strong> 实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p> <p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP 传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同。接收窗口的大小是根据接收端处理数据的速度动态调整的。</p> <h4 id="tcp-的拥塞控制是怎么实现的"><a href="#tcp-的拥塞控制是怎么实现的" class="header-anchor">#</a> TCP 的拥塞控制是怎么实现的？</h4> <p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。</p> <p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p> <p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong>、 <strong>拥塞避免</strong>、<strong>快重传</strong> 和 <strong>快恢复</strong>。</p> <ul><li><strong>慢开始</strong>：当主机开始发送数据时，先探测一下，由小到大逐渐增大拥塞窗口。拥塞窗口初始值为 1，每经过一个传播伦茨，值加倍。</li> <li><strong>拥塞避免</strong>：让拥塞窗口缓慢增大，即每经过一个往返时间 RTT 就把拥塞窗口加 1。</li> <li><strong>快重传和快恢复</strong>： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul> <h4 id="什么是-arq-协议-有哪几种"><a href="#什么是-arq-协议-有哪几种" class="header-anchor">#</a> 什么是 ARQ 协议？有哪几种？</h4> <p>ARQ，即自动重传请求，是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间内没有收到确认信息（ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p> <p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p> <ul><li>停止等待 ARQ 协议：每发完一个分组就停止发送，等待对方确认。如果过了一段时间后，还是没有收到确认，说明没有发送成功，需要重新发送，直到收到确认再发送下一个分组。在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</li> <li>连续 ARQ 协议：连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</li></ul> <h2 id="http"><a href="#http" class="header-anchor">#</a> HTTP</h2> <h4 id="从输入-url-到页面展示发生了什么"><a href="#从输入-url-到页面展示发生了什么" class="header-anchor">#</a> 从输入 URL 到页面展示发生了什么？</h4> <ol><li>DNS 解析，浏览器通过 DNS 协议查找域名的 IP 地址。</li> <li>浏览器向服务器发起 TCP 连接。</li> <li>连接建立后，浏览器向服务器发送 HTTP 请求。</li> <li>服务器接收到请求后进行处理，并返回 HTTP 响应。</li> <li>浏览器解析响应数据并渲染页面。</li> <li>浏览器断开与服务器的 TCP 连接。</li></ol> <h4 id="http-状态码有哪些"><a href="#http-状态码有哪些" class="header-anchor">#</a> HTTP 状态码有哪些？</h4> <ul><li>1XX：信息性状态码，接收的请求正在处理。</li> <li>2XX：成功状态码，请求正常处理完毕。</li> <li>3XX：重定向状态码，需要进行附加操作以完成请求。</li> <li>4XX：客户端错误状态码。</li> <li>5XX：服务器错误状态码，服务器处理请求出错。504 是网关超时。</li></ul> <h4 id="http-和-https-有什么区别"><a href="#http-和-https-有什么区别" class="header-anchor">#</a> HTTP 和 HTTPS 有什么区别？</h4> <ul><li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li> <li><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li> <li><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，HTTPS 在此基础上还添加了 SSL/TLS 协议。HTTPS 传输内容都经过了对称加密（密钥长度通常是 40 比特或 128 比特），但对称加密的密钥用服务器方的证书进行了非对称加密。所以，HTTPS 比 HTTP 安全性高，但耗费更多的服务器资源。</li> <li><strong>SEO （搜索引擎优化）</strong>：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为安全性更好。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</li></ul> <h4 id="http-协议通信过程"><a href="#http-协议通信过程" class="header-anchor">#</a> HTTP 协议通信过程？</h4> <p>HTTP 是应用层协议，它以 TCP 作为底层协议，默认端口是 80。通信过程如下：</p> <ol><li>服务器在 80 端口等待客户端的连接。</li> <li>浏览器发起到服务器的 TCP 连接（创建 Socket 套接字）。</li> <li>服务器接收来自浏览器的 TCP 连接。</li> <li>三次握手后建立了 TCP 连接，浏览器与服务器交换 HTTP 消息。</li> <li>关闭 TCP 连接。</li></ol> <h4 id="http-有什么优点-https-协议有什么优点"><a href="#http-有什么优点-https-协议有什么优点" class="header-anchor">#</a> HTTP 有什么优点？HTTPS 协议有什么优点？</h4> <ul><li>HTTP 协议优点：扩展性强、速度快、跨平台支持性好。</li> <li>HTTPS 协议优点：保密性好、信任度高。</li></ul> <h4 id="ssl-和-tls-的区别"><a href="#ssl-和-tls-的区别" class="header-anchor">#</a> SSL 和 TLS 的区别？</h4> <p>没有太大的区别，SSL 是前面的版本，TLS 是后面的版本，SSL3.0 被命名为 TLS1.0。</p> <h4 id="ssl-tls-的工作原理"><a href="#ssl-tls-的工作原理" class="header-anchor">#</a> SSL/TLS 的工作原理？</h4> <p>SSL/TLS 的核心要素是非对称加密。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。</p> <p>非对称加密的公钥和私钥依赖于单向陷门函数。单向陷门函数是一个较弱的单向函数，已知单向陷门函数 f，陷门 h，给定任意一个输入 x,易计算出输出 y=f(x;h)，而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p> <p>非对称加密的计算代价较高，效率太低，在实际通信过程中，对消息的加密使用的是对称加密，而非对称加密则是用来获取对称加密的密钥。</p> <h4 id="只用公钥和私钥做非对称加密会有什么安全隐患"><a href="#只用公钥和私钥做非对称加密会有什么安全隐患" class="header-anchor">#</a> 只用公钥和私钥做非对称加密会有什么安全隐患？</h4> <p>可能会有第三方做了一个伪装，窃取了信息。相对客户端它伪装成了服务端，发送给客户端它自己的公钥。相对服务端它伪装成了客户端，破解了客户端的信息发送给了真实服务端。</p> <p>为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的电子签名。</p> <p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p> <h4 id="为什么第三方机构-ca-能够被信赖"><a href="#为什么第三方机构-ca-能够被信赖" class="header-anchor">#</a> 为什么第三方机构 CA 能够被信赖？</h4> <p>主要是靠 <strong>数字签名技术</strong>。数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p> <ol><li>CA 知道服务器的公钥，对证书采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</li> <li>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</li> <li>客户端对证书数据（包含服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</li></ol> <h4 id="http-1-0-和-http-1-1-有什么区别"><a href="#http-1-0-和-http-1-1-有什么区别" class="header-anchor">#</a> HTTP/1.0 和 HTTP/1.1 有什么区别？</h4> <ul><li><strong>连接方式</strong>：HTTP1.0 为短连接，HTTP1.1 支持长连接。</li> <li><strong>状态响应码</strong>：HTTP1.1 新加入了大量的状态码，光是错误响应状态码就新增了24种。</li> <li><strong>缓存机制</strong>：在 HTTP1.0 中主要使用 Header 里的 If-Modified-Since，Expires 来作为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since，If-Match，If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li> <li><strong>带宽</strong>：HTTP1.0 中存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象传送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头中引入了 range 头部，允许只请求资源的某个部分，即返回码是 206（Partial Content）。</li> <li><strong>Host 头处理</strong>：HTTP1.1 引入了 Host 头字段，允许在同一IP地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP1.0 没有 HOST 头字段，无法实现虚拟主机。</li></ul> <h4 id="http-1-1-和-http-2-0-区别"><a href="#http-1-1-和-http-2-0-区别" class="header-anchor">#</a> HTTP/1.1 和 HTTP/2.0 区别？</h4> <ul><li><strong>多路复用</strong>：HTTP2.0 在同一连接上可以同时传输多个请求和响应，互不干扰。HTTP1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有6-8个TCP连接限制。这使得 HTTP2.0 在处理多个请求时效率更高，减少了网络延迟和提高了性能。</li> <li><strong>二进制帧</strong>：HTTP2.0 使用了二进制帧进行数据传输，而 HTTP1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</li> <li><strong>头部压缩</strong>：HTTP1.1 支持 <code>Body</code> 压缩，<code>Header</code> 不支持压缩。HTTP2.0 支持对 <code>Header</code> 压缩，使用了专门为 <code>Header</code> 压缩而设计的 HPACK 算法，减少了网络开销。</li> <li><strong>服务器推送</strong>：HTTP2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP1.1 需要客户端自己发送请求来获取相关资源。</li></ul> <h4 id="http-2-0-和-http-3-0-有什么区别"><a href="#http-2-0-和-http-3-0-有什么区别" class="header-anchor">#</a> HTTP/2.0 和 HTTP/3.0 有什么区别？</h4> <ul><li><strong>传输协议</strong>：HTTP2.0 是基于 TCP 协议实现的，HTTP3.0 新增了 QUIC 协议来实现可靠的传输，提供了与 SSL/TLS 相当的安全性，具有较低的连接和传输延迟。QUIC 协议是基于 UDP 的，在 UDP 基础上新增了很多功能比如加密，重传等。</li> <li><strong>连接建立</strong>：HTTP2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0 个或 1 个 RTT。这意味着 QUIC 在最佳情况下不需要任何额外往返时间就可以建立新连接。</li> <li><strong>队头阻塞</strong>：HTTP2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其他数据流不受影响（本质上是多路复用+轮询）。</li> <li><strong>错误恢复</strong>：HTTP3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP2.0 则需要依赖于 TCP 的错误恢复机制。</li> <li><strong>安全性</strong>：HTTP2.0 和 HTTP3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP2.0 使用 TLS 协议加密，而 HTTP3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</li></ul> <h4 id="http-是不保存用户状态的协议-怎么保存用户状态"><a href="#http-是不保存用户状态的协议-怎么保存用户状态" class="header-anchor">#</a> HTTP 是不保存用户状态的协议，怎么保存用户状态？</h4> <p>Session 机制的存在就是为了解决这个问题的，Session 的主要作用就是通过服务端记录用户的状态。<br>
在服务端保存 Session 的方法很多，最常用的就是内存和数据库（比如使用 Redis）。</p> <h4 id="如何实现-session-跟踪呢"><a href="#如何实现-session-跟踪呢" class="header-anchor">#</a> 如何实现 Session 跟踪呢？</h4> <p>大部分情况下，我们都是通过 Cookie 中附加一个 Session ID 方式来跟踪。<br>
如果 Cookie 被禁用，则可以利用 URL 重写把 Session ID 直接附加在 URL 路径后面。</p> <h4 id="cookie-和-session-有什么区别"><a href="#cookie-和-session-有什么区别" class="header-anchor">#</a> Cookie 和 Session 有什么区别？</h4> <p>Cookie 和 Session 都是用于在 Web 应用程序中管理用户状态和跟踪用户会话的机制，但它们有一些关键的区别：</p> <ul><li><strong>存储位置：</strong>：Cookie 数据存储在客户端（浏览器端），Session 数据存储在服务器端。</li> <li><strong>存储内容：</strong>：Cookie 通常包含有关用户的一些信息，例如用户的标识符、首选语言或其他状态信息。它的大小通常受到浏览器的限制。Session存储可以包含更丰富和复杂的数据，因为它存储在服务器上，不受客户端存储容量的限制。通常，Session存储的是与用户会话相关的数据，如用户的登录状态、购物车内容等。</li> <li><strong>生命周期：</strong>：Cookie 可以设置具有特定过期时间的持久性 Cookie，也可以创建会话 Cookie，它们在用户关闭浏览器时将被删除。持久性 Cookie 可以存储更长时间。Session 数据通常在用户关闭浏览器或一定时间（会话过期时间）后失效。Session 的生命周期通常由服务器管理，并且可以在用户的活动期间保持活动状态。</li> <li><strong>安全性：</strong>：Cookie是存储在用户浏览器中的，因此可能受到一些安全风险，如跨站脚本攻击（XSS）和跨站请求伪造（CSRF）。Session 数据存储在服务器上，相对较安全，但仍然需要注意一些攻击，如会话劫持。</li> <li><strong>传递方式：</strong>：Cookie 通过 HTTP 头部在客户端和服务器之间传递。而 Session 数据本身存储在服务器上，通过 Cookie 存储 Session ID。</li></ul> <h4 id="url-和-uri-的区别"><a href="#url-和-uri-的区别" class="header-anchor">#</a> URL 和 URI 的区别？</h4> <ul><li>URI，即 Uniform Resource Identifier，是统一资源标志符，可以唯一标识一个资源。</li> <li>URL，即 Uniform Resource Locator，是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，不仅可以唯一标识资源，而且提供了定位该资源的信息。</li></ul> <h4 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="header-anchor">#</a> GET 和 POST 的区别？</h4> <ul><li><strong>语义</strong>：这是两者的主要区别，GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。</li> <li><strong>幂等</strong>：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li> <li><strong>格式</strong>：GET 请求的参数通常放在 URL 中，形成查询字符串，而 POST 请求的参数通常放在请求体中，可以有多种编码格式。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的请求体则没有明确的限制。不过 GET 请求也可以用请求体传输数据，只是并不推荐这样做。</li> <li><strong>缓存</strong>：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它不是幂等的，可能会影响资源的状态，每次执行可能需要实时的响应。</li> <li><strong>安全性</strong>：如果使用 HTTP 协议，则两者都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄漏敏感数据，因为 GET 请求的参数通常放在 URL 中。</li></ul> <h2 id="arp-协议"><a href="#arp-协议" class="header-anchor">#</a> ARP 协议</h2> <h4 id="什么是-mac-地址"><a href="#什么是-mac-地址" class="header-anchor">#</a> 什么是 MAC 地址？</h4> <p>MAC 地址的全程是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。一切网络设备都由 MAC 地址唯一标识。MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p> <h4 id="arp-协议解决了哪些问题"><a href="#arp-协议解决了哪些问题" class="header-anchor">#</a> ARP 协议解决了哪些问题？</h4> <p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，<strong>ARP 协议解决了 IP 地址转 MAC 地址的一些问题</strong>。</p> <h4 id="mac-地址的长度是多少-是怎么分配-mac-地址的"><a href="#mac-地址的长度是多少-是怎么分配-mac-地址的" class="header-anchor">#</a> MAC 地址的长度是多少？是怎么分配 MAC 地址的？</h4> <p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是<strong>前 24 比特由 IEEE 统一管理</strong>，保证不会重复。而<strong>后 24 比特，由各家生产商自己管理</strong>，同样保证生产的两块网卡的 MAC 地址不会重复。</p> <p>MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p> <h4 id="arp-协议的工作原理"><a href="#arp-协议的工作原理" class="header-anchor">#</a> ARP 协议的工作原理？</h4> <p><strong>ARP 表、广播问询、单播响应</strong>。</p> <p><strong>ARP 表</strong> 记录了网络设备的 IP 地址到 MAC 地址映射关系，该映射关系以 <code>&lt;IP，MAC，TTL&gt;</code> 三元组的形式存储。其中，<code>TTL</code> 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。</p> <h4 id="有哪两种情况-分别是怎么工作的"><a href="#有哪两种情况-分别是怎么工作的" class="header-anchor">#</a> 有哪两种情况？分别是怎么工作的？</h4> <p>同一局域网中的 MAC 寻址 和 从一个局域网到另一个局域网中的网络设备寻址。</p> <p><strong>同一局域网中的 MAC 寻址</strong>：</p> <ol><li>主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。</li> <li>主机 A 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效，丢弃之。</li> <li>主机 B 收到了查询分组之后，验证是对自己的问询，主机 B 先提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录，接着构造一个 ARP 响应分组发送给主机 A。</li> <li>主机 A 终将收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，构造映射信息，加入到自己的 ARP 表中。</li></ol> <p><strong>从一个局域网到另一个局域网中的网络设备寻址</strong>：<br>
其实与同一局域网中的 MAC 寻址大致相同，只是多了中间两步，先找到目标主机对应的路由器在源子网下连接的接口的 MAC 地址，再通过这个接口转发出去到目标主机对应的路由器，由此将 IP 数据包从本子网转发到了目标主机所在子网。</p> <h4 id="arp-协议工作特点是什么"><a href="#arp-协议工作特点是什么" class="header-anchor">#</a> ARP 协议工作特点是什么？</h4> <p>广播问询、单播响应。</p> <h2 id="应用层常见协议"><a href="#应用层常见协议" class="header-anchor">#</a> 应用层常见协议</h2> <h4 id="smtp-协议的电子邮件发送过程"><a href="#smtp-协议的电子邮件发送过程" class="header-anchor">#</a> SMTP 协议的电子邮件发送过程？</h4> <p>假设邮箱1是 &quot;dabai@cszhinan.com&quot;，要向 &quot;xiaoma@qq.com&quot; 发送邮件，则发送过程如下：</p> <ul><li>通过 <strong>SMTP</strong> 协议，将写好的邮件交给 163邮箱服务器（相当于邮局）。</li> <li>163邮箱服务器发现接收的邮箱是 qq 邮箱，就是用 <strong>SMTP</strong> 协议将邮件转发到 qq 邮箱服务器（相当于邮局）。</li> <li>qq 邮箱服务器接收邮件之后通知邮箱为 &quot;xiaoma@qq.com&quot; 的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li></ul> <h4 id="smtp-协议怎么判断邮箱是真的存在"><a href="#smtp-协议怎么判断邮箱是真的存在" class="header-anchor">#</a> SMTP 协议怎么判断邮箱是真的存在？</h4> <ol><li>查找邮箱域名对应的 SMTP 服务器地址</li> <li>尝试与服务器建立连接</li> <li>连接成功后尝试向需要验证的邮箱发送邮件</li> <li>根据返回结果判定邮箱地址的真实性</li></ol> <h4 id="ftp-协议的特点-优势"><a href="#ftp-协议的特点-优势" class="header-anchor">#</a> FTP 协议的特点/优势？</h4> <p>FTP 协议是基于客户端-服务器（C/S）模型而设计的，在客户端和 FTP 服务器之间建立了两个连接：控制连接和数据连接，这也是与其他客户端服务器程序最大的不同，一般的客户端服务器只有一条TCP连接。这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p> <ul><li>控制连接：用于传送控制信息（命令和响应）</li> <li>数据连接：用于数据传送</li></ul> <p>不过 FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议是用 SFTP 协议。</p> <h4 id="telnet-和-ssh-协议的区别"><a href="#telnet-和-ssh-协议的区别" class="header-anchor">#</a> TelNet 和 SSH 协议的区别？</h4> <p>两者都基于 TCP 协议，都可以用于远程登录服务器。TelNet 协议的所有数据都是以明文形式发送的，存在潜在的安全风险。而 SSH 则通过加密和认证机制实现安全的访问和文件传输等业务。</p> <p>除此之外，SSH 也支持隧道协议、端口映射和 X11 连接。借助 SFTP 或 SCP 协议，SSH 还可以传输文件。SSH 使用客户端-服务器模型，默认端口是 22。SSH 是一个守护进程，负责实时监听客户端请求，并进行处理。大多数现代操作系统都提供了 SSH。</p> <h4 id="rtp-协议是什么协议"><a href="#rtp-协议是什么协议" class="header-anchor">#</a> RTP 协议是什么协议？</h4> <p>RTP 是实时传输协议，通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。<br>
RTP 协议分为两种子协议：</p> <ul><li>RTP：实时传输协议，传输具有实时特性的数据。</li> <li>RTCP：RTP 控制协议，提供实时传输过程中的统计信息（如网络延迟、丢包率等），WebRTC 正是根据这些信息处理丢包。</li></ul> <h4 id="什么是-dns"><a href="#什么是-dns" class="header-anchor">#</a> 什么是 DNS？</h4> <p>DNS，Domain Name System，即域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议（如果本地 <code>hosts</code> 列表中有缓存，就不用动用 DNS）。DNS 要解决的是<strong>域名与 IP 地址的映射问题</strong>。<br>
DNS 是应用层协议，基于 UDP 协议之上，端口为 53。</p> <p>DNS 服务器自底向上可以依次分为四个层级：</p> <ul><li>根 DNS 服务器：根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内仍没有根服务器。</li> <li>顶级域 DNS 服务器（TLD 服务器）：顶级域是指域名的后缀，如 <code>com</code>、<code>org</code>、<code>net</code> 和 <code>edu</code> 等。国家也有自己的顶级域，如 <code>uk</code>、<code>fr</code>、和 <code>ca</code>。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</li> <li>权威 DNS 服务器：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</li> <li>本地 DNS 服务器：每个 ISP （互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构。</li></ul> <h4 id="dns-工作流程"><a href="#dns-工作流程" class="header-anchor">#</a> DNS 工作流程？</h4> <p>DNS 的查询解析过程分为两种模式：<strong>迭代</strong> 和 <strong>递归</strong>。</p> <ul><li><p><strong>迭代</strong>：</p> <ol><li>请求主机向本地 DNS 服务器发起 DNS 请求，该查询报文包含被转换的域名。</li> <li>本地 DNS 服务器没有的话就会向根 DNS 服务器询问，根 DNS 服务器返回给本地 DNS 服务器对应的顶级域 DNS 服务器地址。</li> <li>本地 DNS 服务器再向顶级域 DNS 服务器询问，顶级域 DNS 服务器再返回给本地 DNS 服务器对应的权威 DNS 服务器地址。</li> <li>本地 DNS 服务器再向权威 DNS 服务器询问，权威 DNS 服务器返回域名对应的目标主机的 IP 地址。</li> <li>本地 DNS 服务器获取到域名对应的目标主机的 IP 地址，再将其返回给请求主机。</li></ol></li> <li><p><strong>递归</strong>：</p> <ol><li>请求主机向本地 DNS 服务器发起 DNS 请求，该查询报文包含被转换的域名。</li> <li>本地 DNS 服务器没有的话就会向根 DNS 服务器询问。根 DNS 服务器接收到请求向顶级域 DNS 服务器发起询问。顶级域 DNS 服务器接收到请求向权威 DNS 服务器发起询问。</li> <li>权威 DNS 服务器将域名对应目标主机的 IP 地址返回给顶级域 DNS 服务器。顶级域 DNS 服务器再返回给根 DNS 服务器。根 DNS 服务器再返回给本地 DNS 服务器。本地 DNS 服务器再返回给请求主机。</li></ol></li></ul> <h4 id="dns-报文格式"><a href="#dns-报文格式" class="header-anchor">#</a> DNS 报文格式？</h4> <p>DNS 报文分为查询和回答报文，两种形式的报文结构相同。</p> <ul><li>标识符。16 比特，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。</li> <li>标志。1 比特的 “查询/回答” 标识位，0表示查询报文，1表示回答报文；1 比特的 “权威” 标志位（当某 DNS 服务器是所请求名字的权威 DNS 服务器时，且是回答报文，使用 “权威” 标志）；1 比特的 “希望递归” 标志位，显式地要求执行递归查询；1 比特的 “递归可用” 标志位，用于回答报文中，表示 DNS 服务器支持递归查询。</li> <li>问题数、回答 RR 数、权威 RR 数、附加 RR 数。分别指示了后面 4 类数据区域出现的数量。</li> <li>问题区域。包含正在被查询的主机名字，以及正被询问的问题类型。</li> <li>回答区域。包含了对最初请求的名字的资源记录。<strong>在回答报文的回答区域中可以包含多条 RR，因此一个主机名能够有多个 IP 地址</strong>。</li> <li>权威区域。包含了其他权威服务器的记录。</li> <li>附加区域。包含了其他有帮助的记录。</li></ul> <h4 id="dns-服务器是怎么记录的"><a href="#dns-服务器是怎么记录的" class="header-anchor">#</a> DNS 服务器是怎么记录的？</h4> <p>DNS 服务器在响应查询时，需要查询自己的数据库，数据库中的条目被称为 <strong>资源记录（Resource Record, RR）</strong>。RR 提供了主机名到 IP 地址的映射。RR 是一个包含了 <code>Name</code>，<code>Value</code>，<code>Type</code>，<code>TTL</code> 四个字段的四元组。<code>TTL</code> 是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。<code>Name</code> 和 <code>Value</code> 字段的取值取决于 <code>Type</code>。</p> <ul><li>如果 <code>Type=A</code>，则 <code>Name</code> 是主机名信息，<code>Value</code> 是该主机名对应的 IP 地址。这样的 RR 记录了一条主机名到 IP 地址的映射。</li> <li>如果 <code>Type=AAAA</code> （与 A 记录非常相似），唯一的区别是 A 记录使用的是 IPv4，而 AAAA 记录使用的是 IPv6。</li> <li>如果 <code>Type=CNAME</code> （Canonical Name Record,真实名称记录），则 <code>Value</code> 是别名为 <code>Name</code> 的主机对应的规范主机名。<code>Value</code> 值才是规范主机名。<code>CNAME</code> 记录将一个主机名映射到另一个主机名。<code>CNAME</code> 记录用于为现有的 A 记录创建别名。</li> <li>如果 <code>Type=NS</code>，则 <code>Name</code> 是一个域，而 <code>Value</code> 是一个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名。通常这样的 RR 是由顶级域 DNS 服务器发布的。</li> <li>如果 <code>Type=MX</code>，则 <code>Value</code> 是个别名为 <code>Name</code> 的邮件服务器的规范主机名。既然有了 <code>MX</code> 记录，那么邮件服务器可以和其他服务器使用相同的别名。为了获得邮件服务器的规范主机名，需要请求 <code>MX</code> 记录；为了获得其他服务器的规范主机名，需要请求 <code>CNAME</code> 记录。</li></ul> <p><code>CNAME</code> 记录总是指向另一则域名，而非 IP 地址。</p> <h2 id="ping"><a href="#ping" class="header-anchor">#</a> Ping</h2> <h4 id="ping-命令作用是什么"><a href="#ping-命令作用是什么" class="header-anchor">#</a> Ping 命令作用是什么？</h4> <p>Ping 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p> <p>Ping 命令的输出结果通常包括以下四部分：</p> <ul><li><strong>ICMP Echo Request</strong>：请求报文信息，包含了序列号、TTL（Time to Live）值。</li> <li><strong>目标主机的域名或 IP 地址</strong>：输出结果的第一行。</li> <li><strong>往返时间 RTT</strong>：从发送 ICMP Echo Request 请求报文到接收 ICMP Echo Reply 响应报文的总时间，用来衡量网络连接的延迟。</li> <li><strong>统计结果</strong>：包括发送的 ICMP 请求数据包的数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间的最小、平均、最大和标准偏差值。</li></ul> <h4 id="ping-命令的工作原理是什么"><a href="#ping-命令的工作原理是什么" class="header-anchor">#</a> Ping 命令的工作原理是什么？</h4> <p>PING 基于网络层的 ICMP（Internet Control Message Protocol，互联网控制报文协议），其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</p> <p>CMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：</p> <ul><li><strong>查询报文类型</strong>：向目标主机发送请求并期望得到响应。</li> <li><strong>差错报文类型</strong>：向源主机发送错误信息，用于报告网络中的错误情况。</li></ul> <p>PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型。</p> <ul><li>PING 命令会向目标主机发送 ICMP Echo Request。</li> <li>如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。</li></ul> <h2 id="ip-协议"><a href="#ip-协议" class="header-anchor">#</a> IP 协议</h2> <h4 id="ip-协议的作用是什么"><a href="#ip-协议的作用是什么" class="header-anchor">#</a> IP 协议的作用是什么？</h4> <p>IP 协议是 TCP/IP 协议中最重要的协议之一，属于网络层协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p> <p>IP 协议主要分两种：IPv4 和 IPv6。</p> <h4 id="什么是-ip-地址-ip-寻址如何工作"><a href="#什么是-ip-地址-ip-寻址如何工作" class="header-anchor">#</a> 什么是 IP 地址？ IP 寻址如何工作？</h4> <p>每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 IP 地址（Internet Protocol address），作为唯一标识符。每个 IP 地址都是一个字符序列。</p> <p>当网络设备发送 IP 数据包时，数据包中包含了 源 IP 地址 和 目的 IP 地址 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。</p> <h4 id="什么是-ip-地址过滤"><a href="#什么是-ip-地址过滤" class="header-anchor">#</a> 什么是 IP 地址过滤？</h4> <p>IP 地址过滤简单来说就是限制或阻止特定 IP 地址或 IP 地址范围的访问。IP 地址过滤是一种简单的网络安全措施，实际应用中一般会结合其他网络安全措施，如认证、授权、加密等一起使用。单独使用 IP 地址过滤并不能完全保证网络的安全。</p> <h4 id="ipv4-和-ipv6-有什么区别"><a href="#ipv4-和-ipv6-有什么区别" class="header-anchor">#</a> IPv4 和 IPv6 有什么区别？</h4> <ul><li>地址位数：IPv4 的地址是 32 位的，IPv6 的地址是 128 位的。显然 IPv6 的地址范围更大。</li> <li>格式：IPv4 格式是四组由点分隔的数字，IPv6 格式使用由单或双冒号分割的一组数字或字母。</li></ul> <h4 id="ipv6-的优势"><a href="#ipv6-的优势" class="header-anchor">#</a> IPv6 的优势？</h4> <ul><li><strong>更大的地址空间</strong></li> <li><strong>无状态地址自动配置（SLAAC）</strong>：主机可以直接根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP 服务器，简化了网络配置和管理。</li> <li><strong>NAT（网络地址转换）成为可选项</strong>：IPv6 地址资源充足，可以给全球每个设备一个独立的地址，不必非要通过局域网到广域网的转换。</li> <li><strong>对标头结构进行了改进</strong>：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。</li> <li><strong>可选的扩展头</strong>：允许在 IPv6 标头中添加不同的扩展头，用于实现不同类型的功能和选项。</li> <li><strong>ICMPv6</strong>：IPv6 中的 ICMP 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 等功能的改进，从而提高了网络的可靠性和性能。</li></ul> <h2 id="nat-协议"><a href="#nat-协议" class="header-anchor">#</a> NAT 协议</h2> <h4 id="nat-协议是什么"><a href="#nat-协议是什么" class="header-anchor">#</a> NAT 协议是什么？</h4> <p>NAT，即 Network Address Translation，网络地址转换，应用于局域网到广域网的地址转换过程中。具体地说，在一个小的子网（局域网，Local Area Network，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（Wide Area Network，WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</p> <h4 id="nat-协议的作用是什么"><a href="#nat-协议的作用是什么" class="header-anchor">#</a> NAT 协议的作用是什么？</h4> <ol><li>用于局域网与广域网之间的地址转换。</li> <li>隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，提高了内部网络的安全性。</li></ol> <h4 id="nat-协议是怎么工作的"><a href="#nat-协议是怎么工作的" class="header-anchor">#</a> NAT 协议是怎么工作的？</h4> <p>在路由器内部维护一个 <strong>NAT 转换表</strong>，用于存储转换记录，转换记录不止包括地址，还包括端口号。</p> <p>每个路由器都有一个 WAN 接口和多个 LAN 接口，LAN 接口对应局域网中的各个设备。</p> <h4 id="nat-协议特点"><a href="#nat-协议特点" class="header-anchor">#</a> NAT 协议特点？</h4> <ol><li>NAT 协议通过对 WAN 屏蔽 LAN，有效地缓解了 IPv4 地址分配压力。</li> <li>LAN 主机 IP 地址的变更，无需通告 WAN。</li> <li>WAN 的 ISP 变更接口地址时，无需通告 LAN 内主机。</li> <li>LAN 主机对 WAN 不可见，不可直接寻址，可以保证一定程度的安全性。</li></ol></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/java-note/Java/知识点自测速记/知识点自测速记之JVM.html" class="prev">
        知识点自测速记之JVM
      </a></span> <span class="next"><a href="/java-note/Java/知识点自测速记/知识点自测速记之操作系统.html">
        知识点自测速记之操作系统
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/java-note/assets/js/app.4802240e.js" defer></script><script src="/java-note/assets/js/2.834e1286.js" defer></script><script src="/java-note/assets/js/1.56911593.js" defer></script><script src="/java-note/assets/js/61.9f3ed6b5.js" defer></script>
  </body>
</html>
