(window.webpackJsonp=window.webpackJsonp||[]).push([[51],{478:function(v,a,_){"use strict";_.r(a);var t=_(8),r=Object(t.a)({},(function(){var v=this,a=v._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("blockquote",[a("p",[v._v("这篇文章以问答的形式用于快速回顾知识点以及用于自测。"),a("br"),v._v("\n因为知识点相当多，即使在看时能够理解记住，但过后也往往只是有印象，大概知道是什么东西，但想回答出来却总是卡壳，看了忘，忘了看。因此，这篇文章用于帮助速记回忆，自测时可以由这些点延伸。")])]),v._v(" "),a("h2",{attrs:{id:"java-内存区域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-内存区域"}},[v._v("#")]),v._v(" Java 内存区域")]),v._v(" "),a("h4",{attrs:{id:"java-虚拟机的内存区域是怎么分配的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-虚拟机的内存区域是怎么分配的"}},[v._v("#")]),v._v(" Java 虚拟机的内存区域是怎么分配的？")]),v._v(" "),a("p",[v._v("堆（其中包括字符串常量池）、各个线程分配的内存（其中包括程序计数器、虚拟机栈、本地方法栈）"),a("br"),v._v("\n本地内存（包括直接内存、元空间（元空间包括运行时常量池））"),a("strong",[v._v("不属于")]),v._v("虚拟机运行时数据区域。")]),v._v(" "),a("h4",{attrs:{id:"什么是程序计数器-程序计数器有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是程序计数器-程序计数器有什么作用"}},[v._v("#")]),v._v(" 什么是程序计数器？程序计数器有什么作用？")]),v._v(" "),a("p",[v._v("程序计数器是一块较小的内存，可以看作是当前线程所执行字节码的行号指示器。"),a("br"),v._v("\n作用：改变程序计数器来依次读取指令；在多线程情况下记录当前线程执行的位置。")]),v._v(" "),a("h4",{attrs:{id:"java-虚拟机栈的生命周期-存入的是哪些信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-虚拟机栈的生命周期-存入的是哪些信息"}},[v._v("#")]),v._v(" Java 虚拟机栈的生命周期？存入的是哪些信息？")]),v._v(" "),a("p",[v._v("Java 虚拟机栈的生命周期随线程创建而创建，随线程死亡而死亡。"),a("br"),v._v("\n存入的是栈帧，栈帧随方法调用而入栈，随方法结束而出栈，无论是正常结束还是异常结束。"),a("br"),v._v("\n栈帧组成：局部变量表、操作数栈、动态链接、方法返回地址。"),a("br"),v._v("\n局部变量表：存放基本数据类型和对象引用。"),a("br"),v._v("\n操作数栈：存放方法调用过程中产生的中间计算结果。"),a("br"),v._v("\n动态链接：服务于一个方法需要调用其他方法的场景，将符号引用转换为调用方法的直接引用。")]),v._v(" "),a("h4",{attrs:{id:"程序运行时栈可能会出现什么错误"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程序运行时栈可能会出现什么错误"}},[v._v("#")]),v._v(" 程序运行时栈可能会出现什么错误？")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("StackOverFlowError")]),v._v("：若栈的内存不允许动态扩展，线程请求栈的深度超过当前 Java 虚拟机栈最大深度。")]),v._v(" "),a("li",[a("code",[v._v("OutOfMemoryError")]),v._v("：若栈的内存可以动态扩展（一般不允许），虚拟机在动态扩展栈时无法申请到足够的内存空间。")])]),v._v(" "),a("h4",{attrs:{id:"本地方法栈的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈的作用"}},[v._v("#")]),v._v(" 本地方法栈的作用？")]),v._v(" "),a("p",[v._v("与虚拟机栈类似，但是虚拟机栈针对的是 Java 方法（也就是字节码），而本地方法栈针对的是本地方法。")]),v._v(" "),a("h4",{attrs:{id:"堆是什么-堆有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆是什么-堆有什么作用"}},[v._v("#")]),v._v(" 堆是什么？堆有什么作用？")]),v._v(" "),a("p",[v._v("Java 虚拟机所管理内存最大的一块，也是所有线程共享的一块内存区域，在虚拟机启动时创建。"),a("br"),v._v("\n作用：存放对象实例，几乎所有的对象实例以及数组都在堆中分配内存。")]),v._v(" "),a("h4",{attrs:{id:"堆内存有哪几部分"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆内存有哪几部分"}},[v._v("#")]),v._v(" 堆内存有哪几部分？")]),v._v(" "),a("ul",[a("li",[v._v("新生代（包括 Eden 和 Survivor）")]),v._v(" "),a("li",[v._v("老年代（Old）")]),v._v(" "),a("li",[v._v("永久代（Permanent，后面变为元空间，元空间使用的是本地内存）")])]),v._v(" "),a("h4",{attrs:{id:"对象在堆中各部分的迁移过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象在堆中各部分的迁移过程"}},[v._v("#")]),v._v(" 对象在堆中各部分的迁移过程？")]),v._v(" "),a("p",[v._v("大部分情况，对象会首先在 Eden 分配，在一次新生代垃圾回收后，如果对象存活，就进入 S0 或 S1，并且对象年龄加 1，当年龄达到一定程度，就会晋升到老年代。具体是，Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累计的某个年龄超过了 Survivor 区的一半，取该年龄和预设的 "),a("code",[v._v("MaxTenuringThreshold")]),v._v(" 中更小的一个作为年龄晋升阈值。")]),v._v(" "),a("h4",{attrs:{id:"堆最容易出现的错误"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#堆最容易出现的错误"}},[v._v("#")]),v._v(" 堆最容易出现的错误？")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("java.lang.OutOfMemoryError：Overhead Limit Exceeded")]),v._v("：JVM 花太多时间回收垃圾并且只能回收很少的堆空间。")]),v._v(" "),a("li",[a("code",[v._v("java.lang.OutOfMemoryError：Java heap space")]),v._v("：创建对象时堆空间不足。")])]),v._v(" "),a("h4",{attrs:{id:"什么是方法区-方法区和永久代、元空间的关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是方法区-方法区和永久代、元空间的关系"}},[v._v("#")]),v._v(" 什么是方法区？方法区和永久代、元空间的关系？")]),v._v(" "),a("p",[v._v("方法区是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。"),a("br"),v._v("\n方法区是逻辑概念，好比是类。而永久代、元空间是方法区的实现，相当于是实例。")]),v._v(" "),a("h4",{attrs:{id:"为什么要将永久代替换为元空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要将永久代替换为元空间"}},[v._v("#")]),v._v(" 为什么要将永久代替换为元空间？")]),v._v(" "),a("p",[v._v("元空间使用本地内存，空间大小比永久代大，也因此可以加载的类数更多。")]),v._v(" "),a("h4",{attrs:{id:"方法区存放哪些信息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法区存放哪些信息"}},[v._v("#")]),v._v(" 方法区存放哪些信息？")]),v._v(" "),a("p",[v._v("方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。")]),v._v(" "),a("h4",{attrs:{id:"方法区常用参数有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#方法区常用参数有哪些"}},[v._v("#")]),v._v(" 方法区常用参数有哪些？")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("-XX:MetaspaceSize=N")]),v._v("：初始大小")]),v._v(" "),a("li",[a("code",[v._v("-XX:MaxMetaspaceSize")]),v._v("：最大大小")])]),v._v(" "),a("h4",{attrs:{id:"运行时常量池的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运行时常量池的作用"}},[v._v("#")]),v._v(" 运行时常量池的作用？")]),v._v(" "),a("p",[v._v("用于存放编译期生成的各种字面量和符号引用。"),a("br"),v._v("\n字面量：包括整数、浮点数、字符串字面量。"),a("br"),v._v("\n符号引用：类符号引用、字段符号引用、方法符号引用、接口符号引用。")]),v._v(" "),a("h4",{attrs:{id:"字符串常量池是什么-作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池是什么-作用"}},[v._v("#")]),v._v(" 字符串常量池是什么？作用？")]),v._v(" "),a("p",[v._v("JVM 为了提高性能和减少内存消耗针对字符串专门开辟的一块区域。"),a("br"),v._v("\n作用：避免字符串的重复创建。")]),v._v(" "),a("h4",{attrs:{id:"字符串常量池中保存的是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池中保存的是什么"}},[v._v("#")]),v._v(" 字符串常量池中保存的是什么？")]),v._v(" "),a("ul",[a("li",[v._v("字符串字面量")]),v._v(" "),a("li",[v._v("通过String类的intern()方法添加的字符串")]),v._v(" "),a("li",[v._v("编译器优化的字符串（比如将多个字符串合并为一个）")])]),v._v(" "),a("h4",{attrs:{id:"jdk1-7-为什么要将字符串常量池从永久代移动到堆中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-7-为什么要将字符串常量池从永久代移动到堆中"}},[v._v("#")]),v._v(" JDK1.7 为什么要将字符串常量池从永久代移动到堆中？")]),v._v(" "),a("p",[v._v("永久代的GC回收效率太低，只有在Full GC的时候才会被执行GC，而程序中通常有大量被创建的字符串等待回收。")]),v._v(" "),a("h4",{attrs:{id:"直接内存和堆外内存是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#直接内存和堆外内存是什么"}},[v._v("#")]),v._v(" 直接内存和堆外内存是什么？")]),v._v(" "),a("p",[v._v("直接内存是一种特殊的内存缓冲区，通过Java NIO（New I/O）库中的 java.nio.ByteBuffer 来分配和管理的一种内存区域。它既不是虚拟机运行时数据区域的一部分，也不是虚拟机规范中定义的内存区域。"),a("br"),v._v("\n堆外内存是在 Java 堆之外分配的内存区域，包括直接内存和其他方式分配的内存。")]),v._v(" "),a("h4",{attrs:{id:"java-对象的创建过程是怎样的-重点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-对象的创建过程是怎样的-重点"}},[v._v("#")]),v._v(" Java 对象的创建过程是怎样的？（重点）")]),v._v(" "),a("p",[v._v("类加载检查 -> 分配内存 -> 初始化零值（数据类型对应的零值）-> 设置对象头（类、类元数据信息、哈希码、GC分代年龄等） -> 执行init方法")]),v._v(" "),a("h4",{attrs:{id:"内存分配有哪两种方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存分配有哪两种方式"}},[v._v("#")]),v._v(" 内存分配有哪两种方式？")]),v._v(" "),a("p",[v._v("指针碰撞、空闲列表")]),v._v(" "),a("h4",{attrs:{id:"内存分配并发有哪两种方式保证线程安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存分配并发有哪两种方式保证线程安全"}},[v._v("#")]),v._v(" 内存分配并发有哪两种方式保证线程安全？")]),v._v(" "),a("ul",[a("li",[v._v("CAS + 失败重试")]),v._v(" "),a("li",[v._v("TLAB：为每一个线程预先在 Eden 区分配一块内存，在给线程中的对象分配内存时首先在 TLAB 中分配，TLAB 不够分配时再采用 CAS 进行内存分配。")])]),v._v(" "),a("h4",{attrs:{id:"对象的内存布局是怎样的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的内存布局是怎样的"}},[v._v("#")]),v._v(" 对象的内存布局是怎样的？")]),v._v(" "),a("p",[v._v("对象头、实例数据、对齐填充（仅起占位作用）")]),v._v(" "),a("h4",{attrs:{id:"对象的访问定位有哪几种方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的访问定位有哪几种方式"}},[v._v("#")]),v._v(" 对象的访问定位有哪几种方式？")]),v._v(" "),a("p",[v._v("Java 程序通过栈上的 reference 数据来操作堆上的具体对象。")]),v._v(" "),a("ul",[a("li",[v._v("使用句柄：reference 存储对象句柄地址，句柄中存储 到对象实例数据的指针 和 到对象类型数据的指针。")]),v._v(" "),a("li",[v._v("直接指针：reference 直接存储对象的地址。")])]),v._v(" "),a("h2",{attrs:{id:"jvm-垃圾回收-gc"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm-垃圾回收-gc"}},[v._v("#")]),v._v(" JVM 垃圾回收 GC")]),v._v(" "),a("h4",{attrs:{id:"java-自动内存管理指的是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-自动内存管理指的是什么"}},[v._v("#")]),v._v(" Java 自动内存管理指的是什么？")]),v._v(" "),a("p",[v._v("对象内存的分配与回收。"),a("br"),v._v("\n最核心的功能是堆内存中对象的分配与回收。")]),v._v(" "),a("h4",{attrs:{id:"java-堆的基本结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java-堆的基本结构"}},[v._v("#")]),v._v(" Java 堆的基本结构？")]),v._v(" "),a("ul",[a("li",[v._v("新生代：Eden、S0、S1")]),v._v(" "),a("li",[v._v("老年代")]),v._v(" "),a("li",[v._v("永久代/元空间：JDK8 之后永久代被元空间取代，元空间使用的是直接内存。")])]),v._v(" "),a("h4",{attrs:{id:"内存分配和回收原则是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存分配和回收原则是什么"}},[v._v("#")]),v._v(" 内存分配和回收原则是什么？")]),v._v(" "),a("ol",[a("li",[a("strong",[v._v("对象优先在 Eden 区分配")]),v._v("：大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。")]),v._v(" "),a("li",[a("strong",[v._v("大对象直接进行老年代")]),v._v("：大对象就是需要大量连续内存空间的对象（比如字符串、数组）。大对象直接进入老年代是一种优化策略，旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本。")]),v._v(" "),a("li",[a("strong",[v._v("长期存活的对象将进入老年代")]),v._v("：大部分情况，对象都会首先在 Eden 区域分配。如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1(Eden 区->Survivor 区后对象的初始年龄变为 1)。对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。")])]),v._v(" "),a("h4",{attrs:{id:"主要进行-gc-的区域是哪"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要进行-gc-的区域是哪"}},[v._v("#")]),v._v(" 主要进行 GC 的区域是哪？")]),v._v(" "),a("p",[v._v("针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：")]),v._v(" "),a("ul",[a("li",[v._v("Partial GC：并不收集整个 GC 堆。\n"),a("ul",[a("li",[v._v("Young GC / Minor GC：只对新生代收集")]),v._v(" "),a("li",[v._v("Major GC / Old GC：只对老年代进行垃圾收集。")]),v._v(" "),a("li",[v._v("Mixed GC：对整个新生代和部分老年代进行垃圾收集。")])])]),v._v(" "),a("li",[v._v("Full GC：收集整个 Java 堆，包括新生代、老年代、永久代（JDK8之前）。")])]),v._v(" "),a("h4",{attrs:{id:"空间分配担保是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#空间分配担保是什么"}},[v._v("#")]),v._v(" 空间分配担保是什么？")]),v._v(" "),a("p",[v._v("空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。")]),v._v(" "),a("p",[v._v("JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 "),a("code",[v._v("-XX:HandlePromotionFailure")]),v._v(" 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 "),a("code",[v._v("-XX: HandlePromotionFailure")]),v._v(" 设置不允许冒险，那这时就要改为进行一次 Full GC。"),a("br"),v._v("\nJDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。")]),v._v(" "),a("h4",{attrs:{id:"死亡对象的判断方法有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#死亡对象的判断方法有哪些"}},[v._v("#")]),v._v(" 死亡对象的判断方法有哪些？")]),v._v(" "),a("ul",[a("li",[v._v("引用计数法：引用时加1，引用失效时减1，任何时候计数器为0的对象就是不可能再被使用的。这个方法简单高效，但存在循环引用的问题。")]),v._v(" "),a("li",[v._v('可达性分析法：通过一系列被称为 "GC Roots" 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象不可用，需要被回收。')])]),v._v(" "),a("h4",{attrs:{id:"哪些对象可以作为-gc-roots"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#哪些对象可以作为-gc-roots"}},[v._v("#")]),v._v(" 哪些对象可以作为 GC Roots？")]),v._v(" "),a("ul",[a("li",[v._v("虚拟机栈栈帧的局部变量表中引用的对象")]),v._v(" "),a("li",[v._v("本地方法栈的本地方法中引用的对象")]),v._v(" "),a("li",[v._v("方法区中类静态属性引用的对象")]),v._v(" "),a("li",[v._v("方法区中常量引用的对象")]),v._v(" "),a("li",[v._v("所有被同步锁持有的对象")]),v._v(" "),a("li",[v._v("JNI(Java Native Interface) 引用的对象")])]),v._v(" "),a("h4",{attrs:{id:"对象可以被回收-就一定会被回收吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象可以被回收-就一定会被回收吗"}},[v._v("#")]),v._v(" 对象可以被回收，就一定会被回收吗？")]),v._v(" "),a("p",[v._v("不一定，要真正宣告一个对象死亡，至少要经历两次标记过程。")]),v._v(" "),a("ol",[a("li",[v._v("第一次标记并筛选：筛选条件是此对象有必要执行 "),a("code",[v._v("finalize()")]),v._v(" 方法。当对象没有覆盖 "),a("code",[v._v("finalize()")]),v._v(" 方法，或 "),a("code",[v._v("finalize()")]),v._v(" 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。")]),v._v(" "),a("li",[v._v("第二次标记：在第一次标记筛选中被判定为需要执行 "),a("code",[v._v("finalize()")]),v._v(" 方法的对象会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。")])]),v._v(" "),a("h4",{attrs:{id:"引用类型有哪几种"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#引用类型有哪几种"}},[v._v("#")]),v._v(" 引用类型有哪几种？")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("强引用")]),v._v("：如果一个对象具有强引用，垃圾回收器绝不会回收它。内存空间不足时宁可抛出 "),a("code",[v._v("OutOfMemoryError")]),v._v(" 错误。")]),v._v(" "),a("li",[a("strong",[v._v("软引用")]),v._v("：内存空间足够，垃圾回收器就不会回收它，否则就会回收。软引用可以用来实现内存敏感的高速缓存。软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。")]),v._v(" "),a("li",[a("strong",[v._v("弱引用")]),v._v("：垃圾回收器在回收过程中，不管内存空间够不够，都会回收具有弱引用的对象。")]),v._v(" "),a("li",[a("strong",[v._v("虚引用")]),v._v("：虚引用不决定对象的生命周期，只是作为一个标记，主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的区别在于它必须和引用队列联合使用。")])]),v._v(" "),a("h4",{attrs:{id:"如何判断常量池中一个常量是废弃常量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何判断常量池中一个常量是废弃常量"}},[v._v("#")]),v._v(" 如何判断常量池中一个常量是废弃常量？")]),v._v(" "),a("p",[v._v("eg. 字符串常量池中没有任何对象引用该常量")]),v._v(" "),a("h4",{attrs:{id:"如何判断一个类是无用的类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何判断一个类是无用的类"}},[v._v("#")]),v._v(" 如何判断一个类是无用的类？")]),v._v(" "),a("p",[v._v("三个条件：实例、类加载器、Class 对象。")]),v._v(" "),a("ul",[a("li",[v._v("实例：该类所有实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。")]),v._v(" "),a("li",[v._v("类加载器：加载该类的 "),a("code",[v._v("ClassLoader")]),v._v(" 已经被回收。")]),v._v(" "),a("li",[v._v("Class 对象：该类对应的 "),a("code",[v._v("java.lang.Class")]),v._v(" 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。")])]),v._v(" "),a("h4",{attrs:{id:"垃圾收集的算法有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#垃圾收集的算法有哪些"}},[v._v("#")]),v._v(" 垃圾收集的算法有哪些？")]),v._v(" "),a("ul",[a("li",[v._v("标记-清除：标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。效率不高且会产生大量不连续的内存碎片。")]),v._v(" "),a("li",[v._v("标记-复制：将内存分为大小相同的两块，每次使用其中一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。这个算法改进了标记-清除算法，但存在可用内存变小，不适合老年代的问题。")]),v._v(" "),a("li",[v._v("标记-整理：根据老年代特点提出的算法，标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界之外的内存。")]),v._v(" "),a("li",[v._v("分代收集算法：这种与其说是算法，倒不如说是策略，它根据堆空间的不同采取不同的算法。新生代采用标记-复制，老年代采用标记-清除/整理。")])]),v._v(" "),a("h4",{attrs:{id:"hotspot-为什么要分为新生代和老年代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hotspot-为什么要分为新生代和老年代"}},[v._v("#")]),v._v(" Hotspot 为什么要分为新生代和老年代？")]),v._v(" "),a("p",[v._v("因为对象存活周期不同。")]),v._v(" "),a("ul",[a("li",[v._v("新生代：标记-复制")]),v._v(" "),a("li",[v._v("老年代：标记-清除/整理")])]),v._v(" "),a("h4",{attrs:{id:"什么是垃圾收集器-有哪些垃圾收集器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是垃圾收集器-有哪些垃圾收集器"}},[v._v("#")]),v._v(" 什么是垃圾收集器？有哪些垃圾收集器？")]),v._v(" "),a("p",[v._v("如果说垃圾收集算法是内存回收的方法论，那么垃圾回收器就是内存回收的具体实现。")]),v._v(" "),a("ul",[a("li",[v._v("Serial：单线程收集器，并且在进行垃圾收集的时候必须暂停其他所有的工作线程，直到它收集结束。")]),v._v(" "),a("li",[v._v("ParNew：其实就是 Serial 收集器的多线程版本。")]),v._v(" "),a("li",[v._v("Parallel Scavenge：几乎与 ParNew 一样，但是它关注点是吞吐量（高效率地利用 CPU）。CMS 等垃圾收集器关注点是用户线程的停顿时间（提高用户体验）。")]),v._v(" "),a("li",[v._v("Serial Old：Serial 收集器的老年代版本。")]),v._v(" "),a("li",[v._v("Parallel Old：Parallel Scavenge 的老年代版本。在注重吞吐量以及 CPU 资源的场合，都可以优先考虑 Parallel Scavenge 收集器和 Parallel Old 收集器。")]),v._v(" "),a("li",[v._v("CMS（重点收集器）：一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。它是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。")]),v._v(" "),a("li",[v._v("G1（重点收集器）：一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征。")]),v._v(" "),a("li",[v._v("ZGC：与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，不过 ZGC 对该算法做了重大改进。在 ZGC 中出现 Stop The World 的情况会更少！")])]),v._v(" "),a("h4",{attrs:{id:"cms-收集器的工作过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cms-收集器的工作过程"}},[v._v("#")]),v._v(" CMS 收集器的工作过程？")]),v._v(" "),a("ol",[a("li",[a("strong",[v._v("初始标记")]),v._v("：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快。")]),v._v(" "),a("li",[a("strong",[v._v("并发标记")]),v._v("：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。")]),v._v(" "),a("li",[a("strong",[v._v("重新标记")]),v._v("：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短。")]),v._v(" "),a("li",[a("strong",[v._v("并发清除")]),v._v("：开启用户线程，同时 GC 线程开始对未标记的区域做清扫。")])]),v._v(" "),a("h4",{attrs:{id:"cms-收集器优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cms-收集器优缺点"}},[v._v("#")]),v._v(" CMS 收集器优缺点？")]),v._v(" "),a("p",[v._v("优点：并发收集、低停顿。"),a("br"),v._v("\n缺点：对 CPU 资源敏感；无法处理浮动垃圾；它使用的回收算法——标记-清除会导致收集结束时会有大量空间碎片产生。")]),v._v(" "),a("h4",{attrs:{id:"g1-收集器特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1-收集器特点"}},[v._v("#")]),v._v(" G1 收集器特点：")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("并行与并发")]),v._v("：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。")]),v._v(" "),a("li",[a("strong",[v._v("分代收集")])]),v._v(" "),a("li",[a("strong",[v._v("空间整合")]),v._v("：G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的。")]),v._v(" "),a("li",[a("strong",[v._v("可预测的停顿")]),v._v("：G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。")])]),v._v(" "),a("h4",{attrs:{id:"g1-收集器的工作过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#g1-收集器的工作过程"}},[v._v("#")]),v._v(" G1 收集器的工作过程？")]),v._v(" "),a("p",[v._v("初始标记 -> 并发标记 -> 最终标记 -> 筛选回收。")]),v._v(" "),a("p",[v._v("G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来) 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。")]),v._v(" "),a("h2",{attrs:{id:"类文件结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类文件结构"}},[v._v("#")]),v._v(" 类文件结构")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("魔数")]),v._v("：每个 Class 文件的头 4 个字节称为魔数，它的唯一作用就是确定这个文件是否为一个能被虚拟机接收的 Class 文件。Java 规范规定魔数为固定值：0xCAFEBABE。")]),v._v(" "),a("li",[a("strong",[v._v("Class 文件版本号")]),v._v("：共四个字节，前两个字节是次版本号，后两个字节是主版本号。")]),v._v(" "),a("li",[a("strong",[v._v("常量池")]),v._v("：有一个 2 字节的字段记录常量池的个数，以及一个常量池数组，常量池中主要存放的是字面量和符号引用。")]),v._v(" "),a("li",[a("strong",[v._v("访问标志")]),v._v("：用于识别一些类或者接口层次的访问信息，包括这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等。")]),v._v(" "),a("li",[a("strong",[v._v("类索引、父类索引和接口索引集合")]),v._v("：类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，接口索引集合用来描述这个类实现了哪些接口。")]),v._v(" "),a("li",[a("strong",[v._v("字段表集合")]),v._v("：字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。")]),v._v(" "),a("li",[a("strong",[v._v("方法表集合")]),v._v("：描述类的方法信息。")]),v._v(" "),a("li",[a("strong",[v._v("属性表集合")]),v._v("：在 Class 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。")])]),v._v(" "),a("h2",{attrs:{id:"类加载过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载过程"}},[v._v("#")]),v._v(" 类加载过程")]),v._v(" "),a("h4",{attrs:{id:"类的生命周期各个阶段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的生命周期各个阶段"}},[v._v("#")]),v._v(" 类的生命周期各个阶段？")]),v._v(" "),a("ol",[a("li",[a("strong",[v._v("加载")]),v._v("：类加载器加载，主要完成 3 件事情：\n"),a("ul",[a("li",[v._v("通过全类名获取定义此类的二进制字节流。")]),v._v(" "),a("li",[v._v("将字节流所代表的静态存储结构转换为方法区的运行时数据结构。")]),v._v(" "),a("li",[v._v("在内存中生成一个代表该类的 "),a("code",[v._v("Class")]),v._v(" 对象，作为方法区这些数据的访问入口。")])])]),v._v(" "),a("li",[a("strong",[v._v("验证")]),v._v("：连接阶段的第一步，这一阶段的目的是确保 "),a("code",[v._v("Class")]),v._v(" 文件的字节流中包含的信息符合《Java 虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。如果确定没有问题，也可以通过使用 "),a("code",[v._v("-Xverify:none")]),v._v(" 参数关闭大部分类验证措施，以缩短类的加载时间。验证阶段由四个阶段组成：\n"),a("ul",[a("li",[v._v("文件格式验证（Class 文件格式检查）")]),v._v(" "),a("li",[v._v("元数据验证（字节码语义检查）")]),v._v(" "),a("li",[v._v("字节码验证（程序语义检查）")]),v._v(" "),a("li",[v._v("符号引用验证（类的正确性检查）")])])]),v._v(" "),a("li",[a("strong",[v._v("准备")]),v._v("：正式为类变量（即静态变量）分配内存并设置类变量初始值（数据类型默认的零值）。")]),v._v(" "),a("li",[a("strong",[v._v("解析")]),v._v("：是虚拟机将常量池内的符号引用替换为直接引用的过程。")]),v._v(" "),a("li",[a("strong",[v._v("初始化")]),v._v("：执行初始化方法 "),a("code",[v._v("clinit()")]),v._v(" 方法的过程，是类加载的最后一步，这一步 JVM 才开始真正执行类中定义的 Java 程序代码(字节码)。"),a("code",[v._v("clinit()")]),v._v(" 方法是编译之后自动生成的。")]),v._v(" "),a("li",[a("strong",[v._v("使用")])]),v._v(" "),a("li",[a("strong",[v._v("卸载（Class 对象被 GC）")]),v._v("：卸载类即该类的 Class 对象被 GC。在 JVM 生命周期内，由 jvm 自带的类加载器加载的类是不会被卸载的。但是由我们自定义的类加载器加载的类是可能被卸载的。卸载类需要满足三个条件：\n"),a("ul",[a("li",[v._v("该类的所有实例对象都被 GC。")]),v._v(" "),a("li",[v._v("该类没有在其他任何地方被引用。")]),v._v(" "),a("li",[v._v("该类的类加载器的实例已被 GC。")])])])]),v._v(" "),a("p",[a("strong",[v._v("验证、准备、解析三个阶段被合称为连接。")])]),v._v(" "),a("h4",{attrs:{id:"系统加载-class-文件的步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统加载-class-文件的步骤"}},[v._v("#")]),v._v(" 系统加载 Class 文件的步骤？")]),v._v(" "),a("p",[a("strong",[v._v("加载 -> 连接 -> 初始化")]),a("br"),v._v(" "),a("strong",[v._v("连接：验证（是否合法）-> 准备（方法区分配空间、设置零值）-> 解析（符号引用转为直接引用）")])]),v._v(" "),a("h2",{attrs:{id:"类加载器详解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载器详解"}},[v._v("#")]),v._v(" 类加载器详解")]),v._v(" "),a("h4",{attrs:{id:"加载所做的事有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加载所做的事有哪些"}},[v._v("#")]),v._v(" 加载所做的事有哪些？")]),v._v(" "),a("ol",[a("li",[v._v("通过全类名获取定义此类的二进制字节流。")]),v._v(" "),a("li",[v._v("将字节流代表的静态存储结构转换为方法区的运行时数据结构。")]),v._v(" "),a("li",[v._v("在内存中生成一个代表该类的 "),a("code",[v._v("Class")]),v._v(" 对象，作为方法区这些数据的访问入口。")])]),v._v(" "),a("h4",{attrs:{id:"类加载器是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载器是什么"}},[v._v("#")]),v._v(" 类加载器是什么？")]),v._v(" "),a("ul",[a("li",[v._v("类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。")]),v._v(" "),a("li",[v._v("每个 Java 类都有一个引用指向加载它的 "),a("code",[v._v("ClassLoader")]),v._v("。")]),v._v(" "),a("li",[v._v("数组类不是通过 "),a("code",[v._v("ClassLoader")]),v._v(" 创建的，而是 JVM 在需要的时候自动创建的，数组类通过 "),a("code",[v._v("getClassLoader()")]),v._v(" 方法获取 "),a("code",[v._v("ClassLoader")]),v._v(" 的时候和该数组的元素类型的 "),a("code",[v._v("ClassLoader")]),v._v(" 是一致的。")]),v._v(" "),a("li",[v._v("除了加载类之外，类加载器还可以加载 Java 应用所需的资源如文本、图像、配置文件、视频等等文件资源。")])]),v._v(" "),a("h4",{attrs:{id:"类加载器加载规则是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载器加载规则是什么"}},[v._v("#")]),v._v(" 类加载器加载规则是什么？")]),v._v(" "),a("ul",[a("li",[v._v("JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。")]),v._v(" "),a("li",[v._v("相同二进制名称的类只会被加载一次。")])]),v._v(" "),a("h4",{attrs:{id:"jvm-内置的三个重要的-classloader"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm-内置的三个重要的-classloader"}},[v._v("#")]),v._v(" JVM 内置的三个重要的 ClassLoader？")]),v._v(" "),a("ul",[a("li",[a("strong",[v._v("BootstrapClassLoader（启动类加载器）")]),v._v("：最顶层的类加载器，由 C++ 实现，通常表示为 "),a("code",[v._v("null")]),v._v("，并且没有父类加载器，主要用来加载 JDK 内部的核心类库以及被 "),a("code",[v._v("-Xbootclasspath")]),v._v(" 参数指定的路径下的所有类。")]),v._v(" "),a("li",[a("strong",[v._v("ExtensionClassLoader（扩展类加载器）")]),v._v("：主要负责加载 "),a("code",[v._v("%JRE_HOME%/lib/ext")]),v._v(" 目录下的 jar 包和类以及被 "),a("code",[v._v("java.ext.dirs")]),v._v(" 系统变量所指定的路径下的所有类。")]),v._v(" "),a("li",[a("strong",[v._v("AppClassLoader（应用程序类加载器）")]),v._v("：面向我们用户的加载器，负责加载当前应用 "),a("code",[v._v("classpath")]),v._v(" 下的所有 jar 包和类。")])]),v._v(" "),a("p",[a("strong",[v._v("类加载器自底向上查找判断类是否被加载，自顶向下尝试加载类。")])]),v._v(" "),a("h4",{attrs:{id:"获取到-classloader-为-null-为什么就是-bootstrapclassloader-加载的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#获取到-classloader-为-null-为什么就是-bootstrapclassloader-加载的"}},[v._v("#")]),v._v(" 获取到 ClassLoader 为 null 为什么就是 BootstrapClassLoader 加载的？")]),v._v(" "),a("p",[a("code",[v._v("BootstrapClassLoader")]),v._v(" 是由 C++ 实现的，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 "),a("code",[v._v("null")]),v._v("。")]),v._v(" "),a("h4",{attrs:{id:"自定义类加载器要怎么做"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义类加载器要怎么做"}},[v._v("#")]),v._v(" 自定义类加载器要怎么做？")]),v._v(" "),a("p",[v._v("继承 "),a("code",[v._v("Java.lang.ClassLoader")]),v._v(" 抽象类，并重写两个重要方法之一：")]),v._v(" "),a("ul",[a("li",[a("code",[v._v("loadClass()")]),v._v("：加载指定二进制名称的类，会打破双亲委派模型。")]),v._v(" "),a("li",[a("code",[v._v("findClass()")]),v._v("：不会打破双亲委派模型，建议使用这个。")])]),v._v(" "),a("h4",{attrs:{id:"类的双亲委派模型是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的双亲委派模型是什么"}},[v._v("#")]),v._v(" 类的双亲委派模型是什么？")]),v._v(" "),a("p",[v._v("各种类加载器之间的层次关系被称为类加载器的双亲委派模型。"),a("br"),v._v("\n双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。"),a("br"),v._v("\n双亲委派模型会自顶向下尝试加载类。")]),v._v(" "),a("h4",{attrs:{id:"类加载器之间的父子关系是怎么实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类加载器之间的父子关系是怎么实现的"}},[v._v("#")]),v._v(" 类加载器之间的父子关系是怎么实现的？")]),v._v(" "),a("p",[v._v("不是通过继承实现的，而是通过组合实现的，在类中引用父加载器的实例来复用父加载器代码。")]),v._v(" "),a("p",[v._v("在面向对象编程中，有一条非常经典的设计原则："),a("strong",[v._v("组合优于继承，多用组合少用继承")]),v._v("。")]),v._v(" "),a("h4",{attrs:{id:"双亲委派模型的执行流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型的执行流程"}},[v._v("#")]),v._v(" 双亲委派模型的执行流程？")]),v._v(" "),a("ol",[a("li",[v._v("在类加载的时候，JVM 会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。")]),v._v(" "),a("li",[v._v("把加载类的请求委派给父加载器去加载("),a("code",[v._v("loadClass()")]),v._v(")，所有的请求最终都会传送到顶层的启动类加载器 "),a("code",[v._v("BootstrapClassLoader")]),v._v(" 中。")]),v._v(" "),a("li",[v._v("父加载器无法完成加载请求时（搜索范围中没有找到所需的类），子加载器才会自己去尝试加载("),a("code",[v._v("findClass()")]),v._v(")。")]),v._v(" "),a("li",[v._v("如果子加载器也无法加载，抛出 "),a("code",[v._v("ClassNotFoundException")]),v._v("。")])]),v._v(" "),a("h4",{attrs:{id:"jvm-判定两个-java-类是否相同的具体规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm-判定两个-java-类是否相同的具体规则"}},[v._v("#")]),v._v(" JVM 判定两个 Java 类是否相同的具体规则？")]),v._v(" "),a("p",[v._v("JVM 不仅要看类的全名是否相同，还要看加载此类的类加载器是否一样。只有两者都相同的情况，才认为两个类是相同的。")]),v._v(" "),a("h4",{attrs:{id:"双亲委派模型的好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型的好处"}},[v._v("#")]),v._v(" 双亲委派模型的好处？")]),v._v(" "),a("p",[v._v("双亲委派模型保证了 Java 程序的稳定运行，可以避免类的重复加载，也保证了 Java 的核心 API 不被篡改。")]),v._v(" "),a("h4",{attrs:{id:"打破双亲委派模型的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#打破双亲委派模型的方法"}},[v._v("#")]),v._v(" 打破双亲委派模型的方法？")]),v._v(" "),a("p",[v._v("自定义类加载器的时候，要打破双亲委派模型，重写 "),a("code",[v._v("loadClass()")]),v._v(" 方法即可。在 "),a("code",[v._v("loadClass()")]),v._v(" 方法中先自己尝试加载这个类，或者按其他方法，具体的规则由我们自己去实现。")]),v._v(" "),a("h4",{attrs:{id:"为什么-spi-需要自定义类加载器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么-spi-需要自定义类加载器"}},[v._v("#")]),v._v(" 为什么 SPI 需要自定义类加载器？")]),v._v(" "),a("p",[v._v("SPI 的接口由 Java 核心库提供，由 "),a("code",[v._v("BootstrapClassLoader")]),v._v(" 加载。但 SPI 实现是由第三方供应商提供的，在程序中是由 "),a("code",[v._v("AppClassLoader")]),v._v(" 或者自定义类加载器加载的。默认情况下，一个类及其依赖类由同一个类加载器加载。所以，加载 SPI 接口的类加载器也会用来加载 SPI 的实现，但 "),a("code",[v._v("BootstrapClassLoader")]),v._v(" 是无法找到 SPI 的实现类的，因为它无法委托给子类加载器去尝试加载。")]),v._v(" "),a("h4",{attrs:{id:"什么是线程上下文类加载器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程上下文类加载器"}},[v._v("#")]),v._v(" 什么是线程上下文类加载器？")]),v._v(" "),a("p",[a("strong",[a("code",[v._v("ThreadContextClassLoader")])]),v._v("：将一个类加载器保存在线程私有数据，与线程绑定，需要时取出使用。如果没有设置，则继承父线程的上下文类加载器。使用这种方式能够破坏 Java 的类加载委托机制，让应用逆向使用类加载器。")])])}),[],!1,null,null,null);a.default=r.exports}}]);