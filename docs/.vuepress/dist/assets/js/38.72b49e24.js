(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{648:function(e,s,r){"use strict";r.r(s);var t=r(18),_=Object(t.a)({},(function(){var e=this,s=e.$createElement,r=e._self._c||s;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h2",{attrs:{id:"redis-持久化机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-持久化机制"}},[e._v("#")]),e._v(" Redis 持久化机制")]),e._v(" "),r("h3",{attrs:{id:"aof-重写"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#aof-重写"}},[e._v("#")]),e._v(" AOF 重写")]),e._v(" "),r("p",[e._v("AOF 重写（rewrite）是一个有歧义的名字，该功能是"),r("strong",[e._v("通过读取数据库中的键值对来实现")]),e._v("，程序"),r("strong",[e._v("无须")]),e._v("对现有 AOF 文件进行任何读写、分析或者写入操作。"),r("br"),e._v("\nAOF 重写触发时机有两种，一种是通过设置AOF文件大小，默认是 64 MB，超过则重写；另一种是设置当前 AOF 大小和上一次重写时 AOF 大小的比值，超过比值则重写。"),r("br"),e._v(" "),r("strong",[e._v("既然 AOF 重写是读取数据库中键值对来实现的，为什么不直接采用 RDB，那样不是会更简单吗？")]),r("br"),e._v("\n这个问题其实也就是 AOF 和 RDB 的优劣势问题，各有优势也各有短板，AOF 主要比 RDB 好的地方就是实时性比较好，数据安全性比较高，可以导出 AOF 文件进行分析调错。")]),e._v(" "),r("h2",{attrs:{id:"redis-事务"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-事务"}},[e._v("#")]),e._v(" Redis 事务")]),e._v(" "),r("p",[e._v("Redis 事务实际上是一系列命令的打包执行，与 MySQL 这些的事务不一样。"),r("br"),e._v("\nRedis 事务不支持原子性，但支持持久性（AOF 和 RDB）。"),r("br"),e._v(" "),r("strong",[e._v("如何解决 Redis 事务的缺陷？")]),e._v(" 可以使用 Lua 脚本，一段 Lua 脚本可以当作一条命令来执行，一段 Lua 脚本的执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被打断（"),r("strong",[e._v("隔离性")]),e._v("）。但是，如果操作失败并不会回滚数据，因此使用 Lua 脚本也不满足原子性。")]),e._v(" "),r("h2",{attrs:{id:"redis-性能优化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-性能优化"}},[e._v("#")]),e._v(" Redis 性能优化")]),e._v(" "),r("ul",[r("li",[e._v("使用批量操作减少网络传输：减少了 Round Trip Time (RTT，往返时间)，即数据在网络上传输的时间；也减少了 发送命令的 socket I/O 成本。")]),e._v(" "),r("li",[e._v("大量 key 集中过期问题：定期删除过期 key 任务需要在主线程中执行，若在这过程有大量 key 过期，会影响请求的响应。解决方法一是给 key 设置随机过期时间；二是开启 lazy-free 延迟释放，让 redis 采用异步方式延迟释放 key 使用的内存，交给子线程处理。")]),e._v(" "),r("li",[e._v("处理 Redis big key：一是分割 big key；二是手动清理；三是采用合适的数据结构。")]),e._v(" "),r("li",[e._v("处理 redis hotkey：一是读写分离；二是使用 Redis 集群，将热点数据分散存储在多个节点上；三是使用二级缓存，将热点数据存放一份到 JVM 本地内存中。")])]),e._v(" "),r("h3",{attrs:{id:"惰性删除-lazy-deletion-和延迟释放-lazy-free-的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#惰性删除-lazy-deletion-和延迟释放-lazy-free-的区别"}},[e._v("#")]),e._v(" 惰性删除（lazy deletion）和延迟释放（lazy free）的区别？")]),e._v(" "),r("p",[e._v('"Lazy Free" 和 "Lazy Deletion" 都是 Redis 中与内存管理和键的过期相关的概念，但它们有不同的含义和用途。')]),e._v(" "),r("ol",[r("li",[r("p",[r("strong",[e._v("Lazy Free（惰性释放）：")])]),e._v(" "),r("ul",[r("li",[e._v('"Lazy Free" 是指 Redis 在内存管理方面的一种策略。')]),e._v(" "),r("li",[e._v('当一个键被删除或过期时，Redis 并不立即释放与该键相关联的内存。相反，它会将这些键的内存标记为 "tombstone"（墓碑），并稍后在内存需要时，通过回收这些标记为 "tombstone" 的内存来进行重用。')]),e._v(" "),r("li",[e._v("这种策略的优势在于避免了频繁的内存分配和释放操作，从而减少了内存碎片的产生，提高了性能。然而，它可能会导致 Redis 的内存占用在键被删除或过期后仍然会有一定时间的增加。")])])]),e._v(" "),r("li",[r("p",[r("strong",[e._v("Lazy Deletion（惰性删除）：")])]),e._v(" "),r("ul",[r("li",[e._v('"Lazy Deletion" 是指 Redis 在处理键的过期时的一种策略。')]),e._v(" "),r("li",[e._v("当一个键过期时，并不会立即将它从数据库中删除。相反，它会等到有客户端请求访问该键时，才会在访问时检查键是否过期，并在需要时删除。")]),e._v(" "),r("li",[e._v("这种策略的优势在于避免了在键过期时产生立即的删除操作，从而减轻了对性能的影响。然而，它可能会导致过期键在数据库中积压，直到有客户端请求访问这些键。")])])])]),e._v(" "),r("p",[e._v('综上所述，"Lazy Free" 主要关注内存管理，通过延迟释放内存来提高性能并减少内存碎片。"Lazy Deletion" 则关注键的过期处理，通过延迟实际删除过期键来减轻性能影响。这两种策略在 Redis 中都是为了优化性能和内存使用而采取的手段。')]),e._v(" "),r("h2",{attrs:{id:"redis-内存碎片"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-内存碎片"}},[e._v("#")]),e._v(" Redis 内存碎片")]),e._v(" "),r("p",[e._v("Redis 内存碎片率计算公式：mem_fragmentation_ratio （内存碎片率）= used_memory_rss (操作系统实际分配给 Redis 的物理内存空间大小)/ used_memory(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)"),r("br"),e._v(" "),r("strong",[e._v("一定不要误认为 used_memory_rss 减去 used_memory 值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。")])]),e._v(" "),r("h2",{attrs:{id:"redis-生产问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redis-生产问题"}},[e._v("#")]),e._v(" Redis 生产问题")]),e._v(" "),r("ul",[r("li",[e._v("缓存穿透：大量请求的 key 不合理，根本不存在于缓存中，也不存在于数据库中。解决方法一是缓存无效 key，二是使用布隆过滤器。"),r("strong",[e._v("布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。")])]),e._v(" "),r("li",[e._v("缓存击穿：请求的 key 对应的是热点数据 ，该数据存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）。解决方法一是设置热点数据永不过期或过期时间较长，二是提前将热点数据存入缓存并设置合理过期时间，三是设置互斥锁保证只有一个请求落到数据库。")]),e._v(" "),r("li",[e._v("缓存雪崩：缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力，比如实例宕机。针对 Redis 服务不可用解决方法一是采用集群避免单机出现问题，二是限流避免同时处理大量请求；针对热点缓存同时失效解决方法一是随机设置不同的过期时间，二是缓存永不失效，三是设置二级缓存。")])])])}),[],!1,null,null,null);s.default=_.exports}}]);