(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{497:function(e,v,_){"use strict";_.r(v);var a=_(8),s=Object(a.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("p",[e._v("项目中 remoting 包就是网络传输模块，其中包含了四个包：")]),e._v(" "),v("ul",[v("li",[e._v("constants：存放一些网络传输模块共用的常量")]),e._v(" "),v("li",[e._v("dto：网络传输的实体类")]),e._v(" "),v("li",[e._v("handler：用于处理 rpc 请求的类")]),e._v(" "),v("li",[e._v("transport：用户网络传输相关的类（真正传输网络请求的地方，提供了 Socket 和 Netty 两种网络传输方法）")])]),e._v(" "),v("h2",{attrs:{id:"网络传输实体类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络传输实体类"}},[e._v("#")]),e._v(" 网络传输实体类")]),e._v(" "),v("p",[e._v("对于请求，无论成功或失败，都要返回一个 rpcResponse 对象，封装处理的结果（响应码、响应信息、响应体等）")]),e._v(" "),v("h2",{attrs:{id:"网络传输相关的类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#网络传输相关的类"}},[e._v("#")]),e._v(" 网络传输相关的类")]),e._v(" "),v("p",[e._v("虽然有 Socket 和 Netty 两种传输方法，但还是先定义了一个发送 RPC 请求的顶层接口 "),v("code",[e._v("RpcRequestTransport")]),e._v("，后续两种方法对接口进行实现即可。这个接口加上了自定义注解 "),v("code",[e._v("@SPI")]),e._v(", 表示它是一个可扩展的接口。")]),e._v(" "),v("h3",{attrs:{id:"补充-spi-知识"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充-spi-知识"}},[e._v("#")]),e._v(" 补充：SPI 知识")]),e._v(" "),v("p",[e._v("一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”")]),e._v(" "),v("ul",[v("li",[e._v("API：当实现方提供了接口和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这种接口和实现都是放在实现方的。")]),e._v(" "),v("li",[e._v("SPI：当接口存在于调用方这边时，由接口调用方确定接口规则，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。")])]),e._v(" "),v("p",[e._v("Java SPI 约定了一个规范，使用步骤如下：")]),e._v(" "),v("ol",[v("li",[e._v("编写一个接口")]),e._v(" "),v("li",[e._v("编写具体实现类")]),e._v(" "),v("li",[e._v("在 "),v("code",[e._v("ClassPath")]),e._v(" 下的 "),v("code",[e._v("META-INF/services")]),e._v(" 目录创建以接口全限定名命名的文件，文件内容为实现类的全限定名，多个实现用换行符分割。")]),e._v(" "),v("li",[e._v("通过 "),v("code",[e._v("ServiceLoader")]),e._v(" 类获取具体实现。")])]),e._v(" "),v("h3",{attrs:{id:"spi-注解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#spi-注解"}},[e._v("#")]),e._v(" "),v("code",[e._v("@SPI")]),e._v(" 注解")]),e._v(" "),v("p",[e._v("项目中 "),v("code",[e._v("@SPI")]),e._v(" 注解的处理参考了 Dubbo 的 SPI 注解处理，在 ExtensionLoader 类中处理的。"),v("strong",[e._v("如何处理的？")])]),e._v(" "),v("p",[e._v("在 Dubbo 中 SPI 的使用规范：")]),e._v(" "),v("ol",[v("li",[e._v("编写接口，接口必须加 "),v("code",[e._v("@SPI")]),e._v(" 注解，代表它是一个可扩展的接口。")]),e._v(" "),v("li",[e._v("编写实现类。")]),e._v(" "),v("li",[e._v("在 ClassPath 下的 "),v("code",[e._v("META-INF/dubbo")]),e._v(" 目录创建以接口全限定名命名的文件，文件内容为 "),v("code",[e._v("Key=Value")]),e._v(" 格式，Key 是扩展点的名称，Value 是扩展点实现类的全限定名。")]),e._v(" "),v("li",[e._v("通过 "),v("code",[e._v("ExtensionLoader")]),e._v(" 类获取扩展点实现。")])]),e._v(" "),v("p",[e._v("Dubbo默认会扫描META-INF/services、META-INF/dubbo、META-INF/dubbo/internal三个目录下的配置，第一个是为了兼容Java SPI，第三个是Dubbo内部使用的扩展点。")]),e._v(" "),v("h2",{attrs:{id:"补充"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[e._v("#")]),e._v(" 补充")]),e._v(" "),v("h3",{attrs:{id:"class-和-getclass-方法有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#class-和-getclass-方法有什么区别"}},[e._v("#")]),e._v(" "),v("code",[e._v(".class")]),e._v(" 和 "),v("code",[e._v("getClass()")]),e._v(" 方法有什么区别？")]),e._v(" "),v("p",[v("code",[e._v("class")]),e._v(" 关键字和 "),v("code",[e._v("getClass()")]),e._v(" 方法都与获取类的 "),v("code",[e._v("Class")]),e._v(" 对象有关，但在使用和上下文中存在一些区别。")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("class")]),e._v(" 关键字："),v("code",[e._v("class")]),e._v(" 关键字是 "),v("code",[e._v("Java")]),e._v(" 的关键字，用于获取编译时的类字面常量。它获取的 "),v("code",[e._v("Class")]),e._v(" 对象是在编译时确定的，表示具体的类类型。")]),e._v(" "),v("li",[v("code",[e._v("getClass()")]),e._v(" 方法："),v("code",[e._v("getClass()")]),e._v(" 是定义在 Object 类中的方法，用于获取对象的运行时类对象，即对象实际所属类的 "),v("code",[e._v("Class")]),e._v(" 对象。它是一个实例方法，可以通过对象调用。这意味着，在多态的情况下，如果对象是一个子类的实例，那么 "),v("code",[e._v("getClass()")]),e._v(" 方法将返回子类的 "),v("code",[e._v("Class")]),e._v(" 对象。"),v("code",[e._v("getClass()")]),e._v(" 方法在运行时根据对象的实际类型确定 "),v("code",[e._v("Class")]),e._v(" 对象，适用于需要在运行时动态获取对象类型的场景，如反射和运行时类型判断。")])]),e._v(" "),v("h2",{attrs:{id:"编码解码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编码解码"}},[e._v("#")]),e._v(" 编码解码")]),e._v(" "),v("h3",{attrs:{id:"lengthfieldbasedframedecoder-类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#lengthfieldbasedframedecoder-类"}},[e._v("#")]),e._v(" "),v("code",[e._v("LengthFieldBasedFrameDecoder")]),e._v(" 类")]),e._v(" "),v("p",[v("code",[e._v("LengthFieldBasedFrameDecoder")]),e._v(" 是 Netty 提供的一个用于解决粘包和拆包问题的解码器。在网络通信中，数据被拆分成一系列的数据包进行传输。当数据包到达接收端时，需要进行拆包操作以还原原始数据。但是由于网络的不确定性，可能出现粘包问题（多个数据包粘在一起）或拆包问题（一个数据包被拆成多个片段）。"),v("br"),e._v(" "),v("code",[e._v("LengthFieldBasedFrameDecoder")]),e._v(" 解码器通过读取数据包的长度字段来解决粘包和拆包问题。它基于长度字段的值将数据包拆分为独立的帧，并将每个帧发送给后续的处理器进行处理。"),v("br"),e._v("\n以下是 "),v("code",[e._v("LengthFieldBasedFrameDecoder")]),e._v(" 的构造函数参数：")]),e._v(" "),v("ul",[v("li",[v("code",[e._v("maxFrameLength")]),e._v(": 数据包的最大长度，超过此长度的数据包将被丢弃。")]),e._v(" "),v("li",[v("code",[e._v("lengthFieldOffset")]),e._v(": 长度字段的偏移量，表示长度字段在数据包中的起始位置，长度字段是跳过指定字节长度的字段。")]),e._v(" "),v("li",[v("code",[e._v("lengthFieldLength")]),e._v(": 长度字段的长度，表示长度字段占用的字节数。")]),e._v(" "),v("li",[v("code",[e._v("lengthAdjustment")]),e._v(": 长度调整值，要添加到长度字段值上的补偿值，用于调整解码时计算的数据包长度，也就是要计算出数据包在长度字段之后还剩下的字节数。")]),e._v(" "),v("li",[v("code",[e._v("initialBytesToStrip")]),e._v(": 需要跳过的字节数，用于跳过长度字段本身。如果需要接收所有 head+body 的数据，则此值为 0；如果仅需接收 body 数据，则需要跳过 head 所占字节数。\n使用 "),v("code",[e._v("LengthFieldBasedFrameDecoder")]),e._v(" 需要将其添加到 Netty 的 "),v("code",[e._v("ChannelPipeline")]),e._v(" 中，以进行解码操作。通常，它会作为第一个处理器添加到 "),v("code",[e._v("pipeline")]),e._v(" 中。")])]),e._v(" "),v("h2",{attrs:{id:"参考博客"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考博客"}},[e._v("#")]),e._v(" 参考博客")]),e._v(" "),v("ul",[v("li",[e._v("https://www.cnblogs.com/luffsama/articles/17219842.html")]),e._v(" "),v("li",[e._v("https://blog.csdn.net/qq_32099833/article/details/121088253")])])])}),[],!1,null,null,null);v.default=s.exports}}]);