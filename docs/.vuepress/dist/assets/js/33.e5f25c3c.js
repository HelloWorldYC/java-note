(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{299:function(t,a,s){t.exports=s.p+"assets/img/成员变量和局部变量的区别.ecdeff42.png"},300:function(t,a,s){t.exports=s.p+"assets/img/方法重写的本质.9485dcb8.png"},452:function(t,a,s){"use strict";s.r(a);var n=s(8),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"成员变量和局部变量的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#成员变量和局部变量的区别"}},[t._v("#")]),t._v(" 成员变量和局部变量的区别")]),t._v(" "),a("div",{attrs:{align:"center"}},[a("img",{attrs:{src:s(299),width:"100%"}})]),t._v(" "),a("h2",{attrs:{id:"键盘录入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#键盘录入"}},[t._v("#")]),t._v(" 键盘录入")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第一套体系：遇到空格、制表符、回车就停止接收，这些符号后面的数据就不会接收了")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("      "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//接收整数")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextDouble")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//接收小数")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("next")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("         "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//接收字符串 ")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//第二套体系：遇到回车才停止")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("nextLine")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("     "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//接收字符串")]),t._v("\n")])])]),a("h2",{attrs:{id:"static"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static"}},[t._v("#")]),t._v(" static")]),t._v(" "),a("ul",[a("li",[t._v("注意事项：\n"),a("ul",[a("li",[t._v("静态方法只能访问静态变量和静态方法")]),t._v(" "),a("li",[t._v("非静态方法可以访问静态变量或者静态方法，也可以访问非静态的成员变量和非静态的成员方法")]),t._v(" "),a("li",[t._v("静态方法中是没有this关键字")])])])]),t._v(" "),a("h2",{attrs:{id:"三种类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三种类"}},[t._v("#")]),t._v(" 三种类")]),t._v(" "),a("ul",[a("li",[t._v("JavaBean类： 用来描述一类事物的类。比如，Student,Teacher,Dog,Cat等")]),t._v(" "),a("li",[t._v("测试类：用来检查其他类是否书写正确，带有main方法的类，是程序的入口")]),t._v(" "),a("li",[t._v("工具类：不是用来描述一类事物的，而是帮我们做一些事情的类。"),a("br"),t._v("\n工具类构造时要：1.类名见名知义；2.私有化构造方法；3.方法定义为静态；")])]),t._v(" "),a("h2",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[t._v("#")]),t._v(" 继承")]),t._v(" "),a("ol",[a("li",[t._v("Java只能单继承：一个类只能继承一个直接父类；")]),t._v(" "),a("li",[t._v("Java不支持多继承、但是支持多层继承。")]),t._v(" "),a("li",[t._v("Java中所有的类都直接或者间接继承于Object类。（即Object类是所有类的原始父类）")]),t._v(" "),a("li",[t._v("子类只能访问父类中非私有的成员。")]),t._v(" "),a("li",[a("strong",[t._v("虚方法表中的成员方法可以被继承，不在表中的成员方法不能被继承")])]),t._v(" "),a("li",[t._v("继承中成员变量访问特点："),a("strong",[t._v("就近原则")]),a("br"),t._v("\n先在局部位置找，本类成员位置找，父类成员位置找，逐级往上")]),t._v(" "),a("li",[t._v("若出现了重名的成员变量：")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//从局部位置开始往上找")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("this")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//从本类成员位置开始往上找")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("super")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("name"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//从父类成员位置开始往上找")]),t._v("\n")])])]),a("p",[t._v("方法重写的本质:"),a("br")]),a("div",{attrs:{align:"left"}},[a("img",{attrs:{src:s(300),width:"100%"}})]),a("p"),t._v(" "),a("h2",{attrs:{id:"代码块"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#代码块"}},[t._v("#")]),t._v(" 代码块")]),t._v(" "),a("ul",[a("li",[t._v("局部代码块(已淘汰)"),a("br"),t._v("\n作用：提前结束变量的生命周期，节省空间")]),t._v(" "),a("li",[t._v("构造代码块（不够灵活）\n"),a("ul",[a("li",[t._v("写在成员位置的代码块")]),t._v(" "),a("li",[t._v("作用：可以把多个构造方法中重复的代码抽取出来")]),t._v(" "),a("li",[t._v("执行时机：再创建本类对象的时候会先执行构造代码块再执行构造方法")])])]),t._v(" "),a("li",[t._v("静态代码块（重点掌握）\n"),a("ul",[a("li",[t._v("格式：static{}")]),t._v(" "),a("li",[t._v("特点：需要通过static关键字修饰，随着类的加载而加载，并且自动触发、只执行一次")]),t._v(" "),a("li",[t._v("作用：数据的初始化")])])])]),t._v(" "),a("h2",{attrs:{id:"多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[t._v("#")]),t._v(" 多态")]),t._v(" "),a("p",[t._v("格式："),a("code",[t._v("父类类型 变量名 = new 子类类型")])]),t._v(" "),a("ul",[a("li",[a("p",[t._v("调用成员变量时："),a("strong",[t._v("编译看左边，运行看左边")]),a("br"),t._v("\n编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。"),a("br"),t._v("\n运行看左边：java运行代码的时候，实际获取的就是左边父类中成员变量的值。")])]),t._v(" "),a("li",[a("p",[t._v("调用成员方法时："),a("strong",[t._v("编译看左边，运行看右边")]),a("br"),t._v("\n编译看左边：javac编译代码的时候，会看左边的父类中有没有这个变量，如果有，编译成功，如果没有编译失败。\n运行看右边：java运行代码的时候，实际上运行的是子类中的方法。")])]),t._v(" "),a("li",[a("p",[t._v("能调用哪些方法，由引用类型决定，具体执行情况，由实际内存对象类型决定")])]),t._v(" "),a("li",[a("p",[t._v("java执行方法时，会根据引用的类型得到相应的方法，如果不存在编译时会报错，真正执行时，会动态去匹配，如果真正的对象是子类的话，且此方法在子类中被覆盖的话，就会执行子类方法。"),a("br"),t._v("\njava类型匹配时，如果不能匹配的话就做向上类型转换，转换为父类，直到能够匹配为止，若一直不能匹配在编译时会报错")])])]),t._v(" "),a("h2",{attrs:{id:"接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("JDK7以前")]),t._v("：接口中只能定义抽象方法。")]),t._v(" "),a("li",[a("strong",[t._v("JDK8的新特性")]),t._v("：接口中可以定义有方法体的方法。（默认方法、静态方法）")]),t._v(" "),a("li",[a("strong",[t._v("JDK9的新特性")]),t._v("：接口中可以定义私有方法。")])]),t._v(" "),a("h3",{attrs:{id:"jdk8以后接口中新增的默认方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdk8以后接口中新增的默认方法"}},[t._v("#")]),t._v(" JDK8以后接口中新增的默认方法")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("允许在接口中定义默认方法，需要使用关键字default修饰。"),a("br"),t._v("\n作用：解决接口升级的问题")])]),t._v(" "),a("li",[a("p",[t._v("接口中"),a("strong",[t._v("默认方法")]),t._v("的定义格式：")]),t._v(" "),a("ul",[a("li",[t._v("格式："),a("code",[t._v("public default 返回值类型 方法名（参数列表）{}")])]),t._v(" "),a("li",[t._v("范例："),a("code",[t._v("public default void show() {}")])])])]),t._v(" "),a("li",[a("p",[t._v("接口中默认方法的注意事项：")]),t._v(" "),a("ul",[a("li",[t._v("默认方法不是抽象方法，所以不强制被重写。但是如果被重写，重写的时候去掉default关键字。")]),t._v(" "),a("li",[t._v("public 可以省略，default 不能省略。")]),t._v(" "),a("li",[t._v("如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写。")])])])]),t._v(" "),a("h3",{attrs:{id:"jdk8以后接口中新增的静态方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdk8以后接口中新增的静态方法"}},[t._v("#")]),t._v(" JDK8以后接口中新增的静态方法")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("允许在接口中定义静态方法，需要用 static 修饰")])]),t._v(" "),a("li",[a("p",[t._v("接口中"),a("strong",[t._v("静态方法")]),t._v("的定义格式：")]),t._v(" "),a("ul",[a("li",[t._v("格式："),a("code",[t._v("public static 返回值类型 方法名（参数列表）")])]),t._v(" "),a("li",[t._v("范例："),a("code",[t._v("public static void show(){}")])])])]),t._v(" "),a("li",[a("p",[t._v("接口中静态方法的注意事项：")]),t._v(" "),a("ul",[a("li",[t._v("静态方法只能通过接口名调用，不能通过实现类名或者对象名调用")]),t._v(" "),a("li",[t._v("public 可以省略，static 不能省略")])])])]),t._v(" "),a("h3",{attrs:{id:"jdk9以后接口中新增的私有方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdk9以后接口中新增的私有方法"}},[t._v("#")]),t._v(" JDK9以后接口中新增的私有方法")]),t._v(" "),a("p",[a("strong",[t._v("此方法只为接口提供服务，不需要外类访问")])]),t._v(" "),a("ul",[a("li",[t._v("接口中私有方法的定义格式：\n"),a("ul",[a("li",[t._v("格式1："),a("code",[t._v("private 返回值类型 方法名（参数列表）{}")]),a("br"),t._v("\n范例1："),a("code",[t._v("private void show(){} //普通的私有方法，给默认方法服务的")])]),t._v(" "),a("li",[t._v("格式2："),a("code",[t._v("private static 返回值类型 方法名 （参数列表）{}")]),a("br"),t._v("\n范例2："),a("code",[t._v("private static void method(){} //静态的私有方法，给静态方法服务的")])])])])]),t._v(" "),a("h3",{attrs:{id:"接口的应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口的应用"}},[t._v("#")]),t._v(" 接口的应用")]),t._v(" "),a("ul",[a("li",[t._v("接口代表规则，是行为的抽象。想要让哪个类拥有一个行为，就让这个类实现对应的接口就可以了。")]),t._v(" "),a("li",[t._v("当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态。")])]),t._v(" "),a("h2",{attrs:{id:"内部类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内部类"}},[t._v("#")]),t._v(" 内部类")]),t._v(" "),a("p",[t._v("类的五大成员：属性、方法、构造方法、代码块、内部类"),a("br"),t._v("\n内部类的访问特点：")]),t._v(" "),a("ul",[a("li",[t._v("内部类可以直接访问外部类的成员，包括私有")]),t._v(" "),a("li",[t._v("外部类要访问内部类的成员，必须创建对象")])]),t._v(" "),a("h2",{attrs:{id:"常用api"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用api"}},[t._v("#")]),t._v(" 常用API")]),t._v(" "),a("h3",{attrs:{id:"system"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#system"}},[t._v("#")]),t._v(" System")]),t._v(" "),a("ul",[a("li",[t._v("也是一个工具类，提供了一些与系统相关的方法")]),t._v(" "),a("li",[t._v("时间原点：1970年1月1日 0:0:0，我国在东八区，有8小时时差，因此原点为1970年1月1日 8:0:0")]),t._v(" "),a("li",[t._v("1秒 = 1000 毫秒")]),t._v(" "),a("li",[t._v("常见方法\n"),a("ul",[a("li",[t._v("exit：停止虚拟机")]),t._v(" "),a("li",[t._v("currentTimeMillis：过去当前时间的毫秒值")]),t._v(" "),a("li",[t._v("arraycopy：拷贝数组")])])])]),t._v(" "),a("h3",{attrs:{id:"runtime"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#runtime"}},[t._v("#")]),t._v(" Runtime")]),t._v(" "),a("p",[t._v("表示当前虚拟机的运行环境，是一个类但不能直接建立对象，要用 getRuntime 获取.")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Runtime")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getRuntime")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//当前系统的运行环境对象")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("exit")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" status"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("       "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//停止虚拟机")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("availableProcessors")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//获得CPU的线程数")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("maxMemory")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//JVM能从系统钟获取总内存大小（单位byte）")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("totalMemory")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("          "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//JVM已经从系统中获取总内存大小（单位byte）")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("long")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("freeMemory")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("           "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//JVM剩余内存大小（单位byte）")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Process")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("exec")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" command"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//运行 cmd 命令")]),t._v("\n")])])]),a("h2",{attrs:{id:"lambda表达式-jdk8后"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lambda表达式-jdk8后"}},[t._v("#")]),t._v(" Lambda表达式（JDK8后）")]),t._v(" "),a("ul",[a("li",[t._v("函数式编程（Functional programming）是一种思想特点，忽略面向对象的复杂语法，强调做什么，而不是谁去做。Lambda表达式就是函数式思想的体现。")]),t._v(" "),a("li",[t._v("面向对象：先找对象，让对象做事情")]),t._v(" "),a("li",[t._v("注意点：\n"),a("ul",[a("li",[t._v("Lambda表达式可以用来简化匿名内部类的书写")]),t._v(" "),a("li",[t._v("Lambda表达式只能简化函数式接口的匿名内部类的写法")]),t._v(" "),a("li",[t._v("函数式接口：有且仅有一个抽象方法的接口叫做函数式接口，接口上方可以加@FunctionalInterface注解")])])]),t._v(" "),a("li",[t._v("Lambda的省略规则：\n"),a("ul",[a("li",[t._v("1.参数类型可以省略不写")]),t._v(" "),a("li",[t._v("2.如果只有一个参数，参数类型可以省略，同时()也可以省略")]),t._v(" "),a("li",[t._v("3.如果Lambda表达式的方法体只有一行，大括号，分号，return可以省略不写，需要同时省略。")])])])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("->")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("h2",{attrs:{id:"泛型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[t._v("#")]),t._v(" 泛型")]),t._v(" "),a("p",[t._v("泛型：是JDK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。"),a("br"),t._v(" "),a("strong",[t._v("泛型的格式")]),t._v("：<数据类型>"),a("br"),t._v("\n注意：泛型只能支持引用数据类型。"),a("br"),t._v("\n使用泛型的原因：如果我们没有给集合指定类型，默认认为所有的数据类型都是Object类型，此时可以往集合中添加任意的数据类型。但带来一个坏处：我们在获取数据的时候，无法使用他的特有行为。"),a("br"),t._v("\n扩展知识点：Java中的泛型是伪泛型")]),t._v(" "),a("h3",{attrs:{id:"泛型的好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型的好处"}},[t._v("#")]),t._v(" 泛型的好处")]),t._v(" "),a("ul",[a("li",[t._v("统一数据类型")]),t._v(" "),a("li",[t._v("把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为在编译阶段类型就能确定下来。")])]),t._v(" "),a("h3",{attrs:{id:"泛型的细节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型的细节"}},[t._v("#")]),t._v(" 泛型的细节")]),t._v(" "),a("ul",[a("li",[t._v("泛型中不能写基本数据类型")]),t._v(" "),a("li",[t._v("指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型")]),t._v(" "),a("li",[t._v("如果不写泛型，类型默认是 "),a("strong",[t._v("Object")])])]),t._v(" "),a("h3",{attrs:{id:"泛型类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型类"}},[t._v("#")]),t._v(" 泛型类")]),t._v(" "),a("p",[t._v("如果一个类不确定类型，那么这个类就可以定义为泛型类，在类名后面定义泛型。")]),t._v(" "),a("h3",{attrs:{id:"泛型方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型方法"}},[t._v("#")]),t._v(" 泛型方法")]),t._v(" "),a("p",[t._v("方法中形参类型不确定时，")]),t._v(" "),a("ul",[a("li",[a("ol",[a("li",[t._v("可以使用类名后面定义的泛型 "),a("code",[t._v("<E>")])])])]),t._v(" "),a("li",[a("ol",{attrs:{start:"2"}},[a("li",[t._v("在方法申明上定义自己的泛型")])])])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("修饰符 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("类型"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),t._v(" 返回值类型 方法名"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("类型 变量名"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("show")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("T")]),t._v(" t"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//此处可以理解为变量，但是不是用来记录数据的，而是记录类型的，可以写成：T、E、K、V等")]),t._v("\n")])])]),a("h3",{attrs:{id:"泛型接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型接口"}},[t._v("#")]),t._v(" 泛型接口")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("修饰符 "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" 接口名"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("类型"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("interface")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("E")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("泛型接口的两种使用方式：")]),t._v(" "),a("ol",[a("li",[t._v("实现类给出具体的类型")]),t._v(" "),a("li",[t._v("实现类延续泛型，创建实现类对象时再确定类型")])]),t._v(" "),a("h3",{attrs:{id:"泛型的继承和通配符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#泛型的继承和通配符"}},[t._v("#")]),t._v(" 泛型的继承和通配符")]),t._v(" "),a("ul",[a("li",[t._v("泛型不具备继承性（不能通过多态传递子类对象），但是数据具备继承性（指定泛型的具体类型后，传递数据时，可以传入该类类型或者其子类类型）")])]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("method")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Animal")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//在调用method方法时只能是Animal类型，不能传递其子类，因为泛型不具备继承性")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Ye")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nlist1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Ye")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//数据具备继承性")]),t._v("\nlist1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Fu")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nlist1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Zi")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("ul",[a("li",[t._v("泛型的通配符：\n"),a("ul",[a("li",[t._v("? 也表示不确定的类型，可以进行类型范围的限定")]),t._v(" "),a("li",[t._v("? extends E ：表示可以传递E或者E的所有的子类类型")]),t._v(" "),a("li",[t._v("? super E ：表示可以传递E或者E所有的父类类型")]),t._v(" "),a("li",[t._v("应用场景：如果在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以使用泛型的通配符。")])])])])])}),[],!1,null,null,null);a.default=e.exports}}]);