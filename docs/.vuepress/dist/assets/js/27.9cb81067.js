(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{461:function(t,r,a){t.exports=a.p+"assets/img/RPC框架组成.a9f85966.png"},660:function(t,r,a){"use strict";a.r(r);var s=a(18),v=Object(s.a)({},(function(){var t=this,r=t.$createElement,s=t._self._c||r;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"什么是-rpc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-rpc"}},[t._v("#")]),t._v(" 什么是 RPC？")]),t._v(" "),s("p",[t._v("RPC (Remote Procedure Call)，即远程过程调用，实现跟本地调用一样的效果，客户端通过发送调用方法名称及参数等给服务端，等客户端处理后返回结果到调用处。中间还需要一个媒介作为统筹管理的，给服务端注册服务。")]),t._v(" "),s("h2",{attrs:{id:"rpc-有哪些组成部分"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rpc-有哪些组成部分"}},[t._v("#")]),t._v(" RPC 有哪些组成部分？")]),t._v(" "),s("div",{attrs:{align:"center"}},[s("img",{attrs:{src:a(461),width:"100%"}})]),t._v(" "),s("ul",[s("li",[t._v("注册中心：负责服务地址的注册与查找，存储着服务名称以及对应的服务地址（服务端地址）。")]),t._v(" "),s("li",[t._v("服务端：提供远程方法的一端。")]),t._v(" "),s("li",[t._v("服务端 Stub：这个不是代理类，负责将传输过来的方法、参数反序列化，调用服务端方法，将调用结果序列化，通过网络传输到客户端。")]),t._v(" "),s("li",[t._v("客户端：调用远程方法的一端。")]),t._v(" "),s("li",[t._v("客户端 Stub：其实是一个代理类，负责将方法、参数等序列化，通过网络传输到服务端，以及将返回结果反序列化，返回到调用处。")]),t._v(" "),s("li",[t._v("监控中心：负责统计服务的调用次数和调用时间。")])]),t._v(" "),s("h2",{attrs:{id:"为什么-rpc-中要用到动态代理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么-rpc-中要用到动态代理"}},[t._v("#")]),t._v(" 为什么 RPC 中要用到动态代理？")]),t._v(" "),s("p",[t._v("因为我们在调用远程方法的时候，不需要关心远程方法调用的细节比如网络传输，所以要屏蔽掉远程方法调用的底层细节。当我们在调用远程方法的时候，实际会通过代理对象来传输网络请求（client stub）。")]),t._v(" "),s("h2",{attrs:{id:"为什么不推荐使用-jdk-自带的序列化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么不推荐使用-jdk-自带的序列化"}},[t._v("#")]),t._v(" 为什么不推荐使用 JDK 自带的序列化？")]),t._v(" "),s("p",[t._v("主要有以下几个原因：")]),t._v(" "),s("ul",[s("li",[t._v("不支持跨语言调用：如果调用的是其他语言开发的服务的时候就不支持了。")]),t._v(" "),s("li",[t._v("性能差：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。")]),t._v(" "),s("li",[t._v("存在安全问题：序列化和反序列化本身并不存在问题。但当输入的反序列化代码的数据可被用户控制，那么攻击者可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的恶意代码。")])]),t._v(" "),s("h2",{attrs:{id:"为什么要采用-kyro-作为序列化方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要采用-kyro-作为序列化方式"}},[t._v("#")]),t._v(" 为什么要采用 kyro 作为序列化方式？")]),t._v(" "),s("p",[t._v("因为 JDK 自带的序列化方式不太友好，protobuf 和 protostuff 虽然性能优秀，也支持跨语言，但使用较为繁琐。而 kyro 则是专门针对 Java 语言序列化的，并且性能非常好。项目尚不需要跨语言，所以使用 kyro 比较方便一些。")]),t._v(" "),s("h3",{attrs:{id:"参考博客"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考博客"}},[t._v("#")]),t._v(" 参考博客")]),t._v(" "),s("ul",[s("li",[t._v("https://www.cnblogs.com/luffsama/articles/17219842.html")])])])}),[],!1,null,null,null);r.default=v.exports}}]);