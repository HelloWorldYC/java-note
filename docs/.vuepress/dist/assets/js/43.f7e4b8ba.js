(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{459:function(o,_,e){"use strict";e.r(_);var v=e(4),l=Object(v.a)({},(function(){var o=this,_=o._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[_("h2",{attrs:{id:"慢查询日志"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#慢查询日志"}},[o._v("#")]),o._v(" 慢查询日志")]),o._v(" "),_("p",[o._v("MySQL 慢查询日志（Slow Query Log）是 MySQL 数据库引擎提供的一种功能，用于记录执行时间超过阈值的查询语句。它可以帮助开发人员和数据库管理员识别和优化执行时间较长的查询，从而提高数据库的性能和响应时间。")]),o._v(" "),_("p",[o._v("慢查询日志记录了执行时间超过预设阈值的查询语句，这个阈值通常以秒为单位设定。如果一个查询的执行时间超过了设置的阈值，该查询语句的相关信息会被记录到慢查询日志中，包括查询语句本身、执行时间、开始时间、用户、主机等信息。")]),o._v(" "),_("p",[o._v("通过分析慢查询日志，你可以：")]),o._v(" "),_("ol",[_("li",[_("strong",[o._v("发现性能问题：")]),o._v(" 慢查询日志可以帮助你发现数据库中执行时间较长的查询，从而识别潜在的性能问题和瓶颈。")]),o._v(" "),_("li",[_("strong",[o._v("优化查询：")]),o._v(" 通过分析慢查询日志，你可以了解哪些查询语句执行时间较长，从而有针对性地对这些查询进行优化，例如通过优化查询语句、创建索引或重新设计数据模型等方式来提高性能。")]),o._v(" "),_("li",[_("strong",[o._v("监控数据库性能：")]),o._v(" 定期分析慢查询日志可以帮助你监控数据库的性能变化，及时发现和解决潜在的性能问题。")])]),o._v(" "),_("p",[o._v("要启用慢查询日志，你需要在 MySQL 的配置文件中进行相应的配置，主要包括以下步骤：")]),o._v(" "),_("ol",[_("li",[o._v("设置 "),_("code",[o._v("slow_query_log")]),o._v(" 参数为 "),_("code",[o._v("ON")]),o._v("，启用慢查询日志功能。")]),o._v(" "),_("li",[o._v("设置 "),_("code",[o._v("long_query_time")]),o._v(" 参数，指定查询执行时间的阈值。只有执行时间超过这个阈值的查询会被记录到慢查询日志中。")]),o._v(" "),_("li",[o._v("可选地，设置 "),_("code",[o._v("log_queries_not_using_indexes")]),o._v(" 参数为 "),_("code",[o._v("ON")]),o._v("，以记录未使用索引的查询。")])]),o._v(" "),_("p",[o._v("一旦慢查询日志被启用，MySQL 就会自动记录满足条件的查询语句。你可以定期检查慢查询日志文件，从中获取有关查询性能的信息，并采取适当的优化措施。")]),o._v(" "),_("h2",{attrs:{id:"mysql-数据读写"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql-数据读写"}},[o._v("#")]),o._v(" MySQL 数据读写")]),o._v(" "),_("p",[o._v("MySQL 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 Buffer Pool 中。")]),o._v(" "),_("p",[o._v("后续的查询都是先从 Buffer Pool 中找，没有命中再去硬盘加载，减少硬盘 IO 开销，提升性能。")]),o._v(" "),_("p",[o._v("更新表数据的时候，也是如此，发现 Buffer Pool 里存在要更新的数据，就直接在 Buffer Pool 里更新。")]),o._v(" "),_("p",[o._v("然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（redo log buffer）里，接着刷盘到 redo log 文件里。")]),o._v(" "),_("blockquote",[_("p",[o._v("小贴士：每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成")])]),o._v(" "),_("h2",{attrs:{id:"为什么说redo-log在事务执行过程中可以不断写入-而binlog只有在提交事务时才写入"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么说redo-log在事务执行过程中可以不断写入-而binlog只有在提交事务时才写入"}},[o._v("#")]),o._v(" 为什么说redo log在事务执行过程中可以不断写入，而binlog只有在提交事务时才写入？")]),o._v(" "),_("p",[o._v("首先明确一下两个日志的执行过程：(刷盘时间根据设置)")]),o._v(" "),_("ul",[_("li",[o._v("redolog：redo log buffer -> page cache -> redo log")]),o._v(" "),_("li",[o._v("binlog：binlog cache -> page cache -> binlog")])]),o._v(" "),_("p",[o._v("对于事务执行过程中，个人是这么理解的："),_("br"),o._v("\n数据更新前会先将更新操作写入 binlog cache，而更新了数据后写入 redo log buffer。"),_("br"),o._v("\n由于 redo log buffer 除了设置好的刷盘之外，后台会有线程每隔 1 秒将 redo log buffer 写入 page cache，再刷到磁盘 redo log 中，因此理解 "),_("strong",[o._v("redo log 在事务执行过程中可以不断写入")]),o._v("。"),_("br"),o._v("\n而 binlog 需要一次性写入的，在事务过程中是写入 binlog cache，在事务提交后才写入 page cache 中，由刷盘策略决定何时刷盘，因此认为 "),_("strong",[o._v("binlog 只有在提交事务的时候才写入")]),o._v("。"),_("br"),o._v("\n正是由于两者在事务过程写入的操作不一致（实际写到 page cache），因此需要两阶段提交来实现一致。")]),o._v(" "),_("h2",{attrs:{id:"参考文献"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[o._v("#")]),o._v(" 参考文献")]),o._v(" "),_("ul",[_("li",[o._v("https://javaguide.cn/database/mysql/mysql-logs.html#redo-log")])])])}),[],!1,null,null,null);_.default=l.exports}}]);