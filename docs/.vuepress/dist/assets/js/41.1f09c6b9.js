(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{456:function(t,a,l){"use strict";l.r(a);var v=l(8),_=Object(v.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"编程常识"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#编程常识"}},[t._v("#")]),t._v(" 编程常识")]),t._v(" "),a("h3",{attrs:{id:"t-制表符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#t-制表符"}},[t._v("#")]),t._v(" \\t 制表符")]),t._v(" "),a("ul",[a("li",[t._v("作用：在打印的时候，把前面字符串的长度补齐到8，或者8的整数倍。最少补1个空格，最多补8个空格。")])]),t._v(" "),a("h3",{attrs:{id:"null"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#null"}},[t._v("#")]),t._v(" null")]),t._v(" "),a("ul",[a("li",[t._v("在打印时不能直接打印，要以字符串的形式打印。")])]),t._v(" "),a("h3",{attrs:{id:"任意进制转十进制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任意进制转十进制"}},[t._v("#")]),t._v(" 任意进制转十进制")]),t._v(" "),a("ul",[a("li",[t._v("公式：系数*基数的权次幂 相加\n"),a("ul",[a("li",[t._v("系数：当前的进制数")]),t._v(" "),a("li",[t._v("基数：当前进制数")]),t._v(" "),a("li",[t._v("权：从右往左，依次为 0 1 2 3 4 5 …")])])])]),t._v(" "),a("h3",{attrs:{id:"十进制转任意进制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十进制转任意进制"}},[t._v("#")]),t._v(" 十进制转任意进制")]),t._v(" "),a("ul",[a("li",[t._v("除基取余法\n"),a("ul",[a("li",[t._v("不断地除以基数（几进制，基数就是几）得到余数，直到商为0，再将余数倒着拼起来即可。")])])])]),t._v(" "),a("h3",{attrs:{id:"float的数值范围比long大"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#float的数值范围比long大"}},[t._v("#")]),t._v(" float的数值范围比long大")]),t._v(" "),a("ul",[a("li",[t._v("原因：float类型数字在计算机中用4个字节存储。遵循IEEE-754格式标准：         一个浮点数有2部分组成：底数m和指数e  底数部分 使用二进制数来表示此浮点数的实际值 指数部分 占用8bit的二进制数，可表示数值范围为0-255  但是指数可正可负，所以，IEEE规定，此处算出的次方必须减去127才是真正的指数。         所以，float类型的指数可从-126到128  底数部分实际是占用24bit的一个值，但是最高位始终为1，所以，最高位省去不存储，在存储中占23bit         科学计数法。  格式： "),a("code",[t._v("SEEE EEEE EMMM MMMM MMMM MMMM MMMM MMMM")]),t._v(" S表示浮点数正负     E指数加上127后的值得二进制数据 M底数  举例： 17.625在内存中的存储  首先要把17.625换算成二进制：10001.101          整数部分，除以2，直到商为0，余数反转。         小数部分，乘以2，直到乘位0，进位顺序取。  在将10001.101右移，直到小数点前只剩1位：         1.0001101 * 2^4 因为右移动了四位  这个时候，我们的底数和指数就出来了 底数：因为小数点前必为1，所以IEEE规定只记录小数点后的就好。所以，此处的底数为：0001101 指数：实际为4，必须加上127(转出的时候，减去127)，所以为131。也就是10000011 符号部分是整数，所以是0 综上所述，17.625在内存中的存储格式是： 01000001 10001101 00000000 00000000")])]),t._v(" "),a("h3",{attrs:{id:"原码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#原码"}},[t._v("#")]),t._v(" 原码")]),t._v(" "),a("ul",[a("li",[t._v("原码：十进制数据的二进制表现形式，最左边是符号位，0为正，1为负。")])]),t._v(" "),a("h3",{attrs:{id:"反码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#反码"}},[t._v("#")]),t._v(" 反码")]),t._v(" "),a("ul",[a("li",[t._v("目的：为了解决原码不能计算负数的问题而出现的。")]),t._v(" "),a("li",[t._v("计算规则：正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反，0变1，1变0。")]),t._v(" "),a("li",[t._v("弊端：负数运算时，如果结果不跨0，没有任何问题，但是如果结果跨0，跟实际结果会有1的偏差。")])]),t._v(" "),a("h3",{attrs:{id:"补码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#补码"}},[t._v("#")]),t._v(" 补码")]),t._v(" "),a("ul",[a("li",[t._v("目的：为了解决负数计算时跨0的问题而出现的。")]),t._v(" "),a("li",[t._v("计算规则：正数的补码是其本身，负数的补码是在其反码的基础上+1。另外，补码还能多记录一个特殊的值-128，该数据在1个字节下，没有原码和反码（因此一个字节的取值范围为-128~127）。")]),t._v(" "),a("li",[t._v("注意点：计算机中的存储和计算都是以补码的形式进行的。因为CPU只会做加法运算，数的补码形式可以用加法实现减法运算。")])])])}),[],!1,null,null,null);a.default=_.exports}}]);