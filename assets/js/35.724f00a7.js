(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{422:function(r,s,t){r.exports=t.p+"assets/img/docker与虚拟机对比图.70220dae.png"},423:function(r,s,t){r.exports=t.p+"assets/img/容器与虚拟机总结.77d970e1.png"},481:function(r,s,t){"use strict";t.r(s);var v=t(4),_=Object(v.a)({},(function(){var r=this,s=r._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[s("h2",{attrs:{id:"容器简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器简介"}},[r._v("#")]),r._v(" 容器简介")]),r._v(" "),s("h3",{attrs:{id:"什么是容器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是容器"}},[r._v("#")]),r._v(" 什么是容器？")]),r._v(" "),s("p",[s("strong",[r._v("一句话概括容器：容器就是将软件打包成标准化单元，以用于开发、交付和部署。")])]),r._v(" "),s("ul",[s("li",[s("strong",[r._v("容器镜像是轻量的、可执行的独立软件包")]),r._v("，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。")]),r._v(" "),s("li",[s("strong",[r._v("容器化软件适用于基于 Linux 和 Windows 的应用，在任何环境中都能够始终如一地运行。")])]),r._v(" "),s("li",[r._v("**容器赋予了软件独立性，**使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。")])]),r._v(" "),s("h3",{attrs:{id:"虚拟机和容器区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机和容器区别"}},[r._v("#")]),r._v(" 虚拟机和容器区别")]),r._v(" "),s("p",[s("strong",[r._v("容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源的。虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。")])]),r._v(" "),s("h2",{attrs:{id:"docker-简介"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-简介"}},[r._v("#")]),r._v(" Docker 简介")]),r._v(" "),s("h3",{attrs:{id:"什么是-docker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是-docker"}},[r._v("#")]),r._v(" 什么是 Docker？")]),r._v(" "),s("ul",[s("li",[s("strong",[r._v("Docker 是世界领先的软件容器平台。")])]),r._v(" "),s("li",[r._v("Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核 提供的 CGroup 功能和 namespace 来实现的，以及 AUFS 类的 UnionFS 等技术，"),s("strong",[r._v("对进程进行封装隔离，属于操作系统层面的虚拟化技术")]),r._v("。 由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。")]),r._v(" "),s("li",[s("strong",[r._v("Docker 能够自动执行重复性任务，例如搭建和配置开发环境，从而解放了开发人员以便他们专注在真正重要的事情上：构建杰出的软件。")])]),r._v(" "),s("li",[s("strong",[r._v("用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。")])])]),r._v(" "),s("h3",{attrs:{id:"docker-思想"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-思想"}},[r._v("#")]),r._v(" Docker 思想")]),r._v(" "),s("ul",[s("li",[s("strong",[r._v("集装箱")])]),r._v(" "),s("li",[s("strong",[r._v("标准化")]),r._v("： ① 运输方式 ② 存储方式 ③ API 接口")]),r._v(" "),s("li",[s("strong",[r._v("隔离")])])]),r._v(" "),s("h3",{attrs:{id:"docker-容器的特点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-容器的特点"}},[r._v("#")]),r._v(" Docker 容器的特点")]),r._v(" "),s("p",[r._v("Docker容器具有以下特点：")]),r._v(" "),s("ol",[s("li",[s("strong",[r._v("轻量性")]),r._v("：Docker 容器是轻量级的，与传统虚拟机相比，它们只包含应用程序及其运行所需的依赖项，而不需要额外的操作系统。这使得容器的启动和停止速度非常快。")]),r._v(" "),s("li",[s("strong",[r._v("可移植性")]),r._v("：Docker 容器是可移植的，因为它们在任何支持 Docker 的环境中都可以运行，无论是在开发人员的本地机器上还是在云服务器上。容器化的应用程序在不同的环境中具有一致的行为，避免了因环境差异导致的部署问题。")]),r._v(" "),s("li",[s("strong",[r._v("隔离性")]),r._v("：Docker 容器提供了一定程度的隔离性，使得不同的应用程序可以在同一台主机上独立运行，互不干扰。"),s("strong",[r._v("每个容器都有自己的文件系统、进程空间和网络接口")]),r._v("，这种隔离性确保了应用程序的安全性和可靠性。")]),r._v(" "),s("li",[s("strong",[r._v("可扩展性")]),r._v("：使用 Docker 容器，可以轻松地扩展应用程序的实例数量，通过创建多个容器实例来处理负载。容器可以快速启动和停止，使得应对不断变化的负载需求变得更加容易。")]),r._v(" "),s("li",[s("strong",[r._v("管理和部署简便")]),r._v("：Docker 提供了一套强大的工具和命令行接口，使得容器的管理、部署和监控变得简单而灵活。开发人员可以使用 Docker 镜像和容器来构建、测试和交付应用程序。")]),r._v(" "),s("li",[s("strong",[r._v("可复制性")]),r._v("：Docker 容器使用基于镜像的构建方式，通过 Docker 镜像可以轻松复制和分发应用程序。镜像包含了应用程序及其依赖项的完整快照，使得应用程序的部署变得可重复和可靠。")]),r._v(" "),s("li",[s("strong",[r._v("安全性")]),r._v(": Docker 赋予应用的隔离性不仅限于彼此隔离，还独立于底层的基础设施。Docker 默认提供最强的隔离，因此应用出现问题，也只是单个容器的问题，而不会波及到整台机器。")])]),r._v(" "),s("h3",{attrs:{id:"为什么说-docker-不需要额外的操作系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么说-docker-不需要额外的操作系统"}},[r._v("#")]),r._v(" 为什么说 Docker 不需要额外的操作系统？")]),r._v(" "),s("p",[r._v("传统虚拟机通常需要为每个虚拟机分配独立的操作系统，并在每个虚拟机中运行一个完整的操作系统实例。这导致了资源的冗余使用和较高的资源消耗。"),s("br"),r._v("\n相比传统的虚拟机技术，Docker 使用了 Linux 内核的命名空间（Namespace）和控制组（cgroup）等特性，"),s("strong",[r._v("实现了对进程、文件系统、网络等资源的隔离")]),r._v("。"),s("strong",[r._v("容器共享宿主机的操作系统内核，但每个容器都有自己的文件系统、进程空间和网络接口，使得它们看起来像独立的操作系统实例")]),r._v("。"),s("br"),r._v("\n容器镜像中包含了应用程序及其依赖项的文件系统快照，包括操作系统的基本组件和库。"),s("strong",[r._v("容器在运行时只需要加载这个文件系统快照，而不需要额外的完整操作系统")]),r._v("。"),s("br"),r._v("\n这种轻量级的容器化技术使得 Docker 容器的启动速度非常快，并且占用的资源更少。它提供了与传统虚拟机相似的隔离性和可移植性，但具有更低的开销和更高的性能。")]),r._v(" "),s("blockquote",[s("p",[r._v("为了实现在不同操作系统上运行容器，Docker 提供了针对特定操作系统的版本和解决方案。例如，对于 Linux 操作系统，Docker 使用基于 Linux 内核的命名空间、控制组和文件系统技术，实现了 Linux 容器。对于 Windows 操作系统，Docker 使用了 Windows 容器技术，如基于 Hyper-V 的容器。这些虚拟化技术允许 Docker 在宿主机操作系统之上创建和管理容器，实现容器与宿主机操作系统的隔离。")])]),r._v(" "),s("h3",{attrs:{id:"为什么要用-docker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要用-docker"}},[r._v("#")]),r._v(" 为什么要用 Docker？")]),r._v(" "),s("ul",[s("li",[s("strong",[r._v("Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 “这段代码在我机器上没问题啊” 这类问题；——一致的运行环境")])]),r._v(" "),s("li",[s("strong",[r._v("可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。——更快速的启动时间")])]),r._v(" "),s("li",[s("strong",[r._v("避免公用的服务器，资源会容易受到其他用户的影响。——隔离性")])]),r._v(" "),s("li",[s("strong",[r._v("善于处理集中爆发的服务器使用压力；——弹性伸缩，快速扩展")])]),r._v(" "),s("li",[s("strong",[r._v("可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。——迁移方便")])]),r._v(" "),s("li",[s("strong",[r._v("使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。——持续交付和部署")])])]),r._v(" "),s("h2",{attrs:{id:"容器-vs-虚拟机"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器-vs-虚拟机"}},[r._v("#")]),r._v(" 容器 VS 虚拟机")]),r._v(" "),s("p",[s("strong",[r._v("容器和虚拟机具有相似的资源隔离和分配优势，但功能有所不同，因为容器虚拟化的是操作系统，而不是硬件，因此容器更容易移植，效率也更高。")])]),r._v(" "),s("h3",{attrs:{id:"两者对比图"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#两者对比图"}},[r._v("#")]),r._v(" 两者对比图")]),r._v(" "),s("p",[r._v("传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\n")]),s("div",{attrs:{align:"center"}},[s("img",{attrs:{src:t(422),width:"100%"}})]),s("p"),r._v(" "),s("h3",{attrs:{id:"容器与虚拟机总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器与虚拟机总结"}},[r._v("#")]),r._v(" 容器与虚拟机总结")]),r._v(" "),s("div",{attrs:{align:"center"}},[s("img",{attrs:{src:t(423),width:"100%"}})]),r._v(" "),s("ul",[s("li",[s("strong",[r._v("容器是一个应用层抽象，用于将代码和依赖资源打包在一起。 多个容器可以在同一台机器上运行，共享操作系统内核，但各自作为独立的进程在用户空间中运行。")]),r._v(" 与虚拟机相比，"),s("strong",[r._v("容器占用的空间较少")]),r._v("（容器镜像大小通常只有几十兆），"),s("strong",[r._v("瞬间就能完成启动")]),r._v(" 。")]),r._v(" "),s("li",[s("strong",[r._v("虚拟机 (VM) 是一个物理硬件层抽象，用于将一台服务器变成多台服务器。")]),r._v(" 管理程序允许多个 VM 在一台机器上运行。每个 VM 都包含一整套操作系统、一个或多个应用、必要的二进制文件和库资源，因此 占用大量空间 。而且 "),s("strong",[r._v("VM 启动也十分缓慢")]),r._v(" 。")])]),r._v(" "),s("p",[s("strong",[r._v("虚拟机更擅长于彻底隔离整个运行环境")]),r._v("。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。而 "),s("strong",[r._v("Docker 通常用于隔离不同的应用")]),r._v(" ，例如前端，后端以及数据库。")]),r._v(" "),s("h2",{attrs:{id:"docker-基本概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker-基本概念"}},[r._v("#")]),r._v(" Docker 基本概念")]),r._v(" "),s("p",[s("strong",[r._v("Docker 有三个非常重要的基本概念：镜像（Image）、容器（Container）、仓库（Repository）")])]),r._v(" "),s("h3",{attrs:{id:"镜像-image-一个特殊的文件系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#镜像-image-一个特殊的文件系统"}},[r._v("#")]),r._v(" 镜像（Image）：一个特殊的文件系统")]),r._v(" "),s("p",[s("strong",[r._v("操作系统分为内核和用户空间。")]),r._v(" 对于 Linux 而言，内核启动后，会挂载 root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。")]),r._v(" "),s("p",[s("strong",[r._v("Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。")]),r._v(" 镜像不包含任何动态数据，其内容在构建之后也不会被改变。")]),r._v(" "),s("p",[r._v("Docker 设计时，就充分利用 Union FS 的技术，将其设计为"),s("strong",[r._v("分层存储")]),r._v("的架构 。镜像实际是由多层文件系统联合组成。"),s("strong",[r._v("镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。")]),r._v(" 比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。")]),r._v(" "),s("p",[r._v("分层存储的特征还使得镜像的复用、定制变的更为容易。甚至可以用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像。")]),r._v(" "),s("h3",{attrs:{id:"额外补充-linux-内核启动后-挂在root-文件系统的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#额外补充-linux-内核启动后-挂在root-文件系统的作用"}},[r._v("#")]),r._v(" 额外补充：Linux 内核启动后，挂在root 文件系统的作用？")]),r._v(" "),s("p",[r._v("在 Linux 中，内核启动后，挂载根文件系统（root filesystem）是非常重要的步骤，它对系统的正常运行起着关键作用。挂载根文件系统的主要作用如下：")]),r._v(" "),s("ol",[s("li",[s("strong",[r._v("提供操作系统核心功能")]),r._v("：根文件系统包含了操作系统的核心组件，例如 /bin、/sbin、/etc、/lib 等目录和文件。这些文件和目录存储了操作系统所需的基本工具、系统配置文件、共享库等，是系统正常运行所必需的。")]),r._v(" "),s("li",[s("strong",[r._v("存储用户空间程序和数据")]),r._v("：根文件系统还包含了用户空间程序和数据。用户空间程序位于 /usr/bin、/usr/sbin 等目录下，包括系统应用程序、服务、工具等。数据可以存储在 /var 目录下，包括日志文件、缓存、数据库等。挂载根文件系统使得这些用户空间程序和数据可供系统访问和运行。")]),r._v(" "),s("li",[s("strong",[r._v("提供文件系统层次结构")]),r._v("：根文件系统定义了整个文件系统的层次结构。根目录（/）是文件系统的顶级目录，其他目录和文件都是基于根目录进行组织。通过挂载根文件系统，整个文件系统层次结构可以在内核中建立起来，使得系统能够按照正确的路径访问和管理文件和目录。")]),r._v(" "),s("li",[s("strong",[r._v("设置挂载点")]),r._v('：挂载根文件系统还涉及到为根文件系统设置挂载点。挂载点是指将文件系统与特定目录进行关联，使得该目录下的文件和目录可以访问到相应的文件系统。通常，根文件系统的挂载点是根目录（"/"），所有其他目录和文件都是在其下面进行组织。')])]),r._v(" "),s("p",[r._v("总之，挂载根文件系统是为了将操作系统核心组件、用户空间程序、数据和文件系统层次结构纳入内核的管理范围，确保系统能够正常运行并提供所需的功能和服务。")]),r._v(" "),s("h3",{attrs:{id:"容器-container-镜像运行时的实体"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器-container-镜像运行时的实体"}},[r._v("#")]),r._v(" 容器（Container）：镜像运行时的实体")]),r._v(" "),s("p",[r._v("镜像和容器的关系，就像是面向对象程序设计中的类和实例一样，"),s("strong",[r._v("镜像是静态的定义，容器是镜像运行时的实体")]),r._v("。容器可以被创建、启动、停止、删除、暂停等。")]),r._v(" "),s("p",[s("strong",[r._v("容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。前面讲过镜像使用的是分层存储，容器也是如此。")])]),r._v(" "),s("p",[s("strong",[r._v("容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。")])]),r._v(" "),s("p",[r._v("按照 Docker 最佳实践的要求，"),s("strong",[r._v("容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录")]),r._v("，在这些位置的读写会跳过容器存储层，直接对宿主(或网络存储)发生读写，其性能和稳定性更高。"),s("strong",[r._v("数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡")]),r._v("。因此，使用数据卷后，容器可以随意删除、重新 run ，数据却不会丢失。")]),r._v(" "),s("h3",{attrs:{id:"对于-docker-中分层存储的更加深入的理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对于-docker-中分层存储的更加深入的理解"}},[r._v("#")]),r._v(" 对于 Docker 中分层存储的更加深入的理解：")]),r._v(" "),s("ol",[s("li",[s("p",[r._v("镜像的分层存储：Docker 镜像是通过一系列的文件系统层（Layers）组成的。每个镜像层包含了一个文件系统的快照，其中包括了应用程序、库、依赖项和配置等。这些镜像层按照层次结构堆叠在一起，形成了一个完整的镜像。"),s("strong",[r._v("镜像层之间是只读的，任何对镜像的修改都会创建一个新的镜像层")]),r._v("。这种分层存储的特性使得镜像可以实现共享和重用，"),s("strong",[r._v("不同镜像可以共享相同的层")]),r._v("，节省存储空间并加快下载速度。")])]),r._v(" "),s("li",[s("p",[r._v("容器的分层存储：Docker 容器在运行时是基于镜像创建的，它也使用了分层存储的概念。"),s("strong",[r._v("容器层是在镜像层之上创建的一层，用于存储容器运行时的变动和修改")]),r._v("。当容器启动时，Docker 会在镜像层之上创建一个"),s("strong",[r._v("可写的容器层")]),r._v("，这个层又被称为"),s("strong",[r._v("容器的存储层或写时复制层")]),r._v("。"),s("strong",[r._v("容器层是可读写的，并且允许容器进行修改和添加文件")]),r._v("。这种分层存储的机制使得"),s("strong",[r._v("容器可以共享相同的镜像层")]),r._v("，并且容器之间的修改不会相互影响，提高了资源利用效率和容器的启动速度。")])])]),r._v(" "),s("p",[r._v("通过使用分层存储，Docker实现了以下优势：")]),r._v(" "),s("ul",[s("li",[s("strong",[r._v("节省存储空间")]),r._v("：由于镜像和容器可以共享相同的层，避免了重复存储相同的文件，节省了存储空间。")]),r._v(" "),s("li",[s("strong",[r._v("快速启动和复制")]),r._v("：由于只需加载更改的层，而不是整个镜像或容器，因此启动和复制容器的速度更快。")]),r._v(" "),s("li",[s("strong",[r._v("高效的资源利用")]),r._v("：多个容器可以共享相同的镜像层，减少了资源的冗余使用。")]),r._v(" "),s("li",[s("strong",[r._v("可重用的镜像")]),r._v("：镜像的层次结构允许创建和管理可重用的基础镜像，并在其基础上构建其他镜像。")])]),r._v(" "),s("h3",{attrs:{id:"仓库-repository-集中存放镜像文件的地方"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#仓库-repository-集中存放镜像文件的地方"}},[r._v("#")]),r._v(" 仓库（Repository）：集中存放镜像文件的地方")]),r._v(" "),s("p",[r._v("镜像构建完成后，可以很容易的在当前宿主上运行，但是，"),s("strong",[r._v("如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。")])]),r._v(" "),s("p",[r._v("**一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。**所以说：镜像仓库是 Docker 用来集中存放镜像文件的地方类似于我们之前常用的代码仓库。")]),r._v(" "),s("p",[r._v("通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过 "),s("code",[r._v("<仓库名>:<标签>")]),r._v(" 的格式来指定具体是软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。")]),r._v(" "),s("p",[s("strong",[r._v("Docker Registry 公开服务和 私有 Docker Registry ：")])]),r._v(" "),s("ul",[s("li",[s("strong",[r._v("Docker Registry 公开服务")]),r._v("是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。"),s("br"),r._v("\n最常使用的 Registry 公开服务是官方的 Docker Hub ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：https://hub.docker.com/open。"),s("br"),r._v("\n除了直接通过 Docker Hub 网站搜索镜像这种方式外，还可以通过 "),s("code",[r._v("docker search")]),r._v(" 这个命令搜索 Docker Hub 中的镜像，搜索的结果是一致的。")]),r._v(" "),s("li",[r._v("用户还可以在"),s("strong",[r._v("本地搭建私有 Docker Registry")]),r._v(" 。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。")])]),r._v(" "),s("h2",{attrs:{id:"常用命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常用命令"}},[r._v("#")]),r._v(" 常用命令")]),r._v(" "),s("h3",{attrs:{id:"基本命令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基本命令"}},[r._v("#")]),r._v(" 基本命令")]),r._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" version      "),s("span",{pre:!0,attrs:{class:"token comment"}},[r._v("# 查看 docker 版本")]),r._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" images       "),s("span",{pre:!0,attrs:{class:"token comment"}},[r._v("# 查看所有已下载镜像，等价于：docker image ls 命令")]),r._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" container "),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("ls")]),r._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[r._v("# 查看所有容器")]),r._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("ps")]),r._v("           "),s("span",{pre:!0,attrs:{class:"token comment"}},[r._v("# 查看正在运行的容器")]),r._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" image prune  "),s("span",{pre:!0,attrs:{class:"token comment"}},[r._v("# 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；")]),r._v("\n")])])]),s("h3",{attrs:{id:"拉取镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#拉取镜像"}},[r._v("#")]),r._v(" 拉取镜像")]),r._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" search mysql     "),s("span",{pre:!0,attrs:{class:"token comment"}},[r._v("# 查看 mysql 相关镜像")]),r._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" pull mysql:5.7   "),s("span",{pre:!0,attrs:{class:"token comment"}},[r._v("# 拉取 mysql 镜像")]),r._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" image "),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("ls")]),r._v("         "),s("span",{pre:!0,attrs:{class:"token comment"}},[r._v("# 查看所有已下载镜像")]),r._v("\n")])])]),s("h3",{attrs:{id:"删除镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#删除镜像"}},[r._v("#")]),r._v(" 删除镜像")]),r._v(" "),s("p",[r._v("通过 "),s("code",[r._v("docker rmi [image]")]),r._v(" （等价于 "),s("code",[r._v("docker image rm [image]")]),r._v("）删除镜像（可以通过标签名称或者镜像 ID 删除）。但在这之前首先要确保这个镜像没有被容器引用（可以通过 "),s("code",[r._v("docker ps")]),r._v(" 命令查看），若镜像正在被容器引用，需要先通过 "),s("code",[r._v("docker stop [containerId]")]),r._v(" 命令或 "),s("code",[r._v("docker stop [image]")]),r._v(" 暂停这个容器。")]),r._v(" "),s("div",{staticClass:"language-sh extra-class"},[s("pre",{pre:!0,attrs:{class:"language-sh"}},[s("code",[r._v("➜  ~ "),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("ps")]),r._v("\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\nc4cd691d9f80        mysql:5.7           "),s("span",{pre:!0,attrs:{class:"token string"}},[r._v('"docker-entrypoint.s…"')]),r._v("   "),s("span",{pre:!0,attrs:{class:"token number"}},[r._v("7")]),r._v(" weeks ago         Up "),s("span",{pre:!0,attrs:{class:"token number"}},[r._v("12")]),r._v(" days          "),s("span",{pre:!0,attrs:{class:"token number"}},[r._v("0.0")]),r._v(".0.0:3306-"),s("span",{pre:!0,attrs:{class:"token operator"}},[r._v(">")]),s("span",{pre:!0,attrs:{class:"token number"}},[r._v("3306")]),r._v("/tcp, "),s("span",{pre:!0,attrs:{class:"token number"}},[r._v("33060")]),r._v("/tcp   mysql\n\n➜  ~ "),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" images\nREPOSITORY              TAG                 IMAGE ID            CREATED             SIZE\nmysql                   "),s("span",{pre:!0,attrs:{class:"token number"}},[r._v("5.7")]),r._v("                 f6509bac4980        "),s("span",{pre:!0,attrs:{class:"token number"}},[r._v("3")]),r._v(" months ago        373MB\n\n➜  ~ "),s("span",{pre:!0,attrs:{class:"token function"}},[r._v("docker")]),r._v(" rmi f6509bac4980 "),s("span",{pre:!0,attrs:{class:"token comment"}},[r._v("#  或者 docker rmi mysql")]),r._v("\n")])])]),s("h2",{attrs:{id:"build、ship、run"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#build、ship、run"}},[r._v("#")]),r._v(" Build、Ship、Run")]),r._v(" "),s("ul",[s("li",[s("strong",[r._v("Build（构建镜像）")]),r._v("：镜像就像是集装箱包括文件以及运行环境等等资源。")]),r._v(" "),s("li",[s("strong",[r._v("Ship（运输镜像）")]),r._v("：主机和仓库间运输，这里的仓库就像是超级码头一样。")]),r._v(" "),s("li",[s("strong",[r._v("Run（运行镜像）")]),r._v("：运行的镜像就是一个容器，容器就是运行程序的地方。")])]),r._v(" "),s("p",[r._v("**Docker 运行过程也就是去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。**所以，我们也常常将 Docker 称为码头工人或码头装卸工，这和 Docker 的中文翻译搬运工人如出一辙。")]),r._v(" "),s("h2",{attrs:{id:"参考文献"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[r._v("#")]),r._v(" 参考文献")]),r._v(" "),s("ul",[s("li",[r._v("https://javaguide.cn/tools/docker/docker-intro.html")])])])}),[],!1,null,null,null);s.default=_.exports}}]);